<html><head><meta name="viewport" content="width=device-width, initial-scale=1"> <meta http-equiv="content-type" content="text/html; charset=UTF-8"> <link rel="stylesheet" href="acldoc-styles.css" type="text/css"><title>Runtime analyzer</title></head><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/runtime-analyzer.htm">10.0 version</a></td></tr></table><h1 id="2">Runtime analyzer</h1><p id="3">This document contains the following sections:</p><a href="#profile-intro-1">1.0 Runtime analyzer Introduction</a><br><a href="#three-profilers-1">2.0 The three types of analysis: general information</a><br>&nbsp;&nbsp;&nbsp;<a href="#time-profiler-2">2.1 The time analyzer</a><br>&nbsp;&nbsp;&nbsp;<a href="#spaceprofiler-2">2.2 The space analyzer</a><br>&nbsp;&nbsp;&nbsp;<a href="#call-counting-2">2.3 The call-counting profiler</a><br><a href="#profiler-invocation-1">3.0 Invoking the  runtime analyzer</a><br><a href="#further-info-1">4.0 Further points, including information on temporary files</a><br>&nbsp;&nbsp;&nbsp;<a href="#text-section-2">4.1 Profiling error: could not read text section</a><br><a href="#controlling-operation-1">5.0 Controlling the operation of data collection</a><br>&nbsp;&nbsp;&nbsp;<a href="#data-collection-control-2">5.1 Control of data collection</a><br>&nbsp;&nbsp;&nbsp;<a href="#profiling-mp-2">5.2 Runtime analysis with multiprocessing enabled</a><br>&nbsp;&nbsp;&nbsp;<a href="#closures-in-profiler-2">5.3 Closures in runtime analysis output</a><br><a href="#profiler-results-1">6.0 Interpreting the results</a><br>&nbsp;&nbsp;&nbsp;<a href="#call-count-results-2">6.1 Call-count results</a><br>&nbsp;&nbsp;&nbsp;<a href="#space-and-time-2">6.2 Space and time results</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#disassemble-profile-3">6.2.1 The disassemble-profile function</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#result-header-3">6.2.2 A note on the header in results</a><br>&nbsp;&nbsp;&nbsp;<a href="#profiler-examples-2">6.3 Examples</a><br><a href="#sfp-header-1">Appendix A. Headers in show-flat-profile and show-call-graph output</a><br><hr><hr><h2 id="4"><a name="profile-intro-1">1.0 Runtime analyzer Introduction</a></h2>

<p id="5">
The runtime analyzer is a tool to make Lisp programs more
efficient. Runtime analyzer information tells you which parts of the
program run slowly or use a lot of space (thus increasing garbage
collection). Once you know this, you can improve efficiency by
optimizing (see <a href="compiling.htm">compiling.htm</a>) or by recoding.
</p>
<p id="6">
The Runtime Analyzer works on all platforms. (Problems with the
Runtime Analyzer on AMD 64 processors reported in earlier versions of
this document, have been resolved. That processor is used by 64-bit
Allegro CL on Linux and 64-bit Allegro CL on x86 Solaris.)
</p>

<p id="7">
Allegro CL provides three runtime analysis tools for assisting users in
determining where time is spent or space is used. Most powerful are
the space and time analyzers which statistically sample a running
program to determine which functions use the most time or which use
the most space. The call-counting profiler keeps a count of the number
of times a compiled function is actually called while a program is
running.</p>

<p id="8">
Allegro Composer extends the space and time analyzers by providing a
graphical display of the results as well as the ability to start and
stop the profilers graphically. Without Allegro Composer, all the same
information is gathered and reported but the information is printed to
the terminal.
</p>

<p id="9">
The Allegro CL Integrated Development Environment in Windows also
provides a graphical display of runtime analyzer data and various menu
commands for starting and stopping analysis. See the description on
the <a href="ide-menus-and-dialogs/runtime-analyzer-results-dialog.htm">Runtime Analyzer
Results</a> dialog in the IDE help file. The IDE additionally
provides a <a href="ide-menus-and-dialogs/runtime-analyzer-control-dialog.htm">Runtime Analyzer
Control</a> dialog which provides graphic tools for starting,
suspending, and stopping profiles and for controlling what is
profiled.
</p>

<p id="10">
We describe the four types of
runtime analyzer below. Later sections describe how to use the runtime
analyzer and how to interpret the results. Please note the following:
</p>

<ul>
<li id="11">
A single analysis run can collect space or time information 
but not both.
</li>
<li id="12">
Call-counting information can be collected at the same time as space
or time information, but the resulting time data is skewed because the
(non-trivial) time spent counting function calls is included. (Space
results are unaffected since the call-counting code does not cons.)
</li>
<li id="13">
You should analyze exactly the code you are interested in. Extraneous
code simply skews the results. In particular, do not wrap the time
macro around code to be analyzed.
</li>
</ul>


<hr><hr><h2 id="14"><a name="three-profilers-1">2.0 The three types of analysis: general information</a></h2>

<hr><h2 id="15"><a name="time-profiler-2">2.1 The time analyzer</a></h2>

<p id="16">
The time analyzer collects data by interrupting execution of the
Lisp periodically and recording the functions on the execution
stack. The variable <a href="variables/prof/s_granularity_s.htm"><code>*granularity*</code></a> controls how often
execution is interrupted. Its value is the integer number of machine
clock ticks between samples.
</p>

<p id="17">A machine clock tick occurs approximately every 0.01 seconds (the
exact value is machine dependent). In that time, the machine will
typically execute tens of thousands of machine instructions. The
statistical nature of the time analyzer should therefore be
evident. However, under reasonable assumptions concerning lack of
interaction between execution of your program and machine clock ticks
and with sufficient samples, the information gathered by the sampling
process will closely mirror the actual behavior of the code which is
executed.</p>

<p id="18">The `reasonable assumptions' state that (1) there is no cycle in
the program harmonic with the program interrupting time so that the
interrupting times do provide a random sample of program execution and
(2) if your program does several different things, enough time is
spent on each to provide statistically significant results. Several
thousand samples are statistically sufficient. Of course, functions
where your code spends very little time may be missed altogether by
the time analyzer. However, the purpose of the runtime analyzer is to
assist you in making your code run faster, and functions which use
little time are not important in achieving that result.
</p>



<hr><h2 id="19"><a name="spaceprofiler-2">2.2 The space analyzer</a></h2>

<p id="20">
The space analyzer tries to identify the functions which use the most
space. Like the time analyzer, the space analyzer is statistical but
the method for sampling is quite different.
</p>

<p id="21">
The time analyzer stops execution regularly and examines the
stack. The space analyzer stops execution whenever a page of memory is
allocated. The statistical nature of the space analyzer arises from
the fact that the function which calls for a page of memory will not
(typically) use it all. After the function which called for the page
has completed, there may be sufficient room left on the page for the
space requirements of the next function. Therefore, only the first
function is charged with needing space even though both functions used
the space.
</p>

<p id="22">
The assumption of the space analyzer is that the requirement for
new pages of memory occurs randomly and in proportion to the amount of
space actually required by a function.  So given a reasonably large
sample, the functions that use large amounts of space will have
proportionally large amounts of space attributed to them by the
analyzer.
</p>

<p id="23">In Allegro CL, memory is organized into three kinds of objects:
symbols, conses, and other. Both symbols and conses have a specific
size and so a known number can fit on a page. Other Lisp objects
require variable amounts of memory (depending on what information they
contain). All objects other than symbols and conses are stored on
other pages.</p>

<p id="24">
The space analyzer thus records information whenever one of the
functions which allocate a new page of memory is requested. The
request can come from the internal function _page_from_new (for
symbols and conses) or from the function new_other (for other
objects). These functions are deep in the system and are not typically
user visible. On machines where this is possible, during analysis,
hooks associated with those two functions stop execution when they are
called and record information about what is on the stack. Note that
because of the way stack linking is done on certain machines, you may
not see the actual _page_from_new calls, but rather Lisp functions
(such as <b>cons</b>) which trigger the calls. These analyses are
harder to interpret, but the stack linking requirements make it
impossible to list these calls with more accuracy. (The examples in
the document are from platforms that do show _page_from_new.)
</p>

<p id="25">
Note that the time macro also provides information on space used by
the form evaluated.  This information is quite accurate (in some
cases, the total space used is more accurately reported by the time
macro than by the space analyzer). Time does not provide a breakdown
of what within a form caused space usage and that is what the space
analyzer is designed to do.
</p>



<hr><h2 id="26"><a name="call-counting-2">2.3 The call-counting profiler</a></h2>

<p id="27">
The call-counting profiler is integrated with the space and time
analyzers. No special compilation is necessary for calls to a function
to be counted, but you must tell the system to keep counts by
specifying true values for the <i>:count</i> or
<i>:count-list</i> keyword arguments when the runtime
analyzer is started. (However, see <a href="variables/compiler/verify-funcalls-switch.htm"><code>verify-funcalls-switch</code></a>. <a href="../ansicl/dictentr/funcall.htm"><b>funcall</b></a>'ed functions in certain cases
in compiled code will not be counted if the call was compiled with
that compiler switch false.)  Any function can be call-counted. The
count is exact, not statistical.  The only `calls' that will be missed
are where a function is compiled inline and the inline code is
executed, and, on certain architectures, calls triggered by
funcall. Note that the overhead for counting calls can be significant,
and that overhead is recorded by the time analyzer. There is no space
overhead, so the space analyzer results are unaffected. Therefore, the
reported time usage is skewed by the call-counting overhead when a
time analysis also does call-counting. The time results are still
useful, but must be interpreted with care and a time-only analysis
should not be compared with a time and call-counting analysis.</p>




<hr><hr><h2 id="28"><a name="profiler-invocation-1">3.0 Invoking the  runtime analyzer</a></h2>

<p id="29">Unless otherwise indicated, the symbols described in this section
are in the <b>profiler</b> (nicknamed prof) package.</p>

<p id="30">In order to do a runtime analysis, you need to start it and stop it. You
can start it with <a href="operators/prof/start-profiler.htm"><b>start-profiler</b></a> and stop it with
<a href="operators/prof/stop-profiler.htm"><b>stop-profiler</b></a> or you
can use the macro <a href="operators/prof/with-profiling.htm"><b>with-profiling</b></a> to cause the runtime analyzer
to be run while a specific body of code is executed. The variable
<a href="variables/prof/s_maxsamples_s.htm"><code>*maxsamples*</code></a>
controls the maximum number of samples that will be taken. Data collection
will stop when that number of samples has been recorded even if
<a href="operators/prof/stop-profiler.htm"><b>stop-profiler</b></a> is not
called or the code specified to <a href="operators/prof/with-profiling.htm"><b>with-profiling</b></a> has not completed.</p>

<p id="31">Note that it is important to distinguish between starting and
stopping data collection and suspending data collection. 
<a href="operators/prof/start-profiler.htm"><b>start-profiler</b></a>
and 
<a href="operators/prof/stop-profiler.htm"><b>stop-profiler</b></a>
are the beginning and end of a data collection run. No data is collected
before 
<a href="operators/prof/start-profiler.htm"><b>start-profiler</b></a>
is called and none can be collected after 
<a href="operators/prof/stop-profiler.htm"><b>stop-profiler</b></a>
is called. Temporary suspension of data collection is done with the
functions <a href="operators/prof/start-sampling.htm"><b>start-sampling</b></a> and <a href="operators/prof/stop-sampling.htm"><b>stop-sampling</b></a>. On Windows using the
Integrated Development Environment, commands on the Run menu can be
used to start and stop data collection and sampling.
</p>

<p id="32">The macro <a href="operators/prof/with-profiling.htm"><b>with-profiling</b></a> can be used to collect data
on the evaluation of specific forms. The macro <a href="operators/prof/with-sampling.htm"><b>with-sampling</b></a> similarly can be used to
sample only as specific forms are evaluated.</p>

<hr><hr><h2 id="33"><a name="further-info-1">4.0 Further points, including information on temporary files</a></h2>

<p id="34">Please note the following about time and space data collection. </p>

<ul>
<li id="35">
If an error occurs during the data collection, you should restart the
runtime analyzer run from the beginning to ensure a more accurate
result.
</li>
<li id="36">
Tail merging done by the compiler can cause some results to
look different from what is expected. See the <a href="compiling.htm#tail-merge-disc-2">discussion of tail
merging</a> in the compiling document
<a href="compiling.htm">compiling.htm</a>.
</li>
<li id="37">
There are subtleties about collecting data on non-null closure
functions. Although each copy of a non-null closure that gets created
during program execution is a distinct object, the runtime analyzer
combines the samples for all copies and reports the results as if
there were only one copy.
</li>
<li id="38">
The runtime analyzer writes data files to a temporary location. these
files are removed after analysis. The temporary location is either
<em>/usr/tmp</em> or <em>/tmp</em>. Which is determined when
<em>prof.fasl</em> is loaded into the system (usually at image build
time, so the setting might be wrong). The information on which to use
is stored in two (unexported) variables:
<code>prof::*sizefile-template*</code> and
<code>prof::*samplefile-template*</code>, whose values are either
&quot;/usr/tmp/sizes&quot; and &quot;/usr/tmp/sample&quot; or
&quot;/tmp/sizes&quot; and &quot;/tmp/sample&quot;. (The actual data
files have filenames longer than sizes and sample.) You may change the
values of these variables if the wrong or an inappropriate temporary
directory is specified. The values must be strings like
&quot;&lt;my-tmp-dir&gt;/sizes&quot; and
&quot;&lt;my-tmp-dir&gt;/sample&quot; where &lt;my-tmp-dir&gt; is the
absolute path of the directory you want to use.
</li>
<li id="39">
Functions and variables provided with the runtime analyzer give you
some control over exactly what is profiled. These functions and
variables are described immediately below.
</li>
</ul>

<hr><h2 id="40"><a name="text-section-2">4.1 Profiling error: could not read text section</a></h2>

<p id="41">
You may see this message when collecting data. This section explains
what it means. The reading of the C symbol table into lisp form has
been enhanced to not only include symbols from the executable itself
(which has itself shrunk to a very small size) but also any
shared-libraries that the lisp uses, including the heart of the lisp
itself. The function <a href="operators/ff/list-all-foreign-libraries.htm"><b>list-all-foreign-libraries</b></a> lists
those libraries whose symbols Allegro attempts to read in. </p>

<p id="42">
Sometimes, the shared-libraries do not have the necessary headers
and sections that are needed for proper building of a C symbol table
in lisp. In these cases, a profiler-error is given, for example: 
</p>

<pre id="43">
USER(2): (prof:show-flat-profile) 
profiler error: couldn't find .text section 
profiler error: couldn't find .text section 
</pre>

<p id="44">
In this case (on a Sparc Solaris 2.6) two libraries did not have
<em>.text</em> sections, so no symbols are recorded for those two
libraries.
</p>

<p id="45">
The failure to find symbols is not fatal. The debugging tools that use
the libraries are simply not able to give as complete information as
if the symbols had been available. The same soft failure occurs when a
symbol in a <em>.so</em> had been declared static (or in the case of
Windows, any C symbol not explicitly
<strong>DllExport</strong>-ed). The exact failure mode depends on the
arrangement of the functions in memory; a function at one address
whose symbol was not properly recorded will appear to be part of the
next-lower-addressed function whose name was recorded.
</p>



<hr><hr><h2 id="46"><a name="controlling-operation-1">5.0 Controlling the operation of data collection</a></h2>

<p id="47">
The status of the data collecting can be determined at any time using
the function <a href="operators/prof/profiler-status.htm"><b>profiler-status</b></a>. Called with no arguments,
it returns the status of the current profile.  The status can be one
of the following: </p>

<blockquote>
<ul>
<li id="48">
<code>:inactive</code> -- data collection has not yet 
started
</li>
<li id="49">
<code>:suspended</code> -- data collection has started, but sampling 
is currently not being done
</li>
<li id="50">
<code>:sampling</code> -- data collection has started and 
sampling is occurring
</li>
<li id="51">
<code>:saved</code> -- data collection has been stopped, but as yet no
analysis of saved data has occurred
</li>
<li id="52">
<code>:analyzed</code> -- all data has been analyzed
</li>
</ul>
</blockquote>

<p id="53">A finalized analysis (profiler-status returns
<code>:analyzed</code>) can be saved using the macro <a href="operators/prof/save-current-profile.htm"><b>save-current-profile</b></a>.  It takes a variable
name (i.e. a symbol) as an argument and the profile data is made the
value of that variable.</p>

<p id="54">Saving an analysis with <a href="operators/prof/save-current-profile.htm"><b>save-current-profile</b></a> allows you to analyze
data at your leisure, running other analyses in the meantime. The
keyword argument <code>:current-profile</code> to <a href="operators/prof/show-call-graph.htm"><b>show-call-graph</b></a> and <a href="operators/prof/show-flat-profile.htm"><b>show-flat-profile</b></a> can take a
saved profile instead of the default (which is the currently running
or last run analysis) and display results using that data.</p>

<hr><h2 id="55"><a name="data-collection-control-2">5.1 Control of data collection</a></h2>

<p id="56">Fairly fine control is provided over the collection of data while
the data is being collected. Sampling can be started and stopped with
the functions start-sampling and stop-sampling. The macro
with-sampling can be used to sample just while specified forms are
evaluated. Note that data collection started with the function <a href="operators/prof/start-profiler.htm"><b>start-profiler</b></a> may start
sampling immediately or may delay sampling (depending on
the value of the keyword <code>:start-sampling-p</code>).</p>

<p id="57">
The variables <a href="variables/prof/s_maxsamples_s.htm"><code>*maxsamples*</code></a> and <a href="variables/prof/s_granularity_s.htm"><code>*granularity*</code></a> also control the behavior of
the runtime analyzer. The first puts a limit on the number of samples
collected. 
Its initial value is <a href="../ansicl/dictentr/most-pos.htm"><code>most-positive-fixnum</code></a>. The
second specifies the time interval between time samples. The units are
clock ticks, an internal value usually about 1/100 of a second (during
which time thousands of machine instructions are executed). The space
analyzer, which is not statistical in the same way, ignores the value
of <a href="variables/prof/s_granularity_s.htm"><code>*granularity*</code></a>.
</p>

<p id="58">When data is being collected, everything done in Lisp is sampled,
including the runtime analyzer itself. The runtime analyzer overhead
(for either space or time) is small. The runtime analyzer can be
turned on and off (that is suspended and resumed) with the functions
<a href="operators/prof/start-sampling.htm"><b>start-sampling</b></a> and
<a href="operators/prof/stop-sampling.htm"><b>stop-sampling</b></a>.</p>

<p id="59">After data collection completes, the data is stored within Lisp. If
you wish to analyze the data, you must do so before sampling for
another analysis is started. (You can, however, begin an analysis of
the collected data and save it for later detailed analysis). If after
data is collected, collecting data for a new runtime analysis is
started, the data collected by the previous runtime analysis will be
lost.</p>

<p id="60">
As an example of how to use these functions, we show how to collect
data on a single function <strong>foo</strong> that never calls itself
embedded in a larger piece of code. Suppose we want to analyze
<b>foo</b> alone, the steps are as follows:
</p>

<blockquote>
  <blockquote>
    <p id="61">1. Fwrap the function <strong>foo</strong> with the following
    form. (Fwrapping code is described in <a href="fwrappers-and-advice.htm">fwrappers-and-advice.htm</a>.)</p>
    <pre id="62">
    (def-fwrapper timer-wrap (&rest args)
      (prog2 
        (prof:start-sampling) 
        (call-next-fwrapper)
        (prof:stop-sampling)))
    (fwrap 'foo 'timer-fw1 'timer-wrap)
</pre>
    <p id="63">2. Start the runtime analyzer with 
    <a href="operators/prof/start-profiler.htm"><b>start-profiler</b></a>
    with nil as the value of the keyword <code>:start-sampling-p</code>. This prepares the runtime analyzer to collect data without actually beginning sampling.</p>
    <p id="64">3. Run the code containing calls to <strong>foo</strong>. </p>
    <p id="65">4. Stop data collection when done. </p>
  </blockquote>
</blockquote>

<p id="66">It should be clear why <strong>foo</strong> cannot call itself: the
fwrapper code placed around <strong>foo</strong> will cause data collection to
stop when the embedded call to <strong>foo</strong> returns even
though the original call is still being evaluated. If a function does
call itself (or calls another function which calls it back), use the
following code:</p>

<pre id="67">
(defparameter *prof-depth* 0)
(def-fwrapper timer-wrap-2 (&rest args)
  (prog2 
     (progn (incf *prof-depth*) (if (= 1 *prof-depth*) 
                                    (prof:start-sampling)))
           (call-next-fwrapper)
           (decf *prof-depth*)
           (if (zerop *prof-depth*) (prof:stop-sampling))))
(fwrap 'foo 'timer-fw2 'timer-wrap-2)
</pre>

<p id="68">
Collecting data on more than one function is more complex, because of
embedded calls. Unless you are sure that the functions you are
interested in never call each other, you must use global variables as
flags or semaphores as above to be sure that data collection is done
exactly when you want.
</p>



<hr><h2 id="69"><a name="profiling-mp-2">5.2 Runtime analysis with multiprocessing enabled</a></h2>

<p id="70">
This section describes the interaction between the runtime analyzer
and the multiprocessing capabilities of Allegro Common Lisp. The
multiprocessing facility is described in
<a href="multiprocessing.htm">multiprocessing.htm</a>. The runtime analyzer has the
ability to collect data on all processes or just a selected set.
</p>

<p id="71">
Data collection on processes can be controlled on a process by process
basis with the function <a href="operators/mp/profile-process-p.htm"><b>mp:profile-process-p</b></a> which returns
the value of the <em>profile-process-p</em> flag of an argument
process object. If that flag is <code>nil</code>, samples
are not collected when the process is running. Setf can be used to
change the value of that flag on a process.
</p>

<p id="72">The operators <a href="operators/prof/start-profiler.htm"><b>start-profiler</b></a> and <a href="operators/prof/with-profiling.htm"><b>with-profiling</b></a> accept the keyword argument
<code>:except-processes</code> (on platforms that use OS threads,
Windows only in 7.0) or <code>:except-stackgroups</code>
(non-OS-threads paltforms) which allows another form of control over
which processes have data collected on them. By giving a list of
processes as the value of that argument, you can prohibit the runtime
analyzer from collecting samples for the given processes. The Process
Browser in Allegro Composer (on UNIX) provides a way to set this flag
with the mouse.</p>



<hr><h2 id="73"><a name="closures-in-profiler-2">5.3 Closures in runtime analysis output</a></h2>

<p id="74">
The runtime-analyzer has been enhanced to separate closure
calls. <a href="operators/prof/start-profiler.htm"><b>start-profiler</b></a>
and <a href="operators/prof/with-profiling.htm"><b>with-profiling</b></a> have
a new keyword called <code>:interpret-closures</code>. When
<code>:interpret-closures</code> is <code>nil</code> (the
default) the closures are not saved and analyzed separately so the
behavior is the same as in earlier releases.When
true, closures are saved and analyzed as separate
entries, even though they may use the same template
function. </p>

<p id="75">
A function spec called <code>closure</code> has been added
(see <a href="implementation.htm">implementation.htm</a> for
information on function specs). This is valid whenever analyzed
data exists and identifies the closures which the runtime analyzer has
seen. The function spec is <code>(prof:closure <em>n</em>)</code>
where <em>n</em> is a small integer enumerating the closures in the
data. This allows the user to grab the closure object and to do a
<a href="operators/prof/disassemble-profile.htm"><b>disassemble-profile</b></a>
on it without having to know what symbol holds its
<code>fdefinition</code> (sometimes this is very hard).
</p>

<p id="76">When flat analyses and call-graphs are reported, closures are
identified by <code>(prof:closure <em>n</em>)</code>, followed by the
printed representation of the closure object itself.</p>



<hr><hr><h2 id="77"><a name="profiler-results-1">6.0 Interpreting the results</a></h2> 

<p id="78">
Space and time analysis results can be displayed graphically if you
are running Allegro Composer (using an X window) but can only be
printed to the terminal if you are not. Graphical display on UNIX is
described in <a href="composer.htm#composer-profiling-1">The window interface to the runtime
analyzer</a> of the <a href="composer.htm">Allegro
Composer User Guide</a>. Graphical display on Windows uses the
<a href="ide-menus-and-dialogs/runtime-analyzer-results-dialog.htm">Runtime Analyzer
Results</a> dialog. The system will display space or time data
automatically according to what kind of data was collected.
</p>
<p id="79">
See also <a href="#disassemble-profile-3">Section 6.2.1 The disassemble-profile function</a> for how
to display profile data in a disassembly.
</p>

<p id="80">
Note that you should not collect data for additional analyses once you
have started to display results on the terminal. Only do another
runtime analyzer run when your analysis is complete. Note too that you
can save the results with <a href="operators/prof/save-current-profile.htm"><b>save-current-profile</b></a>.
</p>

<p id="81">You can look at the data in two ways: a flat analysis and a
call-graph. A flat analysis shows the time or space information sorted
by function from largest consumer of time or space to least
consumer.</p>

<p id="82">The call-graph format shows information about the callers and
callees of each function grouped with the information about the
function.</p>

<hr><h2 id="83"><a name="call-count-results-2">6.1 Call-count results</a></h2>

<p id="84">The two functions <a href="operators/prof/show-call-counts.htm"><b>show-call-counts</b></a> and <a href="operators/prof/list-call-counts.htm"><b>list-call-counts</b></a> report call-count
results. The first prints the results and the second returns them in a
list.  (See the definitions of the functions for information on
specifying an analysis other than the current one and controlling
the number of functions about which information is printed.)</p>



<hr><h2 id="85"><a name="space-and-time-2">6.2 Space and time results</a></h2>

<p id="86">The function <a href="operators/prof/show-flat-profile.htm"><b>show-flat-profile</b></a> prints a flat analysis to
<code>*standard-output*</code> (or another stream if you desire).
There is an example of a flat analysis output below.</p>

<p id="87">The function <a href="operators/prof/show-call-graph.htm"><b>show-call-graph</b></a> allows you to examine
which functions have been called. Here is how it works.</p>

<p id="88">For each function, F, a call-graph shows the functions that called
it (parents of F) and the functions that it called (children of
F). Roughly speaking, a call-graph is the flat analysis display
expanded to show parents and children. The display for function F is
surrounded by dashed lines. F's display shows first information about
the parents of F, then information about F itself, then information
about F's children. (See the example later in this section.)</p>

<p id="89">The following algorithm is used to find the parents of a function
F. Each sample is examined and if F appears in the control
stack, the function calling F is recorded as the parent. If F appears
more than once in the control stack, all the different parents
(callers) are recorded, but if the same caller calls F several times
in the stack, only the oldest instance is recorded. The time spent in
(or the space used by) F and its descendents due to calls by a
particular parent is proportional to the ratio of the number of
samples where this particular parent of F was found to the total
number of samples.</p>

<p id="90">The algorithm for finding children is as follows. Each sample is
examined and if F is in the control stack, the function it calls is
recorded as its child. If F appears more than once in the stack, each
different child is recorded but if the same child appears more than
once, only the oldest instance is recorded. The time spent in (or the
space used by) a particular child and its descendents due to calls by
F is proportional to the ratio of the number of samples where this
particular child of the function F was found to the number of
samples.</p>

<p id="91">If there is a recursive entry in a call-graph, then the local %
entry for that function will have an <em>r</em> after it. If there is
a recursive entry, then time attributed to this entry may be counted
twice because of recursion. For example, if <strong>bar</strong> calls
<strong>baz</strong> calls <strong>foo</strong> calls
<strong>baz</strong>, then <strong>foo</strong> and
<strong>bar</strong> are parents of <strong>baz</strong>, and there
will be two entries for parents of baz, corresponding to only 1 clock
tick (sample). So the report shows two lines (one for
<strong>foo</strong> and one for <strong>bar</strong>), but the time
is double counted. Similarly for a child case: <strong>bar</strong>
calls <strong>foo</strong> calls <strong>bar</strong> calls
<strong>baz</strong>. Then <strong>foo</strong> and
<strong>baz</strong> are both children of <strong>bar</strong>
(reported on 2 separate lines in the report) corresponding to
only 1 sample.</p>

<p id="92">The output of a flat analysis and particularly of a call-graph may
be voluminous. In order to reduce the amount of data to a manageable
amount, the default display of either a flat analysis or a call-graph
suppresses some internal functions and packages. When a package is
hidden, functions named by symbols in the package are not
displayed. The functions and packages suppressed are in the lists
<a href="variables/prof/s_hidden-functions_s.htm"><code>*hidden-functions*</code></a> and <a href="variables/prof/s_hidden-packages_s.htm"><code>*hidden-packages*</code></a>,
respectively. You can suppress display of extra functions by adding
them to the list that is the value of *hidden-functions*. You can
suppress the display of extra packages (that is, of functions named by
symbols in the packages) by adding them to the list that is the value
of <a href="variables/prof/s_hidden-packages_s.htm"><code>*hidden-packages*</code></a>.</p>

<p id="93">When functions are suppressed from the display, the runtime
analyzer attributes any effects these functions might have had to the
function that called them. So, assuming the calling function is itself
not suppressed from the display, the calling function in the runtime
analyzer display can be thought of as a kind of composite, made up of
itself and the suppressed function(s) it called. Functions which the
runtime analyzer records as calling hidden functions are indicated in
the runtime analyzer display by prepending "..." to the
function name.</p>

<p id="94">In a call graph all directly called undisplayed functions are
attributed to the caller.  Such undisplayed functions may eventually
directly or indirectly call displayed functions, which will be shown
in the call graph as children of the original caller. I.e., if foo
calls bar calls baz, and bar is suppressed, then foo will be displayed
as "...  foo" and baz will be shown as a child of foo. foo
gets dots because it can be thought of as a composite of foo and bar
(as we explained above). </p>

<p id="95">Sometimes a called function and all its descendants may be
suppressed (e.g., none of them are displayable), in which case the
runtime analyzer display just uses "..." to indicate that there are
completely suppressed cases.</p>

<p id="96">You can further control the amount of analysis you see with the variables <a href="variables/prof/s_significance-threshold_s.htm"><code>*significance-threshold*</code></a>
and <a href="variables/prof/s_fractional-significance-threshold_s.htm"><code>*fractional-significance-threshold*</code></a>.</p>

<p id="97">The variable <a href="variables/prof/s_hidden-space-functions_s.htm"><code>*hidden-space-functions*</code></a> lists
functions (mostly kernel functions named with strings rather than
symbols) whose suppression makes the space analyzer output more
understandable. The functions mostly actually allocate space requested
(directly or implicitly) by other functions presumably of more
interest.</p>

<p id="98">Note several things about the display control variables we have just discussed. </p>

<ul>
<li id="99">
They only affect the display of runtime analyzer data, not the
collection of that data. Therefore, with the results of a analysis
available, you can display the data with various values for these
variables.
</li>
<li id="100">
Setting <a href="variables/prof/s_hidden-packages_s.htm"><code>*hidden-packages*</code></a>, <a href="variables/prof/s_hidden-functions_s.htm"><code>*hidden-functions*</code></a>, and <a href="variables/prof/s_hidden-space-functions_s.htm"><code>*hidden-space-functions*</code></a>
all to nil and setting both <a href="variables/prof/s_significance-threshold_s.htm"><code>*significance-threshold*</code></a> and <a href="variables/prof/s_fractional-significance-threshold_s.htm"><code>*fractional-significance-threshold*</code></a> to 0.0
results in all available detail from the run being displayed.
</li>
<li id="101">
These variables also affect the graphical display provided by Allegro
Composer.
</li>
</ul>

<p id="102">You can always reset the value of the five display control
variables, 
<a href="variables/prof/s_hidden-packages_s.htm"><code>*hidden-packages*</code></a>, <a href="variables/prof/s_hidden-functions_s.htm"><code>*hidden-functions*</code></a>, <a href="variables/prof/s_hidden-space-functions_s.htm"><code>*hidden-space-functions*</code></a>, <a href="variables/prof/s_significance-threshold_s.htm"><code>*significance-threshold*</code></a>, and <a href="variables/prof/s_fractional-significance-threshold_s.htm"><code>*fractional-significance-threshold*</code></a>,
with the function <a href="operators/prof/reset-profiler-display-defaults.htm"><b>reset-profiler-display-defaults</b></a>.</p>

<hr><h2 id="103"><a name="disassemble-profile-3">6.2.2 The disassemble-profile function</a></h2>

<p id="104">The function <a href="operators/prof/disassemble-profile.htm"><b>disassemble-profile</b></a> will print a
disassembly of a specific function indicating the estimated time spent
for each instruction. Calls to other functions are identified as jumps
to subroutines (using hardware specific terminology). We remind you
that the time data is statistical and so the time spent in
particular instructions are estimates. The less time spent in a
function overall, the worse the estimate.</p>


<hr><h2 id="105"><a name="result-header-3">6.2.2 A note on the header in results</a></h2>

<p id="106">
The runtime analyzer emits headers similar to the following (the
numbers are different of course) in the <a href="operators/prof/show-flat-profile.htm"><b>show-flat-profile</b></a> or <a href="operators/prof/show-call-graph.htm"><b>show-call-graph</b></a> output:
</p>

<pre id="107">

  Sampling stopped after 1181 samples taken for the time profiler.

  Sample represents 1.2 seconds of user+system CPU time 
                        (out of a total of 5.5).
</pre>


<p id="108">
In Virtual Threads Lisps (ie non-os-threads, non-smp) sampling is done
on the basis of accumulated processor time in threads known to the Allegro CL
implementation. The value "1181" is the number of times a Lisp thread
accumulated sufficient processor time to qualify as a sample.  The
value "1.2" is a total sampling time calculated by multiplying the
number of samples by the sampling granularity.  The value "5.5" is the
total user and system time used by the Lisp process during the
sampling period.  When this value is the same as the total sampling
time, it is not included in the message.
</p>
<p id="109">
The total user+system time can be larger than the total sampling time
when there are other non-Lisp threads running in the process and
multiple processors are available.  Although Lisp code can use only
one thread and processor at any moment, there may be system threads
and foreign threads running and accumulating time in parallel with the
Lisp thread.
</p>
<p id="110">
Note that when a Lisp thread is waiting, it accumulates no time at all 
and thus does not appear in the profiler output.
</p>








<hr><h2 id="111"><a name="profiler-examples-2">6.3 Examples</a></h2>

<p id="112">
This section gives examples of using the runtime analyzer. These
examples were run on a Sun Solaris machine running the Solaris 2.7
operating system. The results might be quite different if run on a
different platform. Further, optimization settings during compilation
dramatically affect the results. You should not expect to see the
results included here if you try the examples on your system.
</p>
<p id="113">
The first example uses the time runtime analyzer. We will profile the
following functions, which we define and compile.
</p>

<pre id="114">
(defun fact (x) 
  (if (= x 1) 1 
   (* x (fact (- x 1)))))

(defun bar (x) 
  (dotimes (i 2000) 
    (make-array x)))

(defun foo (x) 
  (fact x)
  (bar x))

(compile 'fact)

(compile 'foo)

(compile 'bar)
</pre>

<p id="115">
First we collect the data by evaluating the following form
calling <a href="operators/prof/with-profiling.htm"><b>with-profiling</b></a>:
</p>

<pre id="116">
(prof:with-profiling (:type  :time) (foo 2000))
</pre>

<p id="117">
We display the flat analysis by evaluating the following form
calling <a href="operators/prof/show-flat-profile.htm"><b>show-flat-profile</b></a>:
</p>

<pre id="118">
(prof:show-flat-profile)
</pre>

<p id="119">
That causes the following to be printed (the results you see may be 
different, of course):
</p>

<pre id="120">
Sampling stopped after 52 samples taken for the time profiler.

Sample represents .3 seconds of processor time (out of a total of .3)

Times below 1.0% will be suppressed.

  %     %     self  total            self   total  Function
 Time  Cum.   secs   secs    calls ms/call ms/call   name
 25.0  25.0    0.1    0.1                          "bignum_multiply"
 19.2  44.2    0.1    0.2                          "make_svector_common"
 19.2  63.5    0.1    0.1                          "_hmul"
  9.6  73.1    0.0    0.0                          "checknslot"
  5.8  78.8    0.0    0.0                          "valid_lispstatic"
  3.8  82.7    0.0    0.1                          "rootscan_others"
  3.8  86.5    0.0    0.0                          "ochecknslot"
  3.8  90.4    0.0    0.0                          "cnoteroot"
  1.9  92.3    0.0    0.0                          "notelispstatic"
  1.9  94.2    0.0    0.0                          "scan_other_item"
  1.9  96.2    0.0    0.0                          "do_c_funcall"
  1.9  98.1    0.0    0.0                          "r_verify_other_ptr_new"
  1.9 100.0    0.0    0.0                          "checkcslot"
</pre>

<p id="121">
The first question you might have is where are <strong>fact</strong>
and <strong>foo</strong>, and why is so little time spent in
<strong>bar</strong>? (<strong>fact</strong>, <strong>foo</strong>,
and <strong>bar</strong> are the functions we defined at the beginning
of the example.) A flat analysis displays entries ordered by the
(estimated) time a function is at the top of the stack, not on the
stack. The three functions we defined call the low-level functions
listed to do their work and so themselves spend little time at the top
of the stack, so little that it falls below the default value of
<a href="variables/prof/s_significance-threshold_s.htm"><code>*significance-threshold*</code></a> (0.01, equivalent
to 1%) for <strong>fact</strong> and <strong>foo</strong>. If you
printed this display with the value of <a href="variables/prof/s_significance-threshold_s.htm"><code>*significance-threshold*</code></a> 0.0, you would
see <strong>fact</strong> and <strong>foo</strong> (and quite a few
more functions) listed.
</p>

<p id="122">
We can see from the output that most of the time is spent in the
Lisp runtime-system functions bignum_multiply and
make_svector_common. (We know they are runtime-system functions
because they are named by strings.) 
</p>

<p id="123">
Now let us look at the call graph. We display it by evaluating the
form calling <a href="operators/prof/show-call-graph.htm"><b>show-call-graph</b></a>:
</p>

<pre id="124">
(prof:show-call-graph)
</pre>

<p id="125">Here is the call graph that is printed (the results you see may be 
different, of course):</p>

<pre id="126">
Time profile of sampled pc values by function, children, and parents.

Total times below 1.0% will be suppressed.
Parent and child times less 2.0% of the node will be suppressed.
Sampling stopped after 52 samples taken for the time profiler.

Sample represents .3 seconds of processor time (out of a total of .3)

  %     %                       Parent
 self total   total local  Function
 Time  Time    secs   %         Child

  0.0 100.0     0.3   0.0   ... "start"
                0.3 100.0        ... "start_reborn_lisp"
-----------------------------------------------------
                0.3 100.0        ... "start"
  0.0 100.0     0.3   0.0   ... "start_reborn_lisp"
                0.3 100.0        ... #:start-lisp-execution-0
-----------------------------------------------------
                0.3 100.0        ... "start_reborn_lisp"
  0.0 100.0     0.3   0.0   ... #:start-lisp-execution-0
                0.3 100.0        ... eval
-----------------------------------------------------
                0.3 100.0        ... #:start-lisp-execution-0
  0.0 100.0     0.3   0.0   eval
                0.3 100.0        unwind-protect
-----------------------------------------------------
                0.3 100.0        eval
  0.0 100.0     0.3   0.0   ... unwind-protect
                0.2  73.1        foo
                0.1  26.9        ... "make_svector"
-----------------------------------------------------
                0.2 100.0        unwind-protect
  0.0  73.1     0.2   0.0   ... foo
                0.2  73.7        fact
                0.1  26.3        bar
-----------------------------------------------------
                0.2 100.0r       fact
                0.2 100.0r       ... foo
  0.0  53.8     0.2   0.0   fact
                0.2 100.0r       "integer_multiply"
                0.2 100.0r       fact
-----------------------------------------------------
                0.2 100.0        fact
  0.0  53.8     0.2   0.0   "integer_multiply"
                0.1  64.3        "bignum_multiply"
                0.1  35.7        "_hmul"
-----------------------------------------------------
                0.1  58.3        ... unwind-protect
                0.1  41.7        bar
  0.0  46.2     0.2   0.0   "make_svector"
                0.2 100.0        "make_svector_common"
-----------------------------------------------------
                0.2 100.0        "make_svector"
 19.2  46.2     0.2  41.7   "make_svector_common"
                0.1  58.3        "new_other"
-----------------------------------------------------
                0.1  73.7        "make_svector_common"
                0.0  26.3        "newbignum"
  0.0  36.5     0.1   0.0   "new_other"
                0.1 100.0        "other_from_new"
-----------------------------------------------------
                0.1 100.0        "new_other"
  0.0  36.5     0.1   0.0   "other_from_new"
                0.1 100.0        "scavenge"
-----------------------------------------------------
                0.1 100.0        "other_from_new"
  0.0  36.5     0.1   0.0   "scavenge"
                0.1 100.0        "scavenge1"
-----------------------------------------------------
                0.1 100.0        "scavenge"
  0.0  36.5     0.1   0.0   "scavenge1"
                0.1  68.4        "scan_rootset_entries"
                0.0  10.5        "rootsweep_var"
                0.0  10.5        "copycatchup_cons"
                0.0   5.3        "scan_activestack"
                0.0   5.3        "copycatchup_other"
-----------------------------------------------------
                0.1 100.0        "integer_multiply"
 25.0  34.6     0.1  72.2   "bignum_multiply"
                0.0  27.8        "newbignum"
-----------------------------------------------------
                0.1 100.0        "scavenge1"
  0.0  25.0     0.1   0.0   "scan_rootset_entries"
                0.1  76.9        "rootscan_others"
                0.0  15.4        "cnoteroot"
                0.0   7.7        "ochecknslot"
-----------------------------------------------------
                0.1 100.0        foo
  0.0  19.2     0.1   0.0   bar
                0.1 100.0        "make_svector"
-----------------------------------------------------
                0.1 100.0        "scan_rootset_entries"
  3.8  19.2     0.1  20.0   "rootscan_others"
                0.0  40.0        "ochecknslot"
                0.0  20.0        "notelispstatic"
                0.0  10.0        "valid_lispstatic"
                0.0  10.0        "checkcslot"
-----------------------------------------------------
                0.1 100.0        "integer_multiply"
 19.2  19.2     0.1 100.0   "_hmul"
-----------------------------------------------------
                0.0  80.0        "rootscan_others"
                0.0  20.0        "scan_rootset_entries"
  3.8   9.6     0.0  40.0   "ochecknslot"
                0.0  60.0        "checknslot"
-----------------------------------------------------
                0.0  60.0        "ochecknslot"
                0.0  40.0        "copycatchup_cons"
  9.6   9.6     0.0 100.0   "checknslot"
-----------------------------------------------------
                0.0 100.0        "bignum_multiply"
  0.0   9.6     0.0   0.0   "newbignum"
                0.0 100.0        "new_other"
-----------------------------------------------------
                0.0  66.7        "rootsweep_var"
                0.0  33.3        "copycatchup_other"
  1.9   5.8     0.0  33.3   "scan_other_item"
                0.0  33.3        "scan_savedstack"
                0.0  33.3        "rootsweep_structure"
-----------------------------------------------------
                0.0  66.7        "rootscan_others"
                0.0  33.3        "rootsweep_structure"
  1.9   5.8     0.0  33.3   "notelispstatic"
                0.0  66.7        "valid_lispstatic"
-----------------------------------------------------
                0.0  66.7        "notelispstatic"
                0.0  33.3        "rootscan_others"
  5.8   5.8     0.0 100.0   "valid_lispstatic"
-----------------------------------------------------
                0.0 100.0        "scavenge1"
  0.0   3.8     0.0   0.0   "copycatchup_cons"
                0.0 100.0        "checknslot"
-----------------------------------------------------
                0.0 100.0        "scavenge1"
  0.0   3.8     0.0   0.0   "rootsweep_var"
                0.0 100.0        "scan_other_item"
-----------------------------------------------------
                0.0 100.0        "scan_rootset_entries"
  3.8   3.8     0.0 100.0   "cnoteroot"
-----------------------------------------------------
                0.0  50.0        "scan_activestack"
                0.0  50.0        "scan_savedstack"
  0.0   3.8     0.0   0.0   "scan_stackspace"
                0.0  50.0        "do_c_funcall"
                0.0  50.0        "verified_funcall"
-----------------------------------------------------
                0.0 100.0        "scavenge1"
  0.0   1.9     0.0   0.0   "copycatchup_other"
                0.0 100.0        "scan_other_item"
-----------------------------------------------------
                0.0 100.0        "scan_other_item"
  0.0   1.9     0.0   0.0   "rootsweep_structure"
                0.0 100.0        "notelispstatic"
-----------------------------------------------------
                0.0 100.0        "rootscan_others"
  1.9   1.9     0.0 100.0   "checkcslot"
-----------------------------------------------------
                0.0 100.0        "scan_other_item"
  0.0   1.9     0.0   0.0   "scan_savedstack"
                0.0 100.0        "scan_stackspace"
-----------------------------------------------------
                0.0 100.0        "scan_stackspace"
  0.0   1.9     0.0   0.0   "verified_funcall"
                0.0 100.0        "verify"
-----------------------------------------------------
                0.0 100.0        "verified_funcall"
  0.0   1.9     0.0   0.0   "verify"
                0.0 100.0        "r_verify"
-----------------------------------------------------
                0.0 100.0        "verify"
  0.0   1.9     0.0   0.0   "r_verify"
                0.0 100.0        "r_verify_other_ptr_new"
-----------------------------------------------------
                0.0 100.0        "r_verify"
  1.9   1.9     0.0 100.0   "r_verify_other_ptr_new"
-----------------------------------------------------
                0.0 100.0        "scavenge1"
  0.0   1.9     0.0   0.0   "scan_activestack"
                0.0 100.0        "scan_stackspace"
-----------------------------------------------------
                0.0 100.0        "scan_stackspace"
  1.9   1.9     0.0 100.0   "do_c_funcall"
-----------------------------------------------------
</pre>

<p id="127">
Look at the entry for <b>foo</b> (sixth down). It tells us that
<b>foo</b> spends much more time in <b>fact</b> (73.7%) than it does
in <b>bar</b> (26.3%). Looking at the entry for <b>fact</b>, the
"r" next to the local percent numbers indicate that this
function has been called recursively. (The suspension points `...'
mean that hidden functions called by <b>foo</b> are taking the time.)
</p>

<p id="128">
To show call-counting, we call for a time analysis again but specify
:count 100 and<code> :count-list (list #'fact #'bar
#'make-array)</code>, so the call to <a href="operators/prof/with-profiling.htm"><b>with-profiling</b></a> is
</p>

<pre id="129">
(prof:with-profiling 
      (:type :time :count 100 :count-list (list #'fact #'bar #'make-array))
      (foo 2000))
</pre>

<p id="130">
Here is the flat analysis produced by <a href="operators/prof/show-flat-profile.htm"><b>show-flat-profile</b></a> and the printout of
<a href="operators/prof/show-call-counts.htm"><b>show-call-counts</b></a>
(somewhat abbreviated).
</p>

<pre id="131">
cl-user(23): (prof:show-flat-profile)
Sampling stopped after 59 samples taken for the time profiler.

Sample represents .3 seconds of processor time (out of a total of .3)

Times below 1.0% will be suppressed.

  %     %     self  total            self   total  Function
 Time  Cum.   secs   secs    calls ms/call ms/call   name
 20.3  20.3    0.1    0.1                          &quot;bignum_multiply&quot;
 15.3  35.6    0.0    0.0                          &quot;_hmul&quot;
 13.6  49.2    0.0    0.2                          &quot;make_svector_common&quot;
 10.2  59.3    0.0    0.0                          &quot;rootscan_others&quot;
  8.5  67.8    0.0    0.0                          &quot;cnoteroot&quot;
  6.8  74.6    0.0    0.0                          &quot;checknslot&quot;
  6.8  81.4    0.0    0.0                          &quot;copynewother&quot;
  3.4  84.7    0.0    0.0                          &quot;copycatchup_other&quot;
  3.4  88.1    0.0    0.0                          &quot;valid_lispstatic&quot;
  1.7  89.8    0.0    0.0                          &quot;scan_other_item&quot;
  1.7  91.5    0.0    0.0                          &quot;copycatchup_structure&quot;
  1.7  93.2    0.0    0.0                          &quot;copycatchup_cons&quot;
  1.7  94.9    0.0    0.0                          &quot;scan_stackspace&quot;
  1.7  96.6    0.0    0.0                          &quot;notelispstatic&quot;
  1.7  98.3    0.0    0.0                          &quot;verify&quot;
  1.7 100.0    0.0    0.0                          &quot;ioctl&quot;
cl-user(24):  (prof:show-call-counts)
3999	#&lt;Function *_2op&gt;
2000	#&lt;Function fact&gt;
2000	#&lt;Function calc-array-size&gt;
7	#&lt;Function arglist&gt;
7	#&lt;Function autoloadp&gt;
7	#&lt;Function generic-function-p&gt;
7	#&lt;Function encapsulated-basic-definition&gt;
7	#&lt;Function process-finalizations&gt;
7	#&lt;Function pop-finalization&gt;
7	#&lt;Function length&gt;
7	#&lt;Function resident-function&gt;
7	#&lt;Function closure-has-arglist-p&gt;
7	#&lt;Closure Template Function default-gc-after-hook @ #x400ccd2&gt;
7	#&lt;Function gc-after&gt;
6	#&lt;Function %eval&gt;
3	#&lt;Function function-information&gt;
3	#&lt;Function fboundp&gt;
3	#&lt;Closure Template Function scan-keyword @ #x4029f82&gt;
2	#&lt;Function variable-information&gt;
2	#&lt;Function get_2op&gt;
2	#&lt;Function %invokes&gt;
1	#&lt;Function foo&gt;
1	#&lt;Function bar&gt;
1	#&lt;Function instance-write-1&gt;
[...]
nil
cl-user(25): 
</pre>

<p id="132">
Note that the call counts are by function object, not function
name, that the call-counting overhead in this case is not very
significant -- see the comparable result without call-counting above
-- (but in other cases it might be), and that runtime-system functions
(named by strings in the flat analysis) are not counted.
</p>

<p id="133">
We end with an example of a space analysis. We use the following
code, which (1) uses a lot of space and (2) uses different types of
space. Consider the following functions:
</p>

<pre id="134">
(defun foo (n)
  (let ((array (bar n)))
    (dotimes (i (* n 8000))
      (setf (aref array i) (cons nil nil)))))

(defun bar (n)
  (make-array (* n 8000)))

(compile 'foo)

(compile 'bar)
</pre>

<p id="135">
We assume these functions have been defined and compiled within
Lisp. Note that <b>bar</b> creates an array (which will trigger calls
to new_other) and <b>foo</b> does a lot of consing, which will trigger
calls to _page_from_new. (On some platforms, the _page_from_new calls
themselves do not show up in the report.)
</p>

<p id="136">We call these functions in a with-profiling form:</p>

<pre id="137">
(prof:with-profiling (:type :space) (foo 1))
</pre>

<p id="138">
Before looking at the results, we set <a href="variables/prof/s_hidden-functions_s.htm"><code>*hidden-functions*</code></a> to nil, so we can see
what system functions are actually allocating the space.
</p>

<pre id="139">
(setf prof:*hidden-functions* nil)
</pre>

<p id="140">
We print the results with <a href="operators/prof/show-flat-profile.htm"><b>show-flat-profile</b></a>. 
</p>
<pre id="141">
(prof:show-flat-profile)
</pre>
<p id="142">
At first, we see <b>foo</b> and <b>bar</b> but no internal functions
(the suspension points `...' mean that functions called by foo and bar
are using the space). Then we set <a href="variables/prof/s_hidden-space-functions_s.htm"><code>*hidden-space-functions*</code></a> to nil and we see
the runtime-system space functions actually called.
</p>

<pre id="143">
Sampling stopped after 12 samples taken for the space profiler.

Sample represents 96.0 Kbytes of space allocated (out of a total of 96.0)

Mem.s below 1.0% will be suppressed.

  %     %     self  total            self   total  Function
 Mem.  Cum.  Kbyte  Kbyte    calls by/call by/call   name
 66.7  66.7     64     96                          ... foo
 33.3 100.0     32     32                          ... bar
cl-user(32): (setq prof:*hidden-space-functions* nil)
nil
cl-user(33): (prof:show-flat-profile)
Sampling stopped after 12 samples taken for the space profiler.

Sample represents 96.0 Kbytes of space allocated (out of a total of 96.0)

Mem.s below 1.0% will be suppressed.

  %     %     self  total            self   total  Function
 Mem.  Cum.  Kbyte  Kbyte    calls by/call by/call   name
 66.7  66.7     64     64                          "page_from_new"
 33.3 100.0     32     32                          "new_other"
cl-user(34): 
</pre>

<p id="144">
The first thing to notice is that _page_from_new and new_other use
all the space. This is not surprising since they actually allocate the
space. Note that _page_from_new uses 64K (8,000 conses at eight bytes
per cons) and new_other uses 32K (8,000 entries in an array using four
bytes each). No other functions appear since all the space is
allocated by these functions.</p>

<p id="145">
Now we look at a call graph by calling <a href="operators/prof/show-call-graph.htm"><b>show-call-graph</b></a>.
</p>

<pre id="146">
cl-user(34): (prof:show-call-graph)
Space profile of sampled pc values by function, children, and parents.

Total mem.s below 1.0% will be suppressed.
Parent and child mem.s less 2.0% of the node will be suppressed.
Sampling stopped after 12 samples taken for the space profiler.

Sample represents 96.0 Kbytes of space allocated (out of a total of 96.0)

  %     %                       Parent
 self total   total local  Function
 Mem.  Mem.   Kbyte   %         Child

  0.0 100.0      96   0.0   "start"
                 96 100.0        "setupstack"
-----------------------------------------------------
                 96 100.0        "start"
  0.0 100.0      96   0.0   "setupstack"
                 96 100.0        "cont_setstack"
-----------------------------------------------------
                 96 100.0        "setupstack"
  0.0 100.0      96   0.0   "cont_setstack"
                 96 100.0        "start_reborn_lisp"
-----------------------------------------------------
                 96 100.0        "cont_setstack"
  0.0 100.0      96   0.0   "start_reborn_lisp"
                 96 100.0        excl::start-reborn-lisp
-----------------------------------------------------
                 96 100.0        "start_reborn_lisp"
  0.0 100.0      96   0.0   excl::start-reborn-lisp
                 96 100.0        excl::setup-required-stack-group-bindings
-----------------------------------------------------
                 96 100.0        excl::start-reborn-lisp
  0.0 100.0      96   0.0   excl::setup-required-stack-group-bindings
                 96 100.0        #:start-lisp-execution-0
-----------------------------------------------------
                 96 100.0        excl::setup-required-stack-group-bindings
  0.0 100.0      96   0.0   #:start-lisp-execution-0
                 96 100.0        excl::start-lisp-execution
-----------------------------------------------------
                 96 100.0        #:start-lisp-execution-0
  0.0 100.0      96   0.0   excl::start-lisp-execution
                 96 100.0        tpl:start-interactive-top-level
-----------------------------------------------------
                 96 100.0        excl::start-lisp-execution
  0.0 100.0      96   0.0   tpl:start-interactive-top-level
                 96 100.0        "apply"
-----------------------------------------------------
                 96 100.0        tpl:start-interactive-top-level
  0.0 100.0      96   0.0   "apply"
                 96 100.0        tpl:top-level-read-eval-print-loop
-----------------------------------------------------
                 96 100.0        "apply"
  0.0 100.0      96   0.0   tpl:top-level-read-eval-print-loop
                 96 100.0        tpl::top-level-read-eval-print-loop1
-----------------------------------------------------
                 96 100.0        tpl:top-level-read-eval-print-loop
  0.0 100.0      96   0.0   tpl::top-level-read-eval-print-loop1
                 96 100.0        excl::read-eval-print-loop
-----------------------------------------------------
                 96 100.0        tpl::top-level-read-eval-print-loop1
  0.0 100.0      96   0.0   excl::read-eval-print-loop
                 96 100.0        tpl::read-eval-print-one-command
-----------------------------------------------------
                 96 100.0        excl::read-eval-print-loop
  0.0 100.0      96   0.0   tpl::read-eval-print-one-command
                 96 100.0        eval
-----------------------------------------------------
                 96 100.0        tpl::read-eval-print-one-command
  0.0 100.0      96   0.0   eval
                 96 100.0        unwind-protect
-----------------------------------------------------
                 96 100.0        eval
  0.0 100.0      96   0.0   unwind-protect
                 96 100.0        foo
-----------------------------------------------------
                 96 100.0        unwind-protect
  0.0 100.0      96   0.0   foo
                 64  66.7        "cons"
                 32  33.3        bar
-----------------------------------------------------
                 64 100.0        foo
  0.0  66.7      64   0.0   "cons"
                 64 100.0        "cons_from_new_page"
-----------------------------------------------------
                 64 100.0        "cons"
  0.0  66.7      64   0.0   "cons_from_new_page"
                 64 100.0        "conspage_from_new"
-----------------------------------------------------
                 64 100.0        "cons_from_new_page"
  0.0  66.7      64   0.0   "conspage_from_new"
                 64 100.0        "page_from_new"
-----------------------------------------------------
                 64 100.0        "conspage_from_new"
 66.7  66.7      64 100.0   "page_from_new"
-----------------------------------------------------
                 32 100.0        foo
  0.0  33.3      32   0.0   bar
                 32 100.0        "make_svector"
-----------------------------------------------------
                 32 100.0        bar
  0.0  33.3      32   0.0   "make_svector"
                 32 100.0        "make_svector_common"
-----------------------------------------------------
                 32 100.0        "make_svector"
  0.0  33.3      32   0.0   "make_svector_common"
                 32 100.0        "new_other"
-----------------------------------------------------
                 32 100.0        "make_svector_common"
 33.3  33.3      32 100.0   "new_other"
-----------------------------------------------------
cl-user(35): 
</pre>







<hr><hr><h2 id="147"><a name="sfp-header-1">Appendix A: Headers in show-flat-profile and show-call-graph output</a></h2>

<p id="148">
The profiler emits the following headers in the <a href="operators/prof/show-flat-profile.htm"><b>show-flat-profile</b></a>
or <a href="operators/prof/show-call-graph.htm"><b>show-call-graph</b></a> output:
</p>

<pre id="149">
  Sampling stopped after 1181 samples taken for the time profiler.

  Sample represents 1.2 seconds of user+system CPU time 
                        (out of a total of 5.5).
</pre>

<p id="150">
In Virtual Threads Lisps (ie non-os-threads, non-SMP) sampling is done
on the basis of accumulated processor time in threads known to the
Allegro CL implementation. The value "1181" is the number of times a
Lisp thread accumulated sufficient processor time to qualify as a
sample.  The value "1.2" is a total sampling time calculated by
multiplying the number of samples by the sampling granularity.  The
value "5.5" is the total user and system time used by the Lisp process
during the sampling period.  When this value is the same as the total
sampling time, it is not included in the message.
</p>
<p id="151">
The total user+system time can be larger than the total sampling time
when there are other non-Lisp threads running in the process and
multiple processors are available.  Although Lisp code can use only
one thread and processor at any moment, there may be system threads
and foreign threads running and accumulating time in parallel with the
Lisp thread.
</p>
<p id="152">
Note that when a Lisp thread is waiting, it accumulates no time at all 
and thus does not appear in the profiler output.
</p>




</body><hr><p id="2"><small>Copyright (c) 1998-2017, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page was not revised from the 10.0 page.</small><br><small>Created 2017.2.15.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/runtime-analyzer.htm">10.0 version</a></td></tr></table></html>