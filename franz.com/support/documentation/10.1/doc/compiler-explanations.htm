<html><head><meta name="viewport" content="width=device-width, initial-scale=1"> <meta http-equiv="content-type" content="text/html; charset=UTF-8"> <link rel="stylesheet" href="acldoc-styles.css" type="text/css"><title>Compiler explanations</title></head><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/compiler-explanations.htm">10.0 version</a></td></tr></table><h1 id="2">Compiler explanations</h1><p id="3">This document contains the following sections:</p><a href="#intro-1">1.0 Explanation introduction</a><br><a href="#explain-terms-1">2.0 :explain labels</a><br>&nbsp;&nbsp;&nbsp;<a href="#b-labels-2">2.1 :boxing (B) labels: Bgen1</a><br>&nbsp;&nbsp;&nbsp;<a href="#c-labels-2">2.2 :calls (C) labels: CallN</a><br>&nbsp;&nbsp;&nbsp;<a href="#i-labels-2">2.3 :inlining (I) labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#iadd-label-3">2.3.1 ;Iadd labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#iarg-label-3">2.3.2 ;Iarg labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#iash-label-3">2.3.3 ;Iash labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#icmp-label-3">2.3.4 ;Icmp labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#icon-label-3">2.3.5 ;Icon labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#idyn-label-3">2.3.6 ;Idyn labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ieql-label-3">2.3.7 ;Ieql labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ifnc-label-3">2.3.8 ;Ifnc labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ifor-label-3">2.3.9 ;Ifor labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#igen-label-3">2.3.10 ;Igen labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ihof-label-3">2.3.11 ;Ihof labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#iimm-label-3">2.3.12 ;Iimm labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ilen-label-3">2.3.13 ;Ilen labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#imac-label-3">2.3.14 ;Imac labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#iref-label-3">2.3.15 ;Iref labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#itab-label-3">2.3.16 ;Itab labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ityp-label-3">2.3.17 ;Ityp labels</a><br>&nbsp;&nbsp;&nbsp;<a href="#m-labels-2">2.4 tailmerging (M) labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#merg-label-3">2.4.1 ;Merg labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mnot-label-3">2.4.2 ;Mnot labels</a><br>&nbsp;&nbsp;&nbsp;<a href="#t-labels-2">2.5 :type (T) labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#targ-label-3">2.5.1 ;Targ labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tgen-label-3">2.5.2 ;Tgen labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tinf-label-3">2.5.3 ;Tinf labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tres-label-3">2.5.4 ;Tres labels</a><br>&nbsp;&nbsp;&nbsp;<a href="#v-labels-2">2.6 :variable (V) labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#vreg-label-3">2.6.1 ;Vreg labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#vflt-label-3">2.6.2 ;Vflt labels</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#vmem-label-3">2.6.3 ;Vmem labels</a><br><a href="#explain-1">3.0 Examples using the :explain declaration</a><br>&nbsp;&nbsp;&nbsp;<a href="#calls-types-explain-2">3.1 Calls and types explanation</a><br>&nbsp;&nbsp;&nbsp;<a href="#boxing-explain-2">3.2 Boxing explanation</a><br>&nbsp;&nbsp;&nbsp;<a href="#variables-explain-2">3.3 Variables explanation</a><br>&nbsp;&nbsp;&nbsp;<a href="#tailmerging-explain-2">3.4 Tail-merging explanation</a><br>&nbsp;&nbsp;&nbsp;<a href="#inlining-explain-2">3.5 Inlining explanations</a><br><hr><hr><h2 id="4"><a name="intro-1">1.0 Explanation introduction</a></h2>

<p id="5">
When the <code>:explain</code> declaration (described in
<a href="compiling.htm#decl-help-1">Help with
declarations: the :explain
declaration</a> in <a href="compiling.htm">compiling.htm</a>) is in
effect during compilation, the compiler prints information about what
it is doing. This information is labelled with abbreviations which
identify what is being explained (boxing, types, calls, inlining,
etc.) and provide additional information. For example, the lines:
</p>
<pre id="6">
;Tgen1:Examined a (possibly unboxed) call to +_2op with arguments:
;Targ2:  symeval x type (single-float * *)
;Tinf1:     variable-information: lexical: ((type (single-float * *)))
</pre>
<p id="7">
all relate to :types explanations (as indicated by the initial
<b>T</b>). 
</p>
<p id="8">
This document lists all these labels and tells when they might come up
and what they mean.
</p>

<p id="9">
Because the explain formatting can sometimes be verbose, the
explanations now place a "While compiling ..." message before each
lambda expression it is working on, to separate the sections in a file
or a function which has internal functions (e.g. flets or labels).
</p>

<p id="10">
After discussing the labels, there are examples of compilations with
various types of explanations enabled, see
<a href="#explain-1">Section 3.0 Examples using the :explain declaration</a>.
</p>

<hr><hr><h2 id="11"><a name="explain-terms-1">2.0 :explain labels</a></h2>

<p id="12">
Compiler explanations are printed in the following format:
</p>
<pre id="13">
;[Label] [details]
</pre>
<p id="14">
For example:
</p>
<pre id="15">
;Igen1:  Arg0: checking for implied unboxable type (floats, or
;Igen1:  machine-integer):
</pre>
<p id="16">
Note this particular explanation runs over two lines. The same label
starts each line.
</p>
<p id="17">
The first letter of the label identifies the type of explanation:
</p>
<table>
<tr>
<td width="15%"><b>Letter</b></td>
<td width="35%"><b>Explain type</b></td>
</tr>
<tr>
<td width="15%"><b>B</b></td>
<td width="35%">:boxing</td>
</tr>
<tr>
<td width="15%"><b>C</b></td>
<td width="35%">:calls</td>
</tr>
<tr>
<td width="15%"><b>I</b></td>
<td width="35%">:inlining</td>
</tr>
<tr>
<td width="15%"><b>M</b></td>
<td width="35%">:tailmerging</td>
</tr>
<tr>
<td width="15%"><b>T</b></td>
<td width="35%">:types</td>
</tr>
<tr>
<td width="15%"><b>V</b></td>
<td width="35%">:variables</td>
</tr>
</table>


<p id="18">
The labels are abbreviations describing what the compiler is trying to
do. In the subsections to this section, we list all these
abbreviations and explain what they mean. Note the sample messages may
contain <a href="../ansicl/dictentr/format.htm"><b>format</b></a> directives
(e.g. <code>;Call2:Generated a non-inline self tail jump to
~s:</code>), indicating some value will be displayed when the actual
message is printed.
</p>


<hr><h2 id="19"><a name="b-labels-2">2.1 :boxing (B) labels: Bgen1</a></h2>

<p id="20">
See <a href="#boxing-explain-2">Section 3.2 Boxing explanation</a> for a definition
of boxing. There is only one label for :boxing
explanations, <b>Bgen1</b>:
</p>

<pre id="21">
;Bgen1:Generating a single-float box
;Bgen1:Generating a double-float box
;Bgen1:Generating a bignum box
</pre>

<p id="22">
For each of these messages, the compiler is noting that some consing
will be done as a result of making a "box" to hold a result. To avoid
consing for these situations, it is sometimes possible to propagate
the generated value into a predefined box, i.e. a specialized array of
element type single-float, double-float, or (signed-byte 32) or
(signed-byte 64), depending on the width of the lisp. Note however,
that if <b>arr</b> is declared to be type <code>(simple-array
single-float (*))</code> and the compiler sees a form like
</p>

<pre id="23">
(setf (aref arr n) &lt;unboxed calculation&gt;)
</pre>

<p id="24">
then a single-float box may still be generated, because
the <b>setf</b> returns the value, and if the value is used (say, by
returning) it will tend to be boxed. If the final destination of a
calculation is to one of these specialized arrays, then it is better
to ensure that the value is not used at the end of the function, e.g.:
</p>
<pre id="25">
 (progn
   (setf (aref a n) &lt;unboxed calculation&gt;)
   nil)
</pre>

  

<hr><h2 id="26"><a name="c-labels-2">2.2 :calls (C) labels: CallN</a></h2>

<p id="27">
The explanation generated by :calls all start with C. They are numbered.
</p>
<pre id="28">
<b>;Call1:Generated a non-inline call to ~s:</b>
</pre>
<p id="29">
The compiler is noting that a call is being generated to the function
named in the message.  After the function returns, execution continues
in the caller.
</p>
<pre id="30">
<b>;Call2:Generated a non-inline self tail jump to ~s:</b>
</pre>
<p id="31">
The compiler is noting that a call is being generated to the function
named in the message, which happens to be the function being compiled.
The call is made by tail-jumping.  The caller's frame is reused for
the recursion, and it appears to a debugger that there is only one
level of call to the function in question, no matter how many
recursions are entered by tail-jump.
</p>
<pre id="32">
<b>;Call2:Generated a non-inline non-self tail jump to ~s:</b>
</pre>
<p id="33">
The compiler is noting that a call is being generated to the function
named in the message, explicitly by tail-jumping.  The caller is
no longer on the stack, and it appears to a debugger that the
caller's caller is calling the callee directly (though ghost frames
can usually detect this situation).
</p>
<pre id="34">
<b>;Call3:Generated a non-inline call to internal primitive ~s:</b>
</pre>
<p id="35">
The compiler is noting that a call is being generated to the
internal function named in the message.  After the function
returns, execution continues in the caller.
</p>
<pre id="36">
;Call4:Generated a non-inline non-self tail jump to internal primitive ~s:
</pre>
<p id="37">
The compiler is noting that a call is being generated to the
internal function named in the message, explicitly by tail-jumping.
The caller is no longer on the stack, and it appears to a debugger
that the caller's caller is calling the primitive function directly
(though ghost frames can usually detect this situation).
</p>



<hr><h2 id="38"><a name="i-labels-2">2.3 :inlining (I) labels</a></h2>


<ul>
<li id="39">
<a href="#iadd-label-3">Section 2.3.1 ;Iadd labels</a>
</li>
<li id="40">
<a href="#iarg-label-3">Section 2.3.2 ;Iarg labels</a>
</li>
<li id="41">
<a href="#iash-label-3">Section 2.3.3 ;Iash labels</a>
</li>
<li id="42">
<a href="#icmp-label-3">Section 2.3.4 ;Icmp labels</a>
</li>
<li id="43">
<a href="#icon-label-3">Section 2.3.5 ;Icon labels</a>
</li>
<li id="44">
<a href="#idyn-label-3">Section 2.3.6 ;Idyn labels</a>
</li>
<li id="45">
<a href="#ieql-label-3">Section 2.3.7 ;Ieql labels</a>
</li>
<li id="46">
<a href="#ifnc-label-3">Section 2.3.8 ;Ifnc labels</a>
</li>
<li id="47">
<a href="#igen-label-3">Section 2.3.10 ;Igen labels</a>
</li>
<li id="48">
<a href="#ihof-label-3">Section 2.3.11 ;Ihof labels</a>
</li>
<li id="49">
<a href="#ilen-label-3">Section 2.3.13 ;Ilen labels</a>
</li>
<li id="50">
<a href="#imac-label-3">Section 2.3.14 ;Imac labels</a>
</li>
<li id="51">
<a href="#iref-label-3">Section 2.3.15 ;Iref labels</a>
</li>
<li id="52">
<a href="#itab-label-3">Section 2.3.16 ;Itab labels</a>
</li>
<li id="53">
<a href="#ityp-label-3">Section 2.3.17 ;Ityp labels</a>
</li>
</ul>


<p id="54">
There are quite a few :inlining explanations. We describe each type in
a subsection.
</p>
<p id="55">
For this section and its subsections, all <code>:inlining</code>
explanations are identified immediately after their labels as either
"Node" or "Arg~d". Thus if you consider a typical function call form:
</p>

<pre id="56">
 (foo a b c)
</pre>

<p id="57">
then any examination of <b>a</b>'s type is referred to as <b>Arg0</b>,
examinations of <b>b</b> are referred to as <b>Arg1</b>, and
examinations of <b>c</b> are referred to as <b>Arg2</b>. Any
examinations of the whole result of the form are referred to
as <b>Node</b>.
</p>
<p id="58">
The Arg~d and Node identifiers can be positionally correlated to their
types within the Targ and Tres messages, respectively. However,
unlike <code>:types</code>
explanations, <code>:inlining</code> examinations are not
necessarily made in order - arguments will be examined in the most
expedient way possible to get the best result, but that may mean that
an argument is examined out of order, or two or more times, or not at
all. Likewise for the node (the result of the form) might be examined
before or after the arguments, or not at all.
</p>

<hr><h2 id="59"><a name="iadd-label-3">2.3.1 ;Iadd labels</a></h2>

<p id="60">
These related to addition and subtraction.
</p>

<pre id="61">
<b>;Iadd1: Node: can fixnums be ruled out? (failure to inline may be 
desirable so type checks can be removed):</b>
</pre>
<p id="62">
Normally slow safe <b>+</b> and <b>-</b> operations check their
arguments for fixnums inline, and if they are both fixnums, a function
call is not needed.  But if the possibility for the arguments to be
fixnums is ruled out, then it would be more efficient to compile the
code without the inline fixnum test, since we know that the test will
always fail.  Hence, a failure to inline is more desirable when the
arguments are known not to be fixnums.
</p>
<pre id="63">
<b>;Iadd2:  Node: must check for fixnum at runtime.</b>
</pre>
<p id="64">
If as in Iadd1 it cannot be proved that both arguments are not
fixnums, then the fixnum test is needed, and the inlining will
(unfortunately) succeed.
</p>
<pre id="65">
<b>;Iadd3:  Arg~d: only one arg needs checking at runtime.</b>
</pre>
<p id="66">
When compiling <b>excl::+_2op</b> or <b>-_2op</b> (the two operand
versions of <b>+</b> and <b>-</b>), some architectures will optimize
the fixnum check if one of the two arguments is a fixnum constant.
Whichever argument is the constant, the other argument will be noted
as being checked. Note that the result of the operation must still be
checked for overflow, in which case the actual function call might
still be made. Not all architectures benefit from this optimization;
at the time of writing only x86 and x86-64 architectures have it.
</p>



<hr><h2 id="67"><a name="iarg-label-3">2.3.2 ;Iarg labels</a></h2>

<p id="68">
These related to the number of arguments.
</p>

<pre id="69">
<b>;Iarg1:  Node: looking for ~d args - got ~d
;Iarg2:  Node: looking for at least ~d args - got ~d
;Iarg3:  Node: looking for between ~d and ~d args, got ~d</b>
</pre>
<p id="70">
In all three cases, the number of arguments does not match the
number of arguments required for a particular section of inlining to
take effect.
</p>



<hr><h2 id="71"><a name="iash-label-3">2.3.3 ;Iash labels</a></h2>

<p id="72">
These relate to calls to <b>ash</b>.
</p>

<pre id="73">
<b>;Iash1:  Arg~d: looking for shift type to be subtype of (integer -31 31) - got type (integer -536870912 536870911).
;Iash1:  Arg~d: looking for shift type to be subtype of (integer -31 31) - got type (integer -10 10).
;Iash1:  Arg~d: looking for shift type to be subtype of (integer -31 31) - got type (integer 5 10).</b>
</pre>
<p id="74">
<b>ash</b> does best when it can shift integers that are 32 bits or
less (or 64 bits, on a 64-bit machine).  Note that in all three of
these examples the shift amount has been declared an integer, but in
the first case, the shift amount is a fixnum (if it happens to be a
large positive integer, the result would tend to be a bignum, or if it
is a large negative-integer then the result would tend to be 0 or -1.
In the second case, the shift amount is a reasonable size for
opencoding, but since it crossed the 0 boundary and thus could either
be positive or negative, an extra test would have to be generated if
inlining is decided.  In the last case, the shift amount is positive
and small, so there is a class of values to be shifted that could be
shifted without causing any consing and for which it makes sense to
inline.
</p>
<pre id="75">
<b>;Iash2:  Arg~d: shift amount both negative and positive; must generate runtime test.</b>
</pre>
<p id="76">
In one case for Iash1, the declared integer is both negative and
positive (i.e. the type has the form <code>(integer m n)</code>
where <code>(&lt; m 0) =&gt; t</code> and <code>(&gt; n 0)
=&gt; t</code> If branches can be established in outer code which
deal separately with the negative and positive branches, then the test
within the ash expansion can be eliminated for each branch.
</p>



<hr><h2 id="77"><a name="icmp-label-3">2.3.4 ;Icmp labels</a></h2>

<p id="78">
These relate to calls to comparisons.
</p>
<pre id="79">
<b>;Icmp1:  Node: will check only for fixnums inline.</b>
</pre>
<p id="80">
If nothing is known about the arguments to a comparison, it is still more
efficient to compile inline a test that both arguments are fixnum, and then
if the test fails, call the actual out-of-line function which will handle
all other types.  This message appears if no other combination of argument
types allowed the comparison to be completely commpiled inline.
</p>
<pre id="81">
<b>;Icmp2:  Node: checking for comparison of an integer with a fixnum constant:</b>
</pre>
<p id="82">
This message states that there is a posibility to compare an unknown
integer value with a fixnum constant, which can be done completely
inline.  The general messages that follow will indicate what actual
tests are being performed.:
</p>




<hr><h2 id="83"><a name="icon-label-3">2.3.5 ;Icon labels</a></h2>

<p id="84">
These relate to calls to constants used for things like array
dimensions.
</p>

<pre id="85">
<b>;Icon1:  Arg~d: looking for fixnum constant - got 0
;Icon1:  Arg~d: looking for fixnum constant - got nil
;Icon1:  Arg~d: looking for one of these constants: &lt;list of desired values&gt; - got &lt;nil or result&gt;</b>
</pre>
<p id="86">
One or more constants are useful for certain inlining efforts.  The first
example notes that the fixnum 0 was found, and the second form means that no
constant was found.  The third form allows the compiler to select
from several different constant values, with the result displayed.
</p>
<pre id="87">
<b>;Icon2:  Arg~d: checking that the constant value is 0 - got 1</b>
</pre>
<p id="88">
<b>array-dimension</b> is only inlined when its argument is 0. If it
is not, then the actual function is called to get the result.
</p>



<hr><h2 id="89"><a name="idyn-label-3">2.3.6 ;Idyn labels</a></h2>

<p id="90">
These relate to calls to dynamic-extent.
</p>
<pre id="91">
<b>;Idyn1: Consider declaring &lt;var&gt; dynamic-extent:   (node: ~s).</b>
</pre>
<p id="92">
The variable was not declared dynamic-extent, but the compiler determined
that it might be useful to do so.  Some let init forms which can generate
stack-allocated lisp objects will do so if conditions are right, starting
with a declaration of dynamic-extent for the let variable being initialized.
</p>
<pre id="93">
<b>;Idyn2: Looking for stack-allocation for &lt;var&gt; (call to excl::.primcall):</b>
</pre>
<p id="94">
If &lt;var&gt; has been declared dynamic extent, and if the let
init-form initializing &lt;var&gt; is appropriate, then the compiler
is saying that it will try to transform the form to one which is to be
compiled as stack-allocated. Another &quot;dyn&quot; message will follow -
either Idyn3 or Idyn4, based on success or failure.  Typical forms
which can be transformed are calls to <b>cons</b>, <b>list</b>,
<b>list*</b>, <b>make-list</b>, and <b>make-array</b>.
</p>
<pre id="95">
<b>;Idyn3:    - transformed to ~s</b>
</pre>
<p id="96">
The compiler has succeeded in transforming an allocating form to a
stack-allocating form.  The node of the new call (which will include the
node's name) is also shown.  See Idyn1.
</p>
<pre id="97">
<b>;Idyn4:    - couldn't transform ~s to stack-allocated form.</b>
</pre>
<p id="98">
For one or more reasons, the compiler could not transform a consing
form to a stack-consing form.  See Idyn1 for background.  In
particular, stack consing requires constants in many cases; for
example, neither (make-array n) nor (make-list n) can be
stack-allocated because the array is of variable size.  Also, not all
make-array options have corresponding stack-allocatable functionality;
for example, specifying a :weak option will result in no
transformation, as will specifying :initial-contents (although it is
possible to specify :initial-element for many element-types).  Also,
some :element-type specifications cannot be transformed to
stack-allocations.
</p>

<pre id="99">
<b>;Idyn5:    -  Possible dynamic-extent transformation of a requires trusting declarations.</b>
</pre>
<p id="100">
The Idyn5 message may be seen if declarations are not being trusted
and a form is a candidate for dynamic-extent optimization.  Idyn1
(described above) already displays a message if the optimization is
missed due to the lack of dynamic-extent declaration, but a
dynamic-extent declaration is not enough; declarations must also be
trusted (so <a href="variables/compiler/trust-declarations-switch.htm"><code>trust-declarations-switch</code></a> must be
true). So for the following code:
</p>

<pre id="101">
(defun clear-the-stack ()
  (declare (:explain :types :inlining)
	   #+ignore (optimize speed))
  (let ((a (make-array 1000 :initial-element nil)))
    #+ignore (declare (dynamic-extent a))
    (identity a))
  nil)
</pre>

<p id="102">
You might get one or both of Idyn{1,5}:
</p>

<pre id="103">
;Idyn1: Consider declaring a dynamic-extent:
;Idyn1:   (node: #&lt;call .primcall new-simple-vector @ #x10013832c2&gt;).
;Idyn5: Possible dynamic-extent transformation of a requires trusting declarations.
;Idyn5:   (node: ##&lt;call .primcall new-simple-vector @ #x10013832c2#&gt;)
</pre>

<p id="104">
The former is given if the dynamic-extent declaration is missing, and
the latter if declarations are not trusted.
</p>




<hr><h2 id="105"><a name="ieql-label-3">2.3.7 ;Ieql labels</a></h2>

<p id="106">
These relate to calls to equality tests.
</p>
<pre id="107">
<b>;Ieql1:  Arg~d: looking for atomic type wrt eql:
;Ieql1:  Arg~d: looking for atomic type wrt equal:</b>
</pre>
<p id="108">
If <b>eql</b> or <b>equal</b> receive at least one argument for which
an eql/eq comparison is equivalent to an <b>eq</b> comparison, then
the call to eql/equal can be changed to a call to <b>eq</b>.  This is
generally true for fixnums and symbols, and for eql, it is also true
for lists.
</p>
<pre id="109">
<b>;Ieql2:  Node: must call excl::eql-not-eq.
;Ieql2:  Node: must call excl::equal-not-eq.</b>
</pre>
<p id="110">
If neither argument to eql/equal are of a type for which the call can
be transformed to a call to eq, then out-of-line calls must be
generated.  Note that even if such an out-of-line call is required, an
inline eq test is still done to determine if the two arguments are
identical, and then the out-of-line call is to a function which
assumes that the arguments are not eq.  Note also that although an
out-of-line call is made, there is some inlining done, so the compiler
considers the call to be successfully inlined (the only way to fail to
inline calls to eql/equal is to declare it to be notinline).
</p>



<hr><h2 id="111"><a name="ifnc-label-3">2.3.8 ;Ifnc labels</a></h2>

<p id="112">
These relate to calls to <b>funcall</b>.
</p>
<pre id="113">
<b>;Ifnc1:  Node: must primcall checking funcall.</b>
</pre>
<p id="114">
When calling <b>funcall</b>, there are several options.  The function
argument can be declared as a symbol or a function, in which case
inline instructions to call through the respective types of objects is
done.  Otherwise, (assuming funcall is not being declared notinline)
if the type of the function argument is unknown, or if the
comp:verify-funcalls-switch returns true, then a "checking funcall" is
compiled, which is a runtime-system call to funcall_check, which
figures out what to do.  Funcall_check knows how to call a symbol, a
function object, a flavor instance, and even a list (as an interpreted
function).  It is of course slower than a fully-inline funcall, but is
still considered by the compiler to be a successfully inlined call.
</p>




<hr><h2 id="115"><a name="ifor-label-3">2.3.9 ;Ifor labels</a></h2>

<p id="116">
These labels relate to calls to foreign functions which request a
direct foreign call via the <code>:call-direct</code> option to
<a href="operators/ff/def-foreign-call.htm"><b>ff:def-foreign-call</b></a>.
</p>
<pre id="117">
<b>;Ifor1:  Arg~d: looking for direct foreign call to ~s.</b>
</pre>
<p id="118">
If the function name has been defined
with <code>:call-direct</code>, then the foreign-call
specification and the call itself are being examined to see if this
optimization can be performed.
</p>

<pre id="119">
<b>;Ifor2:   Node: cannot convert &lt;type&gt; into immediate &lt;immed&gt; return value</b>
</pre>
<p id="120">
If the <code>:returning</code> specification given in the
<a href="operators/ff/def-foreign-call.htm"><b>ff:def-foreign-call</b></a>
is not appropriate for the type of the returned value, the
optimization cannot be performed.
</p>

<pre id="121">
<b>;Ifor3:  Node: argument count ~d doesn't match argspec &lt;argspec&gt;.</b>
</pre>
<p id="122">
If the argument count of the call isn't appropriate for the
<a href="operators/ff/def-foreign-call.htm"><b>ff:def-foreign-call</b></a>,
then the optimization will not be performed.
</p>

<pre id="123">
<b>;Ifor4:  Arg~d: looking for vector or one of &lt;type list&gt; but found &lt;type&gt;.</b>
</pre>
<p id="124">
The types of each argument must match those of the Lisp arguments. If
they don't, then the optimization is not performed.
</p>


<pre id="125">
<b>;Ifor5:  Node: return type ~a cannot be converted.</b>
</pre>
<p id="126">
The given return type is either on the list of bad return types for a
direct call, or else is not on the list of possible return types for a
direct call.
</p>



<pre id="127">
<b>;Ifor6:  Node: not wanting to see any of ~{ ~s~} but found ~a</b>
</pre>
<p id="128">
The type of the argument was found to be in the list of bad
foreign-arg types.
</p>





<hr><h2 id="129"><a name="igen-label-3">2.3.10 ;Igen labels</a></h2>

<p id="130">
There are general messages.
</p>
<pre id="131">
<b>;Igen1:  Arg~d: checking for implied unboxable type (floats, or  machine-integer):
;Igen1:  Node: checking for implied unboxable type (floats, or  machine-integer):</b>
</pre>
<p id="132">
When a node or an argument is compiled, the compiler checks to see if
it is appropriate or advisable to try to compile the node in an
unboxed manner.  If a node can be compiled in an unboxed manner, then
it is likely that some boxing
(see <a href="#boxing-explain-2">Section 3.2 Boxing explanation</a>) must be done
later on, but if that boxing occurs much later, or if the boxing can
be done into a pre-supplied box, then it is always desirable to
perform the compilation unboxed.  There are three types of unboxed
value that can be represented by the compiler: single-float,
double-float, and machine-integer (aka (signed-byte 32) in a 32-bit
lisp, and (signed-byte 64) in a 64-bit lisp).
</p>
<p id="133">
Note that a machine-integer is only compiled for if the type of the
node is too large for a fixnum <b>and</b> at least as small as a
(signed-byte 32/64).  It may seem as though this restricts the range
of unboxed integers that are likely, but such compilation does occur
more often than might be originally thought.  It is always possible to
force an unboxed compilation by declaring the node to be (signed-byte
32) or (signed-byte 64).
</p>
<p id="134">
The results of Igen1 are always given by an Igen2 message.
</p>
<pre id="135">
<b>;Igen2:  Arg~d: type is not trusted
;Igen2:  Node: type is not trusted
;Igen2:  Arg~d: type is not unboxable
;Igen2:  Node: type is not unboxable
;Igen2:  Arg~d: type is unboxable as &lt;type&gt;
;Igen2:  Node: type is unboxable as &lt;type&gt;
</b>
</pre>
<p id="136">
One of these three basic messages will always follow an Igen1 message.
The first pair informs that the compiler cannot trust the
declarations, thus the node or argument cannot be compiled as unboxed.
The second pair says that declarations are trusted, but that the type
of the node or argument is not known or is one which cannot be
compiled unboxed.  The third pair of messages indicates success
with unboxing, and will include
the type of the
node. (See <a href="#boxing-explain-2">Section 3.2 Boxing explanation</a> for a
definition of boxing.)
</p>


<pre id="137">
<b>;Igen3: Attempt to inline an unboxed call to ~s while not trusting declarations:
;Igen3: Attempt to inline a boxed call to ~s while not trusting declarations:
;Igen3: Attempt to inline an unboxed call to ~s while trusting declarations:
;Igen3: Attempt to inline a boxed call to ~s while trusting declarations:</b>
</pre>
<p id="138">
Whenever the compiler sees a call expression (i.e. node) it will try to
compile it based on its ability to be inlined and based on the surrounding
context:
</p>
<ul>
<li id="139">
If the surrounding code is being compiled in an unboxed manner,
an attempt to compile this node unboxed is made, and if it succeeds, the
code is most efficient.  If (in an unboxed context) this node cannot be
compiled unboxed, then an attempt to compile it boxed is made, and whether
or not the inline attempt is successful, the result ends up needing to be
unboxed (for the context).
</li>
<li id="140">
If the surrounding code is not being compiled in a boxed manner, then
care is taken to see if this node might be compiled in a boxed manner.
Two attempts at inlining are performed:
<ul>
<li id="141">
An attempt is made to compile the node unboxed, and then to re-box the
result.  If successful, the second attempt is skipped:
</li>
<li id="142">
An attempt is made to compile the node boxed.  Whether or not the inlining
is successful, the result need not be boxed, because it already is boxed.
</li>
</ul>
</li>
</ul>
<p id="143">
Additionally, you are told whether declarations are or are not being
trusted.
</p>

<p id="144">
(See <a href="#boxing-explain-2">Section 3.2 Boxing explanation</a> for a
definition of boxing.)
</p>
<pre id="145">
<b>;Igen4: Inline attempt failed.

Inline attempt succeeded with a hybrid of inline code and a call.


;Igen4: Inline attempt failed, but succeeded in removing hybrid test code.

;Igen4: Inline attempt succeeded.
;Igen4: Inline attempt succeeded with tail-merging.
;Igen4: Inline attempt succeeded with primcall.
;Igen4: Inline attempt succeeded with tail-merged primcall.
;Igen4: Inline attempt succeeded with (primcall to ~s).
;Igen4: Inline attempt succeeded with short array.
;Igen4: Inline attempt succeeded with test between long or short array.
</b>
</pre>
<p id="146">
For every attempt to inline (both boxed and unboxed) a success or
failure message is displayed.  Success in inlining is not necessarily
the highest goal; it may be that an out-of-line call is more efficient
because any inline code generation is just a waste of time, due to
what is known about the arguments to the call. You will often
see the <b>Inline attempt failed, but succeeded in removing hybrid
test code</b> qualified "failure" message when a "failure" could be
viewed as a success.
</p>

<p id="147">
The <b>Inline attempt succeeded with a hybrid of inline code and a
call.</b> messages means that some cases (for example, args are
determined to be fixnums) suceeded in inlining while other cases
resulted in a call out. This message often means more declaration (if
possible) would improve things. In particular, if you expected an
earlier declaration to propagate and it (for whatever reason) did not,
you might see this message. Adding declarations often improve things
in that case.
</p>

<p id="148">
(See <a href="#boxing-explain-2">Section 3.2 Boxing explanation</a> for a
definition of boxing.)
</p>


<h3 id="149">
Hybrid code
</h3>
<p id="150">
If inlining attempts fail, then a straight out-of-line call to the
function is generated.  It is possible for an unboxed inlining to
fail, but the consequent boxed inlining compilation to succeed. There
are two failure messages: that inlining failed and that inlining
failed but hybrid code was removed.
(See <a href="#boxing-explain-2">Section 3.2 Boxing explanation</a> for a definition
of boxing.)
</p>
<p id="151">
Hybrid code is a mixture of inline code (just instructions) and
out-of-line code (i.e. a call to a function).  Normally we want to
make a decision between inline code and a call, but sometimes there is
something that can be done inline that performs part of the necessary
functionality, combined with a test to see if this inline code is
appropriate, and if not, the call is made to the function.  For
example: the inline expander for <b>excl::+_2op</b> (the
two-operand-add) will normally generate hybrid code that tests that
both operands are fixnums, and then perform the add and then check for
overflow.  If the operands are not both fixnums, or if there is an
overflow after the add, then the <b>excl::+_2op</b> function must be
called to perform the addition.  On the pro side for hybrid code is
that if it is appropriate for the operand types, it is very fast.  On
the con side for hybrid code are two issues: first, when the inline
code is not appropriate, extra tests are made to determine that the
out-of-line call should have been made; and second, if the hybrid code
is appropriate 100% of the time, then the tests are also extraneous,
and the out-of-line code would never be called.  If at compile time
the types of the arguments can be narrowed down, then the hybrid tests
can be removed and the appropriate more-specific code can be generated
without the tests.  In the <b>excl::+_2op</b> example, if the operands
can be determined never to be both fixnums, then the hybrid test code
can be removed and a simple, out-of-line call to <b>excl::+_2op</b>
can be generated.  Or, if the operands can be determined to be fixnum
<i>and</i> the result of the addition can also be determined to be
fixnum, then the hybrid tests can also be pulled out and the add
operation done in one instruction, without any out-of-line calls. The
second failure message says that even though the call is not inlined,
the test was determined not to be necessary (so the call is always
made) and so was removed.
</p>

<h3 id="152">
Inlining qualifiers
</h3>
<p id="153">
Success in inlining may come with one of many modifiers; if no modifiers
are present, then the inlining was simple and the call was replaced
directly with inline code.  If "with tail-merging" is present, then the
call has in some way become a jump out of the function currently being
compiled.  If any of the "primcall" modifiers are present, then the
inlining is in fact a call to a runtime-system function.
</p>
<p id="154">
Two special success modifiers have to do with short-arrays and long
(i.e. normal) arrays.  If an array operation can be inlined, but
must distinguish between short arrays and normal arrays, then the
success might be mitigated by the need for an inline test on the
array type, to see if it is short or long.  This extra test consumes
run-time, and should be avoided unless it is the goal of the code
to make the test.  The exact code generated can be controlled by
the kind of declaration used:
</p>
<ul>
<li id="155">
<code>(simple-array * *)</code> indicates a normal or "long"
array
</li>
<li id="156">
<code>(excl:short-simple-array * *)</code> indicates a short
array
</li>
<li id="157">
<code>(or (simple-array * *) (excl:short-simple-array *
*))</code> indicates either short or long, and a run-time test will
be made to determine which code path is taken.
</li>
</ul>
<p id="158">
The type (excl:dual-simple-array * *) is a deftype which expands
to (or (simple-array * *) (excl:short-simple-array * *))
for notational convenience.
</p>
<pre id="159">
<b>;Igen5:  Node: checking for notinline declaration for ~s: none
;Igen5:  Node: checking for notinline declaration for ~s: present
</b>
</pre>
<p id="160">
Before any inlining can be performed, the presence of a notinline
declaration for this function must be tested.  If there is one,
either in the global environment or in a lexical environment, and
that notinline declaration is not shadowed by an inline declaration,
then the inlining will immediately fail.  If no such unshadowed
notinline declaration is present, then the inlining attempts may
proceed.
</p>
<pre id="161">
<b>
;Igen6:  Checking compiler:~s-switch for ~s (got ~s) - succeeded/failed
</b>
</pre>
<p id="162">
At various places in the compiler, the many compiler switches are
tested, to see if they return true or false.  In this message, the name of
the switch is given, as well as an indicator of the desired return
value (t or nil for true or false, respectively) and also the actual
result and whether that constituted success or failure.  In this
context success is required in order for the inlining attempts to proceed,
and so success is presumably desired.  If the switch test fails, the inlining
attempt itself may still succeed, but without the particular inlining that
would have been tried if the switch had been successful.
</p>
<pre id="163">
<b>;Igen7: Call to ~s elided because it is side-effect-free and unused.</b>
</pre>
<p id="164">
If built-in inliners are present for a function which does not produce
side-effects, but the result of that function is never used, then the function
call to the function itself can be elided.  Note that the arguments are always
compiled, so that if they have any side-effects then the correct effect is
achieved.  This message indicates that such a side-effect-free function has
been removed as a reult of its compilation.
</p>
<pre id="165">
<b>;Igen8: Unboxed result must be boxed - consider expanding scope of unboxed forms.</b>
</pre>
<p id="166">
This message alludes to the fact that a box has had to be consed, and
that it may be possible to forego that boxing if some of the code
around this code could be compiled
unboxed. (See <a href="#boxing-explain-2">Section 3.2 Boxing explanation</a> for a
definition of boxing.) For example, consider the following:
</p>
<pre id="167">
(defun foo (a b)
  (declare (optimize speed)
           (single-float a b)
           (:explain :inlining))
  (+ a b 1.0))
</pre>
<p id="168">
There are two excl::+_2op nodes in this compilation, and they are both
successfully compiled in unboxed manner.  However, the result of the
line of computations must be boxed before returning from foo.
But what if the result of the calculation were not returned from foo,
but instead had been stored into a pre-allocated box, and nil returned
instead?  Consider this modified example:
</p>
<pre id="169">
(defun foo (a b res)
  (declare (optimize speed)
           (single-float a b)
           ((simple-array single-float (*)) res)
           (:explain :inlining))
  (setf (aref res 0) (+ a b 1.0))
  nil)
</pre>
<p id="170">
Note now that the Igen8 message disappears, because the store into
the single-float array satisfied the need for the boxing of the result
of the calculation (because the single-float array itself serves as
a box), and no floats are being returned from foo.
</p>
<p id="171">
<b>Note well</b>: The <code>nil</code> return is
necessary; if it were absent, then the result of foo would be the
result of the (setf aref), and since the setf returns as its result
the last value stored, the unboxed value would have had to be boxed in
order to return it, even though it had successfully stored unboxed
into the array.
</p>
<p id="172">
It is possible, using an unofficially documented feature called "immediate
args", to pass arguments to and return a value from a function unboxed,
which allows a further increase in the scope of unboxed compilation.
If this unofficial documentation is desired, contact Franz Inc.
</p>
<pre id="173">
<b>
;Igen9:  No info available to inline ~s as boxed
</b>
</pre>
<p id="174">
If there is no built-in inliner for the call, then this message is
displayed.  Note that we do not support user-declared inlining via
the inline declaration; users should define a compiler-macro for the
function instead.
</p>



<hr><h2 id="175"><a name="ihof-label-3">2.3.11 ;Ihof labels</a></h2>

<p id="176">
These relate to calls to "high order functions".
</p>
<pre id="177">
<b>;Ihof1: This architecture has no instruction for ~s.
</b>
</pre>
<p id="178">
Some high-order-functions are implemented directly in some architectures.
In particular, a floating-point abs is implemented in most architectures
as a single instruction, and sqrt is implemented in several.  On the other
hand, only the x86 architecture implements sin, cos, and tan as single
instructions, or exp and log as short sequences of instructions, as they are
implemented on their x87 floating point units.  Note that the AMD64/EM32T
architecture is not considered an x86 for these purposes; even though they
do have x87 units, they are not part of the standard runtime architecture
and thus we do not make use of the x87 unit on these versions of Allegro CL.
</p>
<p id="179">
If the function being called is a high-order-function supported by any
architecture, but is not one supported by this architecture, then this
message will be given, if other conditions are right.
</p>
<pre id="180">
<b>
;Ihof2:  Arg~d: must be a float type.</b>
</pre>
<p id="181">
The floating point high-order-functions are optimized for float
arguments.  If an unboxed inlining would have tried to compile one of
these with a machine-integer argument, then this message appears and
the unboxed inlining fails. A boxed inlining might succeed later but
there is no
guarantee. (See <a href="#boxing-explain-2">Section 3.2 Boxing explanation</a> for a
definition of boxing.)
</p>
<pre id="182">
<b>
;Ihof3:  Arg~d: type &lt;type&gt; is out of expected range: </b>
</pre>
<p id="183">
Some high-order-functions are implemented mostly as single
instructions in the architecture, but only match Common Lisp's
requirements within a certain range of arguments.  For
example, <b>cl:sqrt</b> returns a complex value when the argument is
negative, but the sqrt instruction available on many architectures
signals or returns a NaN.  On the x86 (x87) architecture, accurate
results are not guaranteed beyond a certain range of argument values.
Thus, in order for the inlining to succeed for one of these
high-order-functions, the argument types must be within the stated
ranges.
</p>




<hr><h2 id="184"><a name="iimm-label-3">2.3.12 ;Iimm labels</a></h2>

<p id="185">
It is possible, using an unofficially documented feature called
"immediate args", to pass arguments to and return a value from a
function unboxed, which allows a further increase in the scope of
unboxed compilation. If this unofficial documentation is desired,
contact Franz Inc.
</p>
<p id="186">
These labels relate to calls to immediate-args functions.
</p>
<pre id="187">
<b>;Iimm1:  Arg~d: looking for immed-args call to &lt;functio&gt;.</b>
</pre>
<p id="188">
If the function name has an immediate-args property, then it and the
call are being examined to see if this optimization can be performed.
</p>

<pre id="189">
<b>;Iimm2:  Node: cannot convert  &lt;type&gt; into immediate  &lt;immed&gt; return value.</b>
</pre>
<p id="190">
If the immediate-args specification for the return value is not
appropriate for the type of the return value, the optimization cannot
be performed.
</p>

<pre id="191">
<b>;Iimm3:  Node: argument count &lt;number&gt; doesn't match argspec &lt;argspec&gt;.</b>
</pre>
<p id="192">
If the argument count of the call isn't appropriate for the
immediate-args specification, then the optimization will not be
performed.
</p>

<pre id="193">
<b>;Iimm4:  Arg~d: looking for one of &lt;type list&gt; but found  &lt;type&gt;.</b>
</pre>
<p id="194">
The types of each argument must match those of the arguments of the
call.  If they don't, then the optimization is not performed.
</p>




<hr><h2 id="195"><a name="ilen-label-3">2.3.13 ;Ilen labels</a></h2>

<p id="196">
These relate to calls to <b>length</b>.
</p>
<pre id="197">
<b>;Ilen1:  Arg~d: checking that type is explicitly non-list:
;Ilen1:  Arg~d: checking that type is explicitly listp:</b>
</pre>
<p id="198">
For a call to length, if it is not known explicitly that the argument
is or is not a list, then run-time code must be generated to test to see
whether the argument is a list, and inline code must be generated to
perform the length operation for both cases.  This message is preparing
for some tests to see if this run-time test and thus one set of inline
code can be elided.
</p>
<pre id="199">
<b>
;Ilen2:  Node: using fast cdr access.</b>
</pre>
<p id="200">
In a lisp which has :verify-car-cdr on the *features* list, if the
verify-car-cdr-switch is returning nil, then the list-walking that is
done to determine the length of the list is performed by
single-instruction cdr operations. This is dangerous if the list is
dotted, because there is no protection against trying to take the cdr
of a non-list (the cdr of the dotted list).
</p>
<pre id="201">
<b>
;Ilen3:  Node: must use call to qcdr.</b>
</pre>
<p id="202">
In a lisp which has :verify-car-cdr on the *features* list, a safe
walk of the list argument to length has been selected.  On the x86
(and some amd64 versions) this means that cdr operations are performed
by calling the "qcdr" runtime-system function, which is slighty slower
than using a single cdr access instruction, but it is safe.
</p>
<pre id="203">
<b>
;Ilen4:  Node: must check cons type for cdr access.</b>
</pre>
<p id="204">
In a lisp which has :verify-car-cdr on the *features* list, a safe
walk of the list argument to length has been selected.  On Power
architectures (AIX, MacOSX on PowerPc, and YellowDog PPC linux)
this means that inline code is generated to determine if the object
being cdr'd down is indeed a cons, and an error is generated at
run-time if not.
</p>



<hr><h2 id="205"><a name="imac-label-3">2.3.14 ;Imac labels</a></h2>

<p id="206">
These relate to multiply/accumulate instructions.
</p>

<pre id="207">
<b>
;Imac1:  Node: trying a multiply/accumlate instruction combination:</b>
</pre>
<p id="208">
Some architectures have "multiply/accumulate" instructions.  These are
three-argument instructions which multiply the first two arguments and
then to that result either add or subtract the other argument.  Some
of these architectures' multiply/accumulate instructions are appropriate
to compilation by Allegro CL.  If so, then this message is displayed
and arguments checked whenever (+ (* op1 op3) op2) or (- (* op1 op3) op2)
is seen.
 </p>
<pre id="209">
<b>
;Imac2:  Node:   - multiply/accumlate attempt succeeded.
;Imac2:  Node:   - multiply/accumlate attempt failed.</b>
</pre>
<p id="210">
One of these messages appears whenever Imac1 is seen.  Either the operation
succeeded or failed, based on what was given as arguments.
</p>



<hr><h2 id="211"><a name="iref-label-3">2.3.15 ;Iref labels</a></h2>

<p id="212">
These relate to array references.
</p>
<pre id="213">
<b>
;Iref1:  Arg~d: looking for (simple-array type ~d) where type is one of &lt;element-types&gt; - got &lt;type&gt;
;Iref1:  Arg~d: looking for (simple-array type ~d) where type is one of &lt;element-types&gt; - failed</b>
</pre>
<p id="214">
This message states that an array access is looking for a simple-array
of some set of element-types and of a specific dimensionality.  If
successful, the actual type that was found is stated.  In order to
inline an array access, it may be declared as a short-simple-array, a
simple-array (i.e., a long simple-array) or a dual-simple-array.  Any
of these three kinds of declarations will cause the inlining to
continue, although if the array is dual-simple-array, a run-time test
for short-ness must be included and two accesses code segments
generated (only one of which will be taken for any given array).  Thus
it is more desirable to specify either simple-array or
short-simple-array, since less code and testing is generated.  The
dimensionality is either a specific integer or * if it doesn't matter.
</p>
<p id="215">
[general array index calculation: A multi-dimensional array has as its
underlying implementation a simple one-dimensional array, large enough
to hold all of the index combinations of the array indices.  For
example, a (simple-array t (2 2)) will have as its base a
(simple-array t 4), and a (simple-array character (3 3 3)) will have
as its base a (simple-array character 27).  The final index is
calculated by multiplying successive indices by the next dimension
over and adding the next index, until all indices are exhausted.  This
calculation might be done at run-time or at compile-time, depending on
how much information the compiler has.]
</p>
<pre id="216">
<b>
;Iref2:  Arg~d: looking for all dimensions declared for faster indexing - failed
;Iref2:  Arg~d: looking for all dimensions declared for faster indexing - got (1 2)</b>
</pre>
<p id="217">
In any array access, if the dimensions of an array are known then faster code
can be generated, since at least some of the indexing can be calculated at
compile-time.  If this test succeeds the message will show what dimensions it
saw declared for the array.  [see general array index calculation]
</p>
<pre id="218">
<b>;Iref3:  Node: must multiply actual dimensions and indices at runtime.</b>
</pre>
<p id="219">
If Iref1 fails, then some multiplication must be done at runtime.  The compiler
generates the multiplication code to do this, and gives this message.
[see general array index calculation]
</p>
<pre id="220">
<b>
;Iref4:  Checking for all array index args to be fixnum constants
;Iref4:  Checking for all array index args to be fixnum constants - failed
</b>
</pre>
<p id="221">
If all of the index args are fixnum constants, then compile-time calculations
can be done.  If not all are constants, the compiler drops down into the Iref5
section to see how many constants it can find.
[see general array index calculation]
</p>
<pre id="222">
<b>;Iref5:  Node: checking if there are any constant index values to avoid multiplication
</b>
</pre>
<p id="223">
This message will be succeeded by any number of Icon1 messages followed by
an Iref6 or an Iref7 message; if the first few arguments to the array access
are constants and are useful to calculating the array index at compile-time,
then this message will show how many such useful constants were found.
[see general array index calculation]
</p>
<pre id="224">
<b>;Iref6:  Node: first index values not constant - must multiply at runtime.</b>
</pre>
<p id="225">
This message will be preceded by an Iref5 message and a single failed
Icon1 message.  It indicates that because the first index was not a
constant, it was not possible to pre-calculate any portion of the final
index at compile-time.
[see general array index calculation]
</p>
<pre id="226">
<b>;Iref7:  Node: found ~d useful index constant~:p.</b>
</pre>
<p id="227">
This message will be preceded by an Iref5 message and any number of Icon1
messages; if the first few arguments to the array access are constants and
are useful to calculating the array index at compile-time, then this message
will show how many such useful constants were found.
[see general array index calculation]
</p>



<hr><h2 id="228"><a name="itab-label-3">2.3.16 ;Itab labels</a></h2>

<p id="229">
These relate to table-driven case (defined below).
</p>
<pre id="230">
<b>;Itab1:Attempt to optimize table-driven case.</b>
</pre>
<p id="231">
When a case macro's keys are all fixnums close together
or <code>t</code> or <code>otherwise</code>, then
the case form can be optimized to what is known as a "table-driven
case" or "table case" for short.  In this situation the keyform is
calculated and the proper match key is selected through a jump table,
rather than by successive comparisons and conditional branches.  This
also results in a constant dispatch time for as many as 256 possible
values for a case, rather than having to rely on placing the keys that
are most likely at the beginning of the case form so they'll be tested
sonner.  Unfortunately the keyform calculations represent overhead
that is not insignificant.  In order to reduce the overhead of testing
for overflows or fixnums, some architectures make use of a new
compiler switch - <a href="variables/compiler/trust-table-case-argument-switch.htm"><code>comp:trust-table-case-argument-switch</code></a>, which
only fires at speed = 3 and safety = 0 (because it is a non-safe
optimization and thus relegated to code which has been carefully
tested already).  This message signals the start of the attempt to
peform this optimization.  Two things must happen in order for this
optimization to complete: speed must be 3 and safety 0, and the type
of the key-form must be declared to be (integer &lt;low&gt;
&lt;high&gt;) where the range of the type falls within acceptable
bounds for table-driven case
<b>and</b> the range covers all possible keys given in the case macro.
</p>
<p id="232">
Warning: This optimization creates the possibility for "correct" code to
run incorrectly, if the case macro has a t/otherwise clause; note that
the t/otherwise clause specifies action for any key-form value that is not
one of the key values, even if that value is not even an integer.  With this
optimization such non-integer or out-of-range values can cause gross trouble.
However, since it is being compiled with unsafe code, and a type of
(integer x y) is also required, any violation of that type constitutes
undefined behavior by the lisp, and the unsafe-ness is justified.  The
only valid values that the t/otherwise clause should see are those which
do not match any keys but which are within the (integer x y) range.
</p>
<pre id="233">
<b>
;Itab2:looking for test type range to be ~d max - got ~d.
</b>
</pre>
<p id="234">
Each architecture has a maximum spread that all keys can be in order for a
table-case to be performed (see Itab1).  This statement shows that
architecture-dependent value and the range specified by the key-form's type.
If the key-form's type is too large, the optimization will fail.
</p>
<pre id="235">
<b>
;Itab3:looking for match range to be subtype of ~s - got (integer ~d ~d).</b>
</pre>
<p id="236">
When it is determined by Itab2 that a table-case's key-form has an acceptable
type range, the range of actual keys is compared to the declared type of the
key-form (the keys are gathered and all holes filled to form a type of the
form (integer min max) where min is the smallest key and max is the largest.
If the key range is not a subtype of the declared key-form's type, the
optimization fails.
</p>
<pre id="237">
<b>
;Itab4:Optimization attempt succeeded.  Table case will compile more efficiently if supported.</b>
</pre>
<p id="238">
This message is shown when all high-level criteria are satisfied for a table-case
(see Itab1, Itab2, Itab3).  If the architecture supports the optimization, then
it will be implemented, otherwise it will be silently ignored and the safe
table-driven case will be compiled.
</p>



<hr><h2 id="239"><a name="ityp-label-3">2.3.17 ;Ityp labels</a></h2>

<p id="240">
These are general messages about types.
</p>
<pre id="241">
<b>;Ityp1:  Arg~d: looking for &lt;type&gt; - failed
;Ityp1:  Arg~d: looking for &lt;type&gt; - got &lt;normalized subtype&gt;
;Ityp1:  Arg~d: looking for one of &lt;list of types&gt; - failed
;Ityp1:  Arg~d: looking for one of &lt;list of types&gt; - succeeded
;Ityp1:  Arg~d: looking for (not fixnum) - got (double-float * *)</b>
</pre>
<p id="242">
These general messages appear whenever the compiler is looking
specifically for a value to have a certain type or types.  The first
two cases are looking for a single type - if successful the
normalized-type is shown (see <a href="operators/excl/normalize-type.htm"><b>excl:normalize-type</b></a>) the third and fourth
forms are looking for the value to be one of a list of types.  The
actual type found is not shown, but can be seen in a Tres1 message
when :explain :types is enabled.  The last message is similar to the
first two; a single type is being looked for, but the type is of the
form (not &lt;type&gt;) and currently the only way to do this is by
specifically declaring the value to be of a type that precludes the
other.  In this example, a double-float does indeed mean that the
value cannot possibly be a fixnum.
</p>
<pre id="243">
<b>;Ityp2:  Node: checking that this node is purely &lt;type&gt;</b>
</pre>
<p id="244">
Many times an expression of the form
</p>
<pre id="245">
 (op arg1 arg2) -&gt; result
</pre>
<p id="246">
can be optimized if all of arg1, arg2 and result are of the same type.
Float values are handled by Ityp3, but fixnums and machine-integers
(where the compiler might not be able to assume that the result is of
that type, even if both arguments are of that type) are handled by
this message.  Ityp1 tests will be done on each of the arguments and on
the node (the result of the expression).  Note that the compiler cannot
assume that two fixnums added together will result in a fixnum, except
under special circumstances or under unsafe compilations where
comp:declared-fixnums-remain-fixnum-switch returns true.  Thus,
</p>
<pre id="247">
(let ((a x) (b y))
  (declare (fixnum  a b))
  (+ a b))
</pre>
<p id="248">
May fail to be "purely fixnum", but 
</p>
<pre id="249">
(let ((a x) (b y))
  (declare (fixnum  a b))
  (the fixnum (+ a b)))
</pre>
<p id="250">
will always be purely fixnum (as long as declarations are trusted).
If the Ityp1 messages after this one succeed, then the optimization
may also succeed.
</p>
<pre id="251">
<b>;Ityp3:  Node: checking for only &lt;type&gt; args (including coercible constants):</b>
</pre>
<p id="252">
For float values, the compiler can infer the type of the result of an
expression, based on floating-point contagion of the types of the
arguments.  Some Ityp1 messages will be shown along with their
results, and if successful, allow the optimization to succeed.
</p>




<hr><h2 id="253"><a name="m-labels-2">2.4 tailmerging (M) labels</a></h2>

<ul>
<li id="254">
<a href="#merg-label-3">Section 2.4.1 ;Merg labels</a>
</li>
<li id="255">
<a href="#mnot-label-3">Section 2.4.2 ;Mnot labels</a>
</li>
</ul>

<hr><h2 id="256"><a name="merg-label-3">2.4.1 ;Merg labels</a></h2>

<p id="257">
These relate to successful tail merging.
</p>

<pre id="258">
<b>;Merg1:  merged a call to ~s as a self-tail-jump</b>
</pre>
<p id="259">
This message indicates that a call to the current function being compiled
was changed to a jump to the beginning.  The normal calling sequence is
short-circuited, so arguments are not saved and tracing/stepping/call-counting
will not be performed on this "call".
</p>
<pre id="260">
<b>;Merg2:  merged a call to ~s as a non-self-tail-jump</b>
</pre>
<p id="261">
This message indicates that a call to a function was changed to a jump to
the normal lisp function entry code.  The function being called might
be the same as the one being compiled, but the call-turned-jump is performed
as if the call were to another function (i.e. the jump is through the name,
the arguments are saved if argument-saving is on, and trace/step/call-counting
all will work for this particular call).
</p>


<hr><h2 id="262"><a name="mnot-label-3">2.4.2 ;Mnot labels</a></h2>

<p id="263">
These relate to unsuccessful tail merging.
</p>

<pre id="264">
<b>;Mnot1: failed to merge a call to ~s as a self-tail-jump because function is closed-over</b>
</pre>
<p id="265">
This message states that tail merging was thwarted because the
function being compiled/called is creating a closure over some
variables, which makes it not conducive to tail-merging; the function
that is a closure is not complete without its closure environment,
which is set up as a part of a normal function call.  Note that the
self-call might still be merged as a jump in a non-self manner (where
the closure environment is set up by a jump through the normal
function calling sequence).
</p>
<pre id="266">
<b>;Mnot2: failed to merge a call to ~s as a self-tail-jump because function is declared notinline</b>
</pre>
<p id="267">
This message states that tail merging was thwarted because the function being
called was declared notinline (the notinline declaration may or may not
have been in effect at the start of the compilation of the function).  The
compiler takes the notinline declaration to be a request to treat an
expression with that operator as a simple function call.  This allows
a call to foo within foo to be traced, etc. even though the call would
otherwise have been mergable.
</p>


<pre id="268">
<b>;Mnot3: failed to merge a call to ~s as a self-tail-jump because unstructured stack allocations are present in the calling function</b>
</pre>
<p id="269">
This message states that tail merging was thwarted because the
function being compiled has unstructured stack-allocations. When
objects are allocated in that unstructure way, it is impossible to
tell whether they are alive or dead at the time. Unless it could be
proved that these stack-allocated values are not passed in as
arguments to the call, it can thus not be proved that the stack is not
needed for the function being called again.  Compare with Mnot9.
</p>

<pre id="270">
<b>;Mnot4: failed to merge a call to ~s as a non-self-tail-jump because function is specially listed as not tailmergable
</b>
</pre>
<p id="271">
This message states that tail merging was thwarted because the function
being called is used for debug purposes and is listed as one for which
tail-merging should _not_ be done.  This guarantees that the stack will
have enough information in it to do effective debugging of any problems.
</p>
<pre id="272">
<b>;Mnot5: failed to merge a call to ~s as a non-self-tail-jump because tail-call-non-self-merge-switch is returning nil</b>
</pre>
<p id="273">
This message states that tail merging was thwarted because the
compiler switch that controls non-self tail-merging is disallowing the
merging to take place.
</p>


<pre id="274">
<b>;Mnot6: failed to merge a call to ~s as non-self-tail-jump because of
machine-dependent reasons (such as register limits)</b>
</pre>
<p id="275">
This message states that tail merging was thwarted because the
architecture didn't allow it.  This message is usually given when the
number of arguments is greater than both the number of arguments
passed in registers on this architecture and also greater than the
number of arguments that the calling function received.  The reason
this is important is: the tail merging operation will "take over" the
stack space alloted to the calling function, for the purpose of
whatever stack space the callee needs.  The caller's caller allocated
stack space for all arguments that the caller will use, but if the
callee must receive more arguments than that, there is not enough
stack space.
</p>
<p id="276">
For example:
</p>
<pre id="277">
(defun foo (x1 x2)
  (bar (x1 x2 1 2)))

(defun bar (w x y z)
  (bas w x y z 10 20))
</pre>
<p id="278">
In this example, when compiled, foo will allocate at least slots for 4
arguments.  On some architectures, such as Powerpc, it will allocate
slots for 8 arguments, because the first 8 arguments are always passed
in registers and the allocation always shadows the register set.  On
the x86, which passes only 2 arguments in registers, there are only
exactly 4 slots allocated.  But when bar is compiled, there must be at
least 6 slots allocated for arguments.  On the Powerpc, this is not a
problem, because it is already known that bar's caller has allocated
at least 8 aarguments, and so there is room for at least 6 arguments
for the tail-merge.  But for the x86, the compilation of bar doesn't
know how much stack space bar's caller allocated (in this situation,
it was only 4 slots) so it can't assume that enough space was
allocated to accomodate the call to bas.  Thus the merge will fail on
x86 but will succeed (or, at least, not fail for this reason) on
Powerpc.
</p>

<pre id="279">
<b>;Mnot7: failed to merge a call to ~s as a non-self-tail-jump because there are catches in the calling function</b>
</pre>
<p id="280">
This message states that tail merging was thwarted because there are active
catches at the point of the tail call, which means that the catch-frame must
be unlinked on the way back from executing the callee. Note that if a
catch was entered but then exited again, the tail-merging is still possible.
</p>
<pre id="281">
<b>;Mnot8: failed to merge a call to ~s as a non-self-tail-jump because the call is an applyn call</b>
</pre>
<p id="282">
This message states that tail merging was thwarted because an applyn
call (see doc on applyn in <a href="compiling.htm#stack-consing-2">Stack consing, avoiding consing using apply, and
stack allocation</a> in <a href="compiling.htm">compiling.htm</a>)
requires the stack to be a specific format.
</p>


<pre id="283">
<b>;Mnot9: failed to merge a call to ~s as a non-self-tail-jump because
unstructured stack allocations are present in the calling function</b>
</pre>
<p id="284">
This message states that tail merging was thwarted because the
function being compiled has unstructured stack-allocations. When
objects are allocated in that unstructure way, it is impossible to
tell whether they are alive or dead at the time. Unless it could be
proved that these stack-allocated values are not passed in as
arguments to the call, it can thus not be proved that the stack is not
needed for the new function being called.  Compare with Mnot3.
</p>

<pre id="285">
<b>;Mnota: failed to merge a call to ~s as a non-self-tail-jump because of an unknown reason</b>
</pre>
<p id="286">
This message states that tail merging was thwarted because there is an
internal compiler inconsistency.  This message should never be seen.
Please report if it is seen.
</p>



<pre id="287">
<b>;Mnotb: failed to merge a call to ~s as non-self-tail-jump because
structured stack allocations are not dead in the calling function</b>
</pre>
<p id="288">
This message states that tail merging was thwarted because the
function being compiled has structured lifo (last in, first out)
stack-allocations. When objects are lifo allocated, the compiler knows
that some of the objects are still alive. Unless it could be proved
that these stack-allocated values are not passed in as arguments to
the call, the stack is needed.  Compare with Mnot9.
</p>



<pre id="289">
<b>;Mnotc: failed to merge a call to ~s as self-tail-jump because
structured stack allocations are not dead in the calling function</b>
</pre>
<p id="290">
This message states that tail merging was thwarted because the
function being compiled has structured lifo (last in, first out)
stack-allocations. When objects are lifo allocated, the compiler knows
that some of the objects are still alive. Unless it could be proved
that these stack-allocated values are not passed in as arguments to
the call, the stack is needed.  Compare with Mnot3.
</p>






<hr><h2 id="291"><a name="t-labels-2">2.5 :type (T) labels</a></h2>

<ul>
<li id="292">
<a href="#targ-label-3">Section 2.5.1 ;Targ labels</a>
</li>
<li id="293">
<a href="#tgen-label-3">Section 2.5.2 ;Tgen labels</a>
</li>
<li id="294">
<a href="#tinf-label-3">Section 2.5.3 ;Tinf labels</a>
</li>
<li id="295">
<a href="#tres-label-3">Section 2.5.4 ;Tres labels</a>
</li>
</ul>


<hr><h2 id="296"><a name="targ-label-3">2.5.1 ;Targ labels</a></h2>

<p id="297">
These relate to arguments.
</p>

<pre id="298">
<b>;Targ1:   call to ~s</b>
</pre>
<p id="299">
Within <b>Targ1</b>, arguments are examined to see what they are.
This message indicates that a "call" node was found; i.e. the argument
to the call is a call itself.
</p>
<pre id="300">
<b>;Targ2:   symeval ~s
;Targ2:   symeval ~s (a special)
;Targ2:   symeval ~s (an instance var)
;Targ2:   symeval ~s (closed over)</b>
</pre>
<p id="301">
Within <b>Targ2</b>, arguments are examined to see
what they are.  This message states that a symbolic variable was
found, of the kind shown.  Note that a symeval node that has as its
type only one possible value is often treated by the compiler as a
constant.  So, for example, (let ((x 1)) (foo x)) can treat x as if it
were the constant 1 - the type propagation assigns the type range
(integer 1 1) to the value of x, and since it is only assigned in that
spot, its value can be considered constant.
</p>
<pre id="302">
<b>;Targ3:   constant ~s</b>
</pre>
<p id="303">
Within <b>Targ3</b>, arguments are examined to see
what they are.  This message indicates that a constant was seen.
</p>
<pre id="304">
<b>;Targ4    a &lt;(some other kind of node)&gt;:</b>
</pre>
<p id="305">
Within <b>Targ3</b>, arguments are examined to see
what they are.  This message indicates that the node was something
other than a call, symbolic-variable, or constant.  The kind of node
is shown as an indicator.
</p>



<hr><h2 id="306"><a name="tgen-label-3">2.5.2 ;Tgen labels</a></h2>

<p id="307">
These relate to general calls.
</p>
<pre id="308">
<b>;Tgen1: Examined a call to ~s with arguments:
;Tgen1: Examined a (possibly unboxed) call to ~s with arguments:</b>
</pre>
<p id="309">
This message starts the type examination of each call node.  The node
consists of arguments to an operator and the node itself, which is the
result of the operation.  Further messages will state what has been
found.  It is in the past tense because the examination has already
been done and the reporting is just showing what was found.  This is
in contrast to how other :explain options work, since the other
operations report what is being seen as progress is being made.
</p>
<p id="310">
This message will be followed by a number of <b>Targ</b> messages
(see <a href="#targ-label-3">above</a>), one for
each argument in the function call being examined. Each complete Targ
message will correspond to arguments in the function call, in order
from left to right. Following the arguments, a Tres message
(see <a href="#tres-label-3">below</a>) might be
given if a result is present. This ordering can also be correlated to
Arg~d and Node sublabels in :inlining explanations
(see <a href="#i-labels-2">Section 2.3 :inlining (I) labels</a>).
</p>



<hr><h2 id="311"><a name="tinf-label-3">2.5.3 ;Tinf labels</a></h2>

<p id="312">
These relate to calls to function or variable information.
</p>

<pre id="313">
<b>;Tinf1:     function-information: ~s
;Tinf1:     variable-information: ~s</b>
</pre>
<p id="314">
If in addition to regularly propagated type information, there is
information available about a function or variable within the current
lexical and/or dynamic environment, this message is displayed with
that information.  The propagated type and the environment type
information are used in concert by the compiler which looks for as
much information as possible in order to provide as much optimization
as is possible.
</p>



<hr><h2 id="315"><a name="tres-label-3">2.5.4 ;Tres labels</a></h2>

<pre id="316">
<b>;Tres1: which returns a value of type ~s
;Tres1: which returns a value in fixnum range of type ~s</b>
</pre>

<p id="317">
This message indicates the type of the node being examined by the
<code>:types</code> explanation; the node describes the value of
the form. In the first form, the type is given simply as a normalized
type. The second form is similar to the first, except that the
compiler has also recognized that the type is a subtype of the fixnum
type.  This is useful information, because it is sometimes hard to
know whether an integer range is within fixnum range or not.
</p>






<hr><h2 id="318"><a name="v-labels-2">2.6 :variable (V) labels</a></h2>

<ul>
<li id="319">
<a href="#vreg-label-3">Section 2.6.1 ;Vreg labels</a>
</li>
<li id="320">
<a href="#vflt-label-3">Section 2.6.2 ;Vflt labels</a>
</li>
<li id="321">
<a href="#vmem-label-3">Section 2.6.3 ;Vmem labels</a>
</li>
</ul>


<hr><h2 id="322"><a name="vreg-label-3">2.6.1 ;Vreg labels</a></h2>

<p id="323">
These messages are about data stored in registers.
</p>

<pre id="324">
<b>;Vreg1: Variables stored in general data registers: ~s.</b>
</pre>

<p id="325">
This message indicates that the list given names variables that
are placed into general data registers.  Not all architectures
generate this message, because it would clutter up the output
and cause it to become confusing.  Ultra-temporary values which
do not have variable names are not listed.
</p>

<pre id="326">
<b>;Vreg2: Variables stored in permanent general registers: ~s.</b>
</pre>

<p id="327">
This message indicates that the list given names variables that
are assigned permanently (at least, during the life of the variable)
to a particular register.  These would be caller-saves registers,
which might either be saved on the stack or via register windows
during a function call.  Ultra-temporary values which
do not have variable names are not listed.
</p>



<hr><h2 id="328"><a name="vflt-label-3">2.6.2 ;Vflt labels</a></h2>

<p id="329">
These messages are about where floating-point data is stored.
</p>
<pre id="330">
<b>;Vflt1: Variables stored in floating point registers: ~s.</b>
</pre>

<p id="331">
This message indicates that the list given names variables that
are placed into floating-point registers. Ultra-temporary values which
do not have variable names are not listed.
</p>

<pre id="332">
<b>;Vflt2: Variables stored in floating point memory: ~s.</b>
</pre>

<p id="333">
This message indicates that the list given names variables that
are stored onto the stack, in an area reserved for non-gc'd data.
This area is not volatile across function calls.
</p>



<hr><h2 id="334"><a name="vmem-label-3">2.6.3 ;Vmem labels</a></h2>

<p id="335">
This message is about where non-floating-point data is stored.
</p>

<pre id="336">
<b>;Vmem1: Variables stored in (non-floating-point) memory: ~s.</b>
</pre>

<p id="337">
This message indicates that the list given names variables that
are stored into the stack, in an area that contains lisp data.
This area is not volatile across function calls.
</p>






<hr><hr><h2 id="338"><a name="explain-1">3.0 Examples using the :explain declaration</a></h2>

<p id="339">
The format of the :explain declaration is described in <a href="compiling.htm#decl-help-1">Help with declarations: the
:explain declaration</a> in
<a href="compiling.htm">compiling.htm</a>. The sections above in this document
list the labels used in :explain output. The subsections below
describe particular :explain types and show examples.
</p>
<p id="340">
Compilers in Allegro CL are specific to platforms, and particularly to
the processor chip used. Because compilers work differently on
different platforms, :explain output will differ on different
platforms. The examples below are designed to show how to use the
:explain feature and how to interpret the output. You will very likely
see different results with your Lisp on your machine.
</p>

<hr><h2 id="341"><a name="calls-types-explain-2">3.1 Calls and types explanation</a></h2>

<p id="342">
<code>:calls</code> should not be used with
<code>:inlining</code> since calls information is provided by
the <code>:inlining</code>
explanation. <code>:types</code> provides different information
and can be used with <code>:inlining</code>.
</p>

<p id="343">
The example below shows simple use of the <code>:explain</code>
declaration. The user is working with two-dimensional arrays of 8-bit
data returned by an image scanner, and writes a function that computes
the average data value in an array. Environment information is also
available in Allegro CL (identifying, for example, lexical
variables). See <a href="environments.htm">environments.htm</a> for information on
how you might be able to augment the compilation environment, thus
allowing variables that have not been setq'd within those blocks to be
type-specified to a tighter type spec (resulting in better
compilations).
</p>

<pre id="344">


cl-user(15): (defun 2d-avg (ar)
	   (declare (:explain :types :calls)
                    (optimize (speed 3) (safety 1))
		    (type (array (unsigned-byte 8) (* *)) ar))
	   (let ((sum 0))
	     (declare (fixnum sum))
	     (dotimes (x 64)
	       (dotimes (y 64)
		 (declare (:explain :calls :types))
		 (incf sum (aref ar x y))))
	     (/ sum 4096)))
2d-avg
cl-user(16): (compile *)
; While compiling 2d-avg:
;Tgen1:Examined a call to &gt;=_2op with arguments:
;Targ2:  symeval x type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Targ3:  constant 64 type in fixnum range (integer 64 64)
;Tres1:   which returns a value of type t
;Tgen1:Examined a call to &gt;=_2op with arguments:
;Targ2:  symeval y type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Targ3:  constant 64 type in fixnum range (integer 64 64)
;Tres1:   which returns a value of type t
;Call1:Generated a non-inline call to aref_2d:
;Tgen1:Examined a call to aref_2d with arguments:
;Targ2:  symeval ar type (array (integer 0 255) (* *))
;Tinf1:     variable-information: lexical: ((type (array # #)))
;Targ2:  symeval x type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Targ2:  symeval y type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Tres1:   which returns a value in fixnum range of type (integer 0 255)
;Tgen1:Examined a call to +_2op with arguments:
;Targ2:  symeval sum type in fixnum range (integer -536870912 536870911)
;Tinf1:     variable-information: lexical: ((type
                                             (integer -536870912 536870911)))
;Targ2:  symeval g27 type in fixnum range (integer 0 255)
;Tres1:   which returns a value in fixnum range of type
;Tres1:   (integer -536870912 536870911)
;Tgen1:Examined a call to +_2op with arguments:
;Targ2:  symeval y type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Targ3:  constant 1 type in fixnum range (integer 1 1)
;Tres1:   which returns a value in fixnum range of type (integer 0 64)
;Tgen1:Examined a call to +_2op with arguments:
;Targ2:  symeval x type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Targ3:  constant 1 type in fixnum range (integer 1 1)
;Tres1:   which returns a value in fixnum range of type (integer 0 64)
;Call1:Generated a non-inline call to /_2op:
;Tgen1:Examined a call to /_2op with arguments:
;Targ2:  symeval sum type in fixnum range (integer -536870912 536870911)
;Tinf1:     variable-information: lexical: ((type
                                             (integer -536870912 536870911)))
;Targ3:  constant 4096 type in fixnum range (integer 4096 4096)
;Tres1:   which returns a value of type (rational * *)
2d-avg
nil
nil
cl-user(17): 

</pre>


<p id="345">
See <a href="#t-labels-2">Section 2.5 :type (T) labels</a> and
<a href="#c-labels-2">Section 2.2 :calls (C) labels: CallN</a> for explanations of the
labels in the output in the examples in this section.
</p>
<p id="346">
Note a couple of points: (1) whenever the system prints that it
<em>examined</em> a call to a function, that means the function is a
candidate for opencoding; (2) if opencoding does not succeed, a
message, typically with a :Call label, is printed saying that the
system <em>generated a non-in-line</em> call to the function (often
before the <em>examined</em> messages). Therefore, if no
<em>generated...</em>, the function was inlined. In the example, there
are non-inline calls to <b>aref_2d</b> and <b>/_2op</b>.
</p>
<p id="347">
Your first reaction might be "what are those functions"? When
optimizing code, Allegro CL often uses internal variants of standard
functions. The associated standard function can usually be easily
recognized: <b>aref_2d</b> is <a href="../ansicl/dictentr/aref.htm"><b>aref</b></a> with a 2-d array argument. <b>/_2op</b> is
two-argument divide.
</p>
<p id="348">
So why didn't they opencode? In <a href="compiling.htm#supported-ops-2">Supported operations</a> in
<a href="compiling.htm">compiling.htm</a> we list various candidates for
opencoding. There is says that
<strong>aref</strong> of a simple array can opencode. Here, the
argument to <strong>aref</strong> is declared to be a (general)
array. First we change that declaration.
</p>
<p id="349">
The last form divides the sum of values by 4096, we are dividing two
fixnums (we have declared that <code>sum</code> is a
fixnum). But / doesn't opencode for fixnums at least on the platform
where this operation was tested. (Behavior may differ on different
platforms: you should always try the examples yourself. They are here
to illustrate the procedure only.) We could fix that by floating the
values and getting a single-float result.
</p>

<pre id="350">
user(6): (defun 2d-avg (ar)
	   (declare (optimize (speed 3) (safety 1)) (:explain :types :calls)
		    (type (simple-array (unsigned-byte 8) (* *)) ar))
	   (let ((sum 0))
	     (declare (fixnum sum))
	     (dotimes (x 64)
	       (dotimes (y 64)
		 (declare (:explain :calls :types))
		 (incf sum (aref ar x y))))
	     (/ (float sum 1.0f0) 4096.0f0)))
2d-avg
user(7): (compile '2d-avg)
;Examining a call to &gt;=_2op with arguments:
;Tgen1:Examined a call to &gt;=_2op with arguments:
;Targ2:  symeval x type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Targ3:  constant 64 type in fixnum range (integer 64 64)
;Tres1: which returns a value of type t
;Tgen1:Examined a call to &gt;=_2op with arguments:
;Targ2:  symeval y type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Targ3:  constant 64 type in fixnum range (integer 64 64)
;Tres1: which returns a value of type t
;Tgen1:Examined a call to aref_2d with arguments:
;Targ2:  symeval ar type (simple-array (integer 0 255) (* *))
;Tinf1:     variable-information: lexical: ((type (simple-array # #)))
;Targ2:  symeval x type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Targ2:  symeval y type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Tres1: which returns a value in fixnum range of type (integer 0 255)
;Tgen1:Examined a call to +_2op with arguments:
;Targ2:  symeval sum type in fixnum range (integer -536870912 536870911)
;Tinf1:     variable-information: lexical: ((type
                                             (integer -536870912 536870911)))
;Targ2:  symeval g36059 type in fixnum range (integer 0 255)
;Tres1: which returns a value in fixnum range of type (integer
                                                       -536870912
                                                       536870911)
;Tgen1:Examined a call to +_2op with arguments:
;Targ2:  symeval y type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Targ3:  constant 1 type in fixnum range (integer 1 1)
;Tres1: which returns a value in fixnum range of type (integer 0 64)
;Tgen1:Examined a call to +_2op with arguments:
;Targ2:  symeval x type in fixnum range (integer 0 64)
;Tinf1:     variable-information: lexical: ((type (integer 0 64)))
;Targ3:  constant 1 type in fixnum range (integer 1 1)
;Tres1: which returns a value in fixnum range of type (integer 0 64)
;Tgen1:Examined a (possibly unboxed) call to to-single-float with arguments:
;Targ2:  symeval sum type in fixnum range (integer -536870912 536870911)
;Tinf1:     variable-information: lexical: ((type
                                             (integer -536870912 536870911)))
;Tres1: which returns a value of type (single-float * *)
;Tgen1:Examined a (possibly unboxed) call to /_2op with arguments:
;Targ1:  call to to-single-float type (single-float * *)
;Targ3:  constant 4096.0 type (single-float 4096.0 4096.0)
;Tres1: which returns a value of type (single-float * *)
2d-avg
nil
nil
cl-user(8): 
</pre>


<p id="351">
This time, success.
</p>

<p id="352">
Note, by the way, the declaration <code>(optimize</code>
<code>(speed 3)</code> <code>(safety 1))</code>. The <a href="variables/compiler/trust-declarations-switch.htm"><code>trust-declarations-switch</code></a>
must be true (as it is when speed is greater than safety) for the
<code>:explain</code> <code>:types</code> and <code>:calls</code>
declaration to have effect.
</p>



<hr><h2 id="353"><a name="boxing-explain-2">3.2 Boxing explanation</a></h2>

<p id="354">
<code>:boxing</code> should not be used with
<code>:inlining</code> since boxing information is provided by
the :inlining explanation.
</p>
<p id="355">
A number is <em>boxed</em> when it is converted from its machine
representation to the Lisp representation. For floats, the machine
representation is one (for singles) or two (for doubles) words. Lisp
adds an extra word, which contains a pointer and a type code. For
fixnums, boxing simply involves a left shift, of two bits in 32-bit
Lisps and 3 in 64-bit Lisp.. For bignums which are in the range of
machine integers, boxing again adds an additional word. 
</p>
<p id="356">
A box can also
exist for multiple Lisp numbers. For single-floats, an array
specialized with <code>:element-type 'single-float</code> can
serve as a box for as many single-floats as the size of the array.
For double-floats, an array of double-floats serves as the multiple
box.  And for machine-integers, an array of <code>:element-type
'(signed-byte N)</code>, where N is 32 or 64, depending on whether
the Lisp is a 32-bit lisp or a 64-bit lisp, will house machine-integer
floats.
</p>

<p id="357">
Boxing obviously involves a computational overhead, but more important
it involves a space overhead. If a calculation involves the
calculation of thousands of floats, for example, thousands of bytes of
space will be used. Often that space need not be used. Let us consider
a simple example. <code>darray</code> is a vector of double
floats. The function <strong>foo-insert</strong> takes a vector, an
index, and a double float as arguments, does something to the double
float (adds 2.0d0 but it could be anything) and stores the result into
the vector at the indicated index. Suppose things were defined as
follows:
</p>

<pre id="358">
(setq darray (make-array 10 :element-type 'double-float 
                         :initial-element 0.0d0))

(defun foo-insert (arr index value)
  (declare (type (simple-array double-float 1) arr)
           (fixnum index)
           (double-float value)
           (optimize (speed 3))
           (:explain :boxing))
  (setf (aref arr index)(+ value 2.0d0)))
</pre>


<p id="359">
When we compile <strong>foo-insert</strong>, we are warned that one
double-float is boxed:
</p>

<pre id="360">
user(16): (compile 'foo-insert)
;Bgen1:Generated a double-float box
foo-insert
nil
nil
user(17):
</pre>

<p id="361">
See <a href="#b-labels-2">Section 2.1 :boxing (B) labels: Bgen1</a> for explanations of the
labels in the output in the examples in this section.
</p>
<p id="362">
Examining the code, we notice that: <strong>foo-insert</strong>
returns a double-float (returned by the <strong>setf</strong>
form). That value must be boxed before it can be returned. This can be
fixed by adding <code>nil</code> at the end of the
definition of <strong>foo-insert</strong>, so it returns <code>nil</code> instead:
</p>

<pre id="363">
(defun foo-insert (arr index value)
  (declare (type (simple-array double-float 1) arr)
           (fixnum index)
           (double-float value)
           (optimize (speed 3))
           (:explain :boxing))
  (setf (aref arr index)(+ value 2.0d0))
  nil)
</pre>


<p id="364">
We try compiling again and no boxing is reported:
</p>

<pre id="365">
user(28): (compile 'foo-insert)
foo-insert
nil
nil
user(29): 
</pre>



<hr><h2 id="366"><a name="variables-explain-2">3.3 Variables explanation</a></h2>

<p id="367">
Local variables in functions can be stored, during a function call,
in memory or in registers. Storing in registers is faster, but there
are only so many registers to go around. The compiler works out the
live ranges of locals (the live range goes from when a local is first
assigned a value until that value is last accessed) and then schedules
register assignments. Unassigned locals are assigned to a memory
location, so an access requires a fetch from memory and a store to
memory.
</p>

<p id="368">
To illustrate explaining variables, consider the following function,
which has many arguments (which are treated as locals) and locals. The
call to <strong>bar</strong> between the <strong>let</strong> bindings
and the call to <strong>list</strong> ensures that the live range of
all the variables lasts until the call to <strong>list</strong>. We
show compilations on various platforms to make clear how behavior is
platform-dependent.
</p>

<pre id="369">
<b>On x86 (such as Linux or Windows):</b>

cl-user(1): (defun bar (&rest args) nil)
bar
cl-user(2): (defun foo (a b c d e f g)
           (declare (:explain :variables))
           (declare (single-float a b c) (double-float d))
           (let ((h (+ a b)) 
                 (i (- a c))
                 (j (* c e))
                 (k (- d c))
                 (l f)
                 (m e)
                 (n g))
             (bar)
	     (list a b c d e f g h i j k l m n)))
foo
cl-user(3): (compile *)
;Vmem1: Variables stored in (non-floating-point) memory: (a h b i j k).
foo
nil
nil
cl-user(4): 

<b>On sparc:</b>

cl-user(3): (compile *)
;Vreg1: Variables stored in general data registers:
;Vreg1: (a b c d e b h c i c e j k a c d e).
;Vreg2: Variables stored in permanent general registers:
;Vreg2: (h h i i j k k).
foo
nil
nil
cl-user(4): 

<b>On PowerPC (used on AIX, MacOSX):</b>

cl-user(3): (compile *)
;Vreg2: Variables stored in permanent general registers:
;Vreg2: (a d f g h b c e i).
;Vmem1: Variables stored in (non-floating-point) memory: (j k).
foo
nil
nil
cl-user(4): 
</pre>

<p id="370">
See <a href="#b-labels-2">Section 2.1 :boxing (B) labels: Bgen1</a> for explanations of the
labels in the output in the examples in this section.
</p>
<p id="371">
Note that it is not recommended that you proclaim (with <a href="../ansicl/dictentr/proclaim.htm"><b>proclaim</b></a>, so that it happens all the
time) explanation of variables since reports will then be made on
things compiled automatically (such as methods and foreign functions),
causing unexpected messages to be printed to the terminal from time to
time.
</p>




<hr><h2 id="372"><a name="tailmerging-explain-2">3.4 Tail-merging explanation</a></h2>

<p id="373">
See <a href="#m-labels-2">Section 2.4 tailmerging (M) labels</a> for explanations of the
labels in the output in the examples in this section.
</p>
<p id="374">
There are two tailmerging compiler switches: <a href="variables/compiler/tail-call-non-self-merge-switch.htm"><code>tail-call-non-self-merge-switch</code></a> and
<a href="variables/compiler/tail-call-self-merge-switch.htm"><code>tail-call-self-merge-switch</code></a>. When the
<code>:explain (:tailmerging t)</code> declaration is in effect,
failure to tailmerge for any reason will be noted. A common reason
is the setting of the optimization qualities are making the switches
return <code>nil</code>, as in the following example:
</p>

<pre id="375">


cl-user(14): :opt

A response of ? gets help on possible answers.

compiler optimize safety setting (0 is fastest): [1] 
compiler optimize space setting: [1] 
compiler optimize speed setting (3 is fastest): [1] 
compiler optimize debug setting (3 is maximum): [2] 
compiler optimize compilation-speed setting (3 is maximum): [1] 

Compiler optimize setting is
     (declaim (optimize (safety 1) (space 1) (speed 1) (debug 2)
                        (compilation-speed 1)))

cl-user(15): (print-startup-info :compiler-switches)
;; These are the values returned by the compiler switch functions given
;; the specified speed, safety, space and debug optimization qualities
;; (current values are used when values are not specified as arguments):
;;
;; [...]
;; compiler:tail-call-non-self-merge-switch             nil
;; compiler:tail-call-self-merge-switch                 t
;; [...]
;;
nil
cl-user(16): (defun foo (x) (declare (:explain :tailmerging)) (bar x))
foo
cl-user(17): (compile 'foo)
;Mnot5: failed to merge a call to bar as non-self-tail-jump because comp:tail-call-non-self-merge-switch is returning nil
foo
nil
nil
cl-user(18): :opt


A response of ? gets help on possible answers.

compiler optimize safety setting (0 is fastest): [1] 
compiler optimize space setting: [1] 
compiler optimize speed setting (3 is fastest): [1] 3
compiler optimize debug setting (3 is maximum): [2] 0
compiler optimize compilation-speed setting (3 is maximum): [1]

Compiler optimize setting is
     (declaim (optimize (safety 1) (space 1) (speed 3) (debug 0)
                        (compilation-speed 1)))


cl-user(19): (defun foo (x) (declare (:explain :tailmerging)) (bar x))
foo
cl-user(20): (compile 'foo)
;Merg1:  merged a call to bar as a non-self-tail-jump
foo
nil
nil
cl-user(21): 
</pre>


<p id="376">
Self tail merges are done (by default) unless speed is 0.
Continuing from above:
</p>

<pre id="377">
cl-user(25): (defun fact (n)
	       (declare (:explain :tailmerging))
	       (if (= n 0) 1) (fact (- n 1)))
fact
cl-user(26): (compile 'fact)
;Merg1:  merged a call to fact as a self-tail-jump
fact
nil
nil
cl-user(27): :opt



A response of ? gets help on possible answers.

compiler optimize safety setting (0 is fastest): [1] 1
compiler optimize space setting: [1] 
compiler optimize speed setting (3 is fastest): [1] 0
compiler optimize debug setting (3 is maximum): [2] 2
compiler optimize compilation-speed setting (3 is maximum): [1] 

Compiler optimize setting is
     (declaim (optimize (safety 1) (space 1) (speed 0) (debug 2)
                        (compilation-speed 1)))

cl-user(28): (defun fact (n)
	       (declare (:explain :tailmerging))
	       (if (= n 0) 1) (fact (- n 1)))
fact
cl-user(29): (compile 'fact)
;Mnot5: failed to merge a call to fact as non-self-tail-jump because comp:tail-call-non-self-merge-switch is returning nil
fact
nil
nil
cl-user(30): 
</pre>





<hr><h2 id="378"><a name="inlining-explain-2">3.5 Inlining explanations</a></h2>

<p id="379">
The compiler will now provide information on attempts to inline
functions in compiled code. This information will be supplied when the
<code>:explain :inlining</code> declaration is in effect during
compilation. The <code>:explain</code> declaration is described
in the section <a href="compiling.htm#decl-help-1">Help
with declarations</a>
</p>
<p id="380">
You can turn on inlining explanation with a declaration like
</p>
<pre id="381">
(declare (:explain :inlining t))
</pre>
<p id="382">
(See <a href="compiling.htm#decl-help-1">Help with
declarations: the :explain
declaration</a> in <a href="compiling.htm">compiling.htm</a> for a
complete description of the :explain declaration format.)
</p>
<h4 id="383">
Do not ask for inlining info with every compilation
</h4>
<p id="384">
You can make the declaration pervasive with <a href="../ansicl/dictentr/proclaim.htm"><b>proclaim</b></a> or <a href="../ansicl/dictentr/declaim.htm"><b>declaim</b></a> but be warned that inline
explanations produce a lot of output. It is recommended that you add
the declaration only to the functions where inlining is an issue.
</p>
<h4 id="385">
Do not ask for :boxing or :calls info when you get :inlining info
</h4>
<p id="386">
There are also <code>:explain :calls</code> and
<code>:explain :boxing</code> declarations. The information
provided by these calls is contained in the :inlining information so
we recommend not asking for :calls or :boxing info when you ask for
:inlining info.
</p>
<h4 id="387">
Only Allegro CL-supplied functions can be inlined, inline declaration
is ignored
</h4>
<p id="388">
To repeat what is said in <a href="compiling.htm">compiling.htm</a>: the
<code>inline</code> declaration is ignored by the compiler. At
appropriate settings of speed and safety, the compiler will inline
whatever it can. Only predefined system functions can be inlined. User
defined functions are never compiled inline. (The compiler will
observe the <code>notinline</code> declaration, however, so you can
suppress inlining of specific functions if you want.)
</p>



<p id="389">
The <code>(:explain :inlining)</code> declaration instructs the
compiler to report what it is doing when it tries to inline functions
as it compiles code. the information is reported in a series of short
messages. When calls are inlined successfully, no information is
reported. (The (<code>(:explain :calls)</code> also report on
whether calls are inlined but provides less specific information.
</p>
<p id="390">
See <a href="#i-labels-2">Section 2.3 :inlining (I) labels</a> for explanations of the
labels in the output in the examples in this section.
</p>
<p id="391">
Here we have a short example just to give the flavor of the declaration.
There are three aspects where we start wrong and then do right:
</p>
<ul>
<li id="392">
Speed must be greater than safety or declarations will not be trusted
(we start with both speed and safety 1).
</li>
<li id="393">
The variables must be declared to be single-floats or double-floats;
declaring them floats is not useful.
</li>
<li id="394">
If a floating point is returned, it will be boxed. Since the result is
stored in a vector, we can have the function return nil and avoid the
box (we don't in the first try).
</li>
<li id="395">
aref will only opencode simple-arrays. We start be simply declaring
<code>vec</code> to be an array.
</li>
</ul>
<p id="396">
The first function definition does the wrong thing in all four
cases. Here is the compilation:
</p>

<pre id="397">
cl-user(51): (defun foo (x y vec n)
               (declare (:explain (:inlining t)) 
                        (optimize (speed 1) (safety 1))
                        (float x y) (fixnum n)
                        (type (array single-float (*)) vec))
                (setf (aref vec n) (+ x y)))
foo
cl-user(51): (compile 'foo)
;Igen1:  Node: checking for implied unboxable type (floats, or
;Igen1:  machine-integer):
;Igen2:  Node: type is not trusted
;Igen3: Attempt to inline a boxed call to +_2op:
;Igen5:  Node: checking for notinline declaration for excl::+_2op: none
;Igen6:  Checking compiler:trust-declarations-switch for t (got nil) - failed
;Iadd2:  Node: must check for fixnum at runtime.
;Igen4: Inline attempt succeeded.
;Igen1:  Node: checking for implied unboxable type (floats, or
;Igen1:  machine-integer):
;Igen2:  Node: type is not trusted
;Igen3: Attempt to inline a boxed call to .inv-s-aref:
;Igen5:  Node: checking for notinline declaration for excl::.inv-s-aref: none
;Iref1:  Arg1: looking for (simple-array type 1)
;Iref1:  where type is one of (t character (unsigned-byte 4) fixnum
;Iref1:                        (unsigned-byte 8) (signed-byte 8)
;Iref1:                        (unsigned-byte 16) (signed-byte 16)
;Iref1:                        (signed-byte 32) single-float double-float bit)
;Iref1:  - failed
;Igen4: Inline attempt failed.
foo
nil
nil
cl-user(52): 
</pre>

<p id="398">
We are told several things: that <a href="variables/compiler/trust-declarations-switch.htm"><code>compiler:trust-declarations-switch</code></a> is nil
and declarations are not trusted; that we wanted a simple-array (of a
particular type) and did not find one; and that even though the call
to <b>+</b> did inline, the inlined code has various checks such as a
check for fixnums.
</p>
<p id="399">
Here is the revised code where speed is 3 and safety 1, we return
<code>nil</code>, and we declare x and y to be
single-floats and vec to be a simple-array:
</p>
<pre id="400">
cl-user(53): (defun foo (x y vec n)
               (declare (:explain (:inlining t)) 
                        (optimize (speed 3) (safety 1))
                        (single-float x y) (fixnum n)
                        (type (simple-array single-float (*)) vec))
                (setf (aref vec n) (+ x y))
                nil)
foo
cl-user(54): (compile 'foo)
;Igen1:  Node: checking for implied unboxable type (floats, or
;Igen1:  machine-integer):
;Igen2:  Node: type is unboxable as single-float
;Igen3: Attempt to inline an unboxed call to +_2op:
;Igen5:  Node: checking for notinline declaration for excl::+_2op: none
;Igen1:  Arg0: checking for implied unboxable type (floats, or
;Igen1:  machine-integer):
;Igen2:  Arg0: type is unboxable as single-float
;Igen1:  Arg1: checking for implied unboxable type (floats, or
;Igen1:  machine-integer):
;Igen2:  Arg1: type is unboxable as single-float
;Igen4: Inline attempt succeeded.
;Igen1:  Node: checking for implied unboxable type (floats, or
;Igen1:  machine-integer):
;Igen2:  Node: type is unboxable as single-float
;Igen3: Attempt to inline an unboxed call to .inv-aref_1d:
;Igen5:  Node: checking for notinline declaration for excl::.inv-aref_1d: none
;Iref1:  Arg1: looking for (simple-array type 1)
;Iref1:  where type is one of (single-float double-float (signed-byte 32)) -
;Iref1:  got (simple-array (single-float * *) (*))
;Igen6:  Checking compiler:trust-declarations-switch for t (got t) - succeeded
;Icon1:  Arg2: looking for fixnum constant - got nil
;Igen1:  Arg0: checking for implied unboxable type (floats, or
;Igen1:  machine-integer):
;Igen2:  Arg0: type is unboxable as single-float
;Igen4: Inline attempt succeeded.
;Igen4: Inline attempt succeeded.
foo
nil
nil
cl-user(55): 
</pre>

<p id="401">
Things seemed to go much better.
</p>

<p id="402">
Here is another example using the trusted-type declaration
(see <a href="compiling.htm#trusted-type-2">The
excl:trusted-type declaration</a> in
<a href="compiling.htm">compiling.htm</a>).
</p>

<pre id="403">
cl-user(1): (compile (defun foo (a y)
                       (declare (:explain :types :inlining)
                                (trusted-type (simple-array t (1 2)) a))
                       (aref a 0 y)))
; While compiling foo:
;Tgen1:Examined a call to aref with arguments:
;Targ2:  symeval a type (simple-array t (1 2))
;Tinf1:     variable-information: lexical: ((trusted-type (simple-array t #)))
;Targ3:  constant 0 type in fixnum range (integer 0 0)
;Targ2:  symeval y type t
;Tres1: which returns a value of type t
;Igen2:  Node: type is not trusted
;Igen3: Attempt to inline a boxed call to aref while not trusting declarations:
;Igen5:  Node: checking for notinline declaration for aref: none
;Iref1:  Arg0: looking for (simple-array type 2)
;Iref1:  where type is one of (t character (unsigned-byte 4) fixnum
;Iref1:                        (unsigned-byte 8) (signed-byte 8)
;Iref1:                        (unsigned-byte 16) (signed-byte 16)
;Iref1:                        (signed-byte 32) single-float double-float)
;Iref1:  - got (simple-array t (1 2)) [trusted-type]
;Iref2:  Arg0: looking for all dimensions declared for faster indexing - got
;Iref2:  (1 2)
;Iref4:  Checking for all array index args to be fixnum constants
;Iref4:    - failed
;Iref5:  Node: checking if there are any constant index values to avoid
;Iref5:  multiplication
;Icon1:  Arg1: looking for fixnum constant - got 0
;Icon1:  Arg2: looking for fixnum constant - got nil
;Iref7:  Node: found 1 useful index constant.
;Igen4: Inline attempt succeeded.
foo
nil
nil
cl-user(2): 
</pre>



</body><hr><p id="2"><small>Copyright (c) 1998-2017, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page was not revised from the 10.0 page.</small><br><small>Created 2017.2.15.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/compiler-explanations.htm">10.0 version</a></td></tr></table></html>