<html><head><meta name="viewport" content="width=device-width, initial-scale=1"> <meta http-equiv="content-type" content="text/html; charset=UTF-8"> <link rel="stylesheet" href="acldoc-styles.css" type="text/css"><title>Foreign Function Interface</title></head><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Minimally revised from 10.0.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/foreign-functions.htm">10.0 version</a></td></tr></table><h1 id="2">Foreign Function Interface</h1><p id="3">This document contains the following sections:</p><a href="#ff-intro-1">1.0 Foreign functions introduction</a><br>&nbsp;&nbsp;&nbsp;<a href="#swig-2">1.1 SWIG: Support for automatic generation of  foreign function definitions 1</a><br>&nbsp;&nbsp;&nbsp;<a href="#cbind-2">1.2 CBIND: Support for automatic generation of  foreign function definitions 2</a><br>&nbsp;&nbsp;&nbsp;<a href="#notation-2">1.3 Some notation</a><br>&nbsp;&nbsp;&nbsp;<a href="#loading-methods-2">1.4 Different versions of Allegro CL load foreign code differently</a><br>&nbsp;&nbsp;&nbsp;<a href="#package-info-2">1.5 Package information</a><br>&nbsp;&nbsp;&nbsp;<a href="#load-foreign-code-2">1.6 Load foreign code with cl:load</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#foreign-file-processing-3">1.6.1 Foreign File Processing</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#externals-resolved-3">1.6.2 Externals must be resolved when the .so/.sl/.dylib/.dll file is created</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#library-depending-3">1.6.3 One library file cannot depend on an already loaded library file</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#entry-points-updated-3">1.6.4 Entry points are updated automatically</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#duplicate-entry-points-3">1.6.5 Duplicate entry points are never a problem</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#modify-so-3">1.6.6 If you modify a so/sl/dylib/dll file that has been loaded, you must load the modified file!</a><br>&nbsp;&nbsp;&nbsp;<a href="#including-foreign-code-at-install-2">1.7 Foreign code cannot easily be included at installation time</a><br>&nbsp;&nbsp;&nbsp;<a href="#ff-and-multiprocessing-2">1.8 Foreign functions and multiprocessing</a><br>&nbsp;&nbsp;&nbsp;<a href="#creating-so-referring-to-acl-2">1.9 Creating Shared Objects that refer to Allegro CL Functionality</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#macosx-shared-3">1.9.1 Linking to Allegro CL shared library on Mac OS X</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#smaller-shared-3">1.9.2 Delaying linking the Allegro CL shared-library until runtime</a><br>&nbsp;&nbsp;&nbsp;<a href="#releasing-the-heap-2">1.10 Releasing the heap when calling foreign functions</a><br><a href="#43-unix-model-1">2.0 The 4.3.x UNIX model for foreign functions</a><br><a href="#interface-specification-1">3.0 The foreign function interface specification</a><br>&nbsp;&nbsp;&nbsp;<a href="#ff-interface-summary-2">3.1 Foreign function interface function summary</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#foreign-addresses-3">3.1.1 A note on foreign addresses</a><br>&nbsp;&nbsp;&nbsp;<a href="#def-foreign-call-2">3.2 def-foreign-call</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#def-foreign-call-syntax-3">3.2.1 def-foreign-call syntax</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#user-conv-3">3.2.2 The user-conversion function in a complex-type-spec</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#def-foreign-call-returning-3">3.2.3 def-foreign-call: the :returning keyword argument</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#def-foreign-call-example-3">3.2.4 def-foreign-call examples</a><br>&nbsp;&nbsp;&nbsp;<a href="#def-foreign-variable-2">3.3 def-foreign-variable</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#def-foreign-variable-syntax-3">3.3.1 def-foreign-variable syntax</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#def-foreign-variable-example-3">3.3.2 def-foreign-variable examples </a><br><a href="#arg-passing-conventions-1">4.0 Conventions for passing arguments</a><br>&nbsp;&nbsp;&nbsp;<a href="#modifying-arguments-2">4.1 Modifying arguments called by address: use arrays</a><br>&nbsp;&nbsp;&nbsp;<a href="#seeing-modifications-2">4.2 Lisp may not see a modification of an argument passed by address</a><br>&nbsp;&nbsp;&nbsp;<a href="#unexpected-change-to-argument-2">4.3 Lisp unexpectedly sees a change to an argument passed by address</a><br>&nbsp;&nbsp;&nbsp;<a href="#passing-integers-2">4.4 Passing fixnums, bignums, and integers</a><br>&nbsp;&nbsp;&nbsp;<a href="#array-to-pass-values-example-2">4.5 Another example using arrays to pass values</a><br><a href="#passing-strings-1">5.0 Passing strings between Lisp and C</a><br>&nbsp;&nbsp;&nbsp;<a href="#passing-strings-lisp-c-2">5.1 Passing strings from Lisp to C</a><br>&nbsp;&nbsp;&nbsp;<a href="#passing-array-of-strings-2">5.2 Special Case: Passing an array of strings from Lisp to C</a><br><a href="#structs-by-value-1">6.0 Passing structures by value</a><br><a href="#signal-handling-1">7.0 Handling signals in foreign code</a><br><a href="#io-in-foreign-code-1">8.0 Input/output in foreign code</a><br><a href="#lisp-from-c-1">9.0 Using Lisp functions and values from C</a><br>&nbsp;&nbsp;&nbsp;<a href="#accessing-lisp-values-2">9.1 Accessing Lisp values from C: lisp_value()</a><br>&nbsp;&nbsp;&nbsp;<a href="#calling-lisp-from-c-2">9.2 Calling Lisp functions from C: lisp_call_address() and lisp_call()</a><br>&nbsp;&nbsp;&nbsp;<a href="#calling-foreign-callables-2">9.3 Calling foreign callables from Lisp</a><br><a href="#ff-on-windows-1">Appendix A. Foreign Functions on Windows</a><br>&nbsp;&nbsp;&nbsp;<a href="#making-a-dll-2">Appendix A.1. Making a .dll</a><br>&nbsp;&nbsp;&nbsp;<a href="#making-fortran-dll-2">Appendix A.2. Making a Fortran .dll</a><br>&nbsp;&nbsp;&nbsp;<a href="#lisp-side-of-ff-2">Appendix A.3. The Lisp side of foreign functions</a><br>&nbsp;&nbsp;&nbsp;<a href="#dll-complete-example-2">Appendix A.4. A complete example</a><br><a href="#ff-on-solaris-1">Appendix B. Building shared libraries on Solaris</a><br><a href="#ff-on-linux-1">Appendix C. Building shared libraries on Linux</a><br><a href="#ff-on-freebsd-1">Appendix D. Building shared libraries on FreeBSD</a><br><a href="#ff-on-macosx-1">Appendix E. Building shared libraries on Mac OS X</a><br><p id="4">The description of Foreign Types is not in this document. It can be
found in <a href="ftype.htm">ftype.htm</a>.</p><hr><hr><h2 id="5"><a name="ff-intro-1">1.0 Foreign functions introduction</a></h2>

<p id="6">The foreign-function interface allows one to link compiled foreign
code dynamically into a running Lisp. <i>Foreign code</i> is defined
to be code not written in Lisp. For example, code written in C or
Fortran is foreign code. The foreign-function interface allows users
to load compiled code written in a foreign programming language into a
running Lisp, execute it from within Lisp, call Lisp functions from
within the foreign code, return to Lisp and pass data back and forth
between Lisp and the foreign code. </p>

<p id="7">This mechanism is very powerful, as programs need not be recoded
into Lisp to use them.  Another advantage arises during program
development. For example, a large graphics library can be linked into
Lisp and all the functions will be accessible interactively. This
enables rapid prototyping of systems that use the library functions,
since the powerful Lisp debugging and development environment is now
available.</p>

<p id="8">
We use the word link because all foreign code should be in a shared
object (typically <em>.so</em> or <em>.sl</em> or <em>.dylib</em> on
Unix) or dynamic library (<em>.dll</em> on Windows) file which is
mapped into a running Lisp process. The function that causes this
linking is <a href="../ansicl/dictentr/load.htm"><b>load</b></a>, which has
been extended to accept and do the right thing with
.so/.sl/.dylib/.dll files. Because <a href="../ansicl/dictentr/load.htm"><b>load</b></a> is used, we sometimes speak of foreign code
being <i>loaded</i> into Lisp. Please understand that foreign code is
not truly made part of the image. See
<a href="loading.htm#using-load-1">Using the load
function</a> in <a href="loading.htm">loading.htm</a> for details of
the Allegro CL implementation to <a href="../ansicl/dictentr/load.htm"><b>load</b></a>.
</p>

<hr><h2 id="9"><a name="swig-2">1.1 SWIG: Support for automatic generation of  foreign function definitions 1</a></h2>

<p id="10">
SWIG is a software development tool that reads C/C++ header files and
generates the wrapper code needed to make C and C++ code accessible
from other languages. See <a href="http://www.swig.org">http://www.swig.org</a>. An interface for
Allegro CL has been added to SWIG. See <a href="http://franz.com/support/tech_corner/swig111605.lhtml">http://franz.com/support/tech_corner/swig111605.lhtml</a>
for specific information on the interface to Allegro CL and
information on downloading the software. (The SWIG software is not
included with the distribution because it is regularly updated. Users
should always get the latest update.)
</p>



<hr><h2 id="11"><a name="cbind-2">1.2 CBIND: Support for automatic generation of  foreign function definitions 2</a></h2>

<p id="12">
The <b>cbind</b> facility provides tools for automatically generating
Lisp code for calling foreign functions using information obtained by
scanning C header files. This facility is only available for Solaris
and Windows. Look at <a href="cbind-intro.htm">cbind-intro.htm</a>. That file
contains pointers to more documentation.
</p>



<hr><h2 id="13"><a name="notation-2">1.3 Some notation</a></h2>

<p id="14">In this chapter, we discuss C or FORTRAN routines and the Lisp
functions that call them. These often have the same names. In order to
distinguish them, names ending with () are foreign routines and names
without () are Lisp functions. Thus we might say:</p>

<p id="15">The foreign function <b>bar()</b> is loaded into Lisp. We use
<b>def-foreign-call</b> to define the Lisp function <b>bar</b> which
calls <b>bar()</b>.</p>



<hr><h2 id="16"><a name="loading-methods-2">1.4 Different versions of Allegro CL load foreign code differently</a></h2>

<p id="17">
The differences are not that significant since all platforms use
some form of dynamic linking of shared objects. However, the internal
mechanisms are different and the differences may sometimes be
important. The type of loading is identified by a feature on the
<a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> list. The
following table lists the relevant features:
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="95%">
  <tr>
    <td WIDTH="245" VALIGN="TOP" COLSPAN="2"><b>Feature</b></td>
    <td WIDTH="357" VALIGN="TOP"><b>Meaning</b></td>
  </tr>
  <tr>
    <td WIDTH="253" VALIGN="TOP"><code>:dynload</code></td>
    <td WIDTH="349" VALIGN="TOP" COLSPAN="2">Foreign code is dynamically linked.</td>
  </tr>
  <tr>
    <td WIDTH="253" VALIGN="TOP"><code>:dlfcn</code></td>
    <td WIDTH="349" VALIGN="TOP" COLSPAN="2">Loading is done using 
    <strong>dlopen()</strong>. <code>:dynload</code> will be 
    present if this feature is present.
    The type of loadable files is <i>.so</i>.</td>
  </tr>
  <tr>
    <td WIDTH="253" VALIGN="TOP"><code>:dlhp</code></td>
    <td WIDTH="349" VALIGN="TOP" COLSPAN="2">Loading is done using <strong>shl_load</strong>. <code>:dynload</code> will be present if this feature is present. HP
    machines only. The type of loadable files is <i>.sl</i>.</td>
  </tr>
  <tr>
    <td WIDTH="253" VALIGN="TOP"><code>:dlwin</code></td>
    <td WIDTH="349" VALIGN="TOP" COLSPAN="2">Loading is done using <strong>LoadLibrary</strong>. <code>:dynload</code> will be present if this feature is present.
    Windows only. The type of loadable files is <i>.dll</i>.</td>
  </tr>
  <tr>
    <td WIDTH="253" VALIGN="TOP"><code>:dlmac</code></td>
    <td WIDTH="349" VALIGN="TOP" COLSPAN="2">Loading
    on Mac OS X ports using the system dynamic loader NSLoadModule. 
    <code>:dynload</code> will be present if this feature is present.
    Mac OS X only. The type of loadable files is <i>.dylib</i>.</td>
  </tr>
  <tr>
    <td WIDTH="253" VALIGN="TOP"><code>:dlld</code></td>
    <td WIDTH="349" VALIGN="TOP" COLSPAN="2">Foreign code is directly loaded into image. <code>:dynload</code> will not be present. No platforms
    currently use this method of foreign loading so none have this feature.</td>
  </tr>
</table>

<p id="18">The following appendices describe how to create files suitable for
loading on various platforms. </p>

<ul>
<li id="19"><a href="#ff-on-windows-1">Appendix A Foreign Functions on Windows</a></li>
<li id="20"><a href="#making-a-dll-2">Appendix A.1 Making a .dll</a></li>
<li id="21"><a href="#making-fortran-dll-2">Appendix A.2 Making a Fortran .dll</a></li>
<li id="22"><a href="#lisp-side-of-ff-2">Appendix A.3 The Lisp side of foreign functions</a></li>
<li id="23"><a href="#dll-complete-example-2">Appendix A.4 A complete example</a></li>
<li id="24"><a href="#ff-on-solaris-1">Appendix B Building shared libraries on Solaris</a></li>

<li id="25"><a href="#ff-on-linux-1">Appendix C Building shared libraries on Linux</a></li>
<li id="26"><a href="#ff-on-freebsd-1">Appendix D Building shared libraries on FreeBSD</a></li>
<li id="27"><a href="#ff-on-macosx-1">Appendix E Building shared libraries on Mac OS X</a></li>
</ul>



<hr><h2 id="28"><a name="package-info-2">1.5 Package information</a></h2>

<p id="29">The foreign-function interface in Lisp is in the package
<code>foreign-functions</code>, nicknamed
<code>ff</code>. Users must either use the qualifier
<code>ff:</code> on these symbols or evaluate</p>

<pre id="30">
(use-package :ff) 
</pre>

<p id="31">before using the interface. </p>

<p id="32">The code for the foreign-function interface may not be contained in
the basic Allegro CL image. It is loaded only when needed. Executing
certain of the interface functions will cause the correct module to be
loaded (<a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>
for instance), but we recommend that you ensure that the code is
loaded by evaluating the following form before using the
foreign-functions interface: </p>

<pre id="33">
(require :foreign) 
</pre>

<p id="34">This will cause the <i>foreign.fasl</i> module to be loaded from
the Lisp library. The form should be included in any source file using
functions in the interface. (It is not an error to call require when a
module is already loaded.) </p>

<p id="35">Note that the foreign-function interface was designed for the C and
Fortran compilers on the system at the time of the release of this
version of Allegro CL. New versions of the C or Fortran compilers from
the hardware manufacturers may, for purposes of using the
foreign-function interface, be incompatible with the version current
when the interface was written. In that case, it is possible that
already written and compiled Lisp code may cease to work, and that,
for a time, the interface may fail altogether. We will maintain the
foreign-function interface, and make it compatible with each new
release of the system compilers. We cannot guarantee, however, that
already compiled code will continue to work in the presence of changes
in the C or Fortran compilers. </p>



<hr><h2 id="36"><a name="load-foreign-code-2">1.6 Load foreign code with cl:load</a></h2>

<p id="37">
Foreign code in a .so/.sl/.dylib/.dll file is loaded into Lisp with
<a href="../ansicl/dictentr/load.htm"><b>load</b></a> (or the top-level command
<a href="tpl-commands/ld.htm"><b>:ld</b></a>). <a href="../ansicl/dictentr/load.htm"><b>load</b></a> is, of course, also used to load Lisp
source and compiled (<em>fasl</em>) files. Since <a href="../ansicl/dictentr/load.htm"><b>load</b></a> may just be presented with a filename as a
single argument, it should be able to determine based on that argument
alone whether Lisp code or a foreign library is being loaded.
Sometimes other arguments are provided. In that case, those arguments
may indicate the type of file being loaded.
</p>
<p id="38">
As described below, <a href="../ansicl/dictentr/load.htm"><b>load</b></a> will
consider the file type to determine whether the file is a foreign
file. <a href="../ansicl/dictentr/load.htm"><b>load</b></a> also has a
non-standard keyword argument <i>foreign</i> which, when
true, tells the system the file is a foreign file. (When
<i>foreign</i> is <code>nil</code>, the type
determines whether the file will be treated as a foreign file or not.)
See <a href="loading.htm#using-load-1">Using the load
function</a> in <a href="loading.htm">loading.htm</a> for details of
the Allegro CL implementation to <a href="../ansicl/dictentr/load.htm"><b>load</b></a>.
</p>

<p id="39">
Note that the Operating System must know where to find foreign files,
either those needed to resolve externals in a file or the file itself
if it is specified to load with no directory information.
</p>
<p id="40">
The specifics on the various Operating Systems differ, but the
principle is usually the same: some single environment variable or
group of variables is set by the user to tell the OS where to look for
library files. On most UNIX and UNIX-like (i.e. LINUX and Mac OS X)
operating systems the variable is LD_LIBRARY_PATH. On HP-UX, it is
SHLIB_PATH. Note that once Lisp has started, changes to the value of
environment variables will likely not be seen by the running Lisp.
</p>


<p id="41">
On Windows, the following locations are searched:
</p>

<ol>
<li id="42">
The directory from which the application loaded.
</li>
<li id="43">
The current directory.
</li>
<li id="44">
On Windows 98/Me: The Windows system directory and on Windows
NT/2000: The 32-bit Windows system directory.
</li>
<li id="45">
Windows
NT/2000: The 16-bit Windows system directory.
</li>
<li id="46">The Windows
directory.
</li>
<li id="47">The directories that are listed in the PATH
environment variable.
</li>
</ol>

<p id="48">
An additional keyword argument is provided to <a href="../ansicl/dictentr/load.htm"><b>load</b></a>, <em>unreferenced-library-names</em>.  If
specified, it should be a list of entry points (strings). The system
will check if these entry points exist and signal an error if they do
not.
</p>

<p id="49">Here is how <a href="../ansicl/dictentr/load.htm"><b>load</b></a> works. 
</p>

<ol>
<li id="50">
It determines the argument type (whether a stream or a file).
</li>
<li id="51">
If the argument is a <code><em>stream</em></code>, load from it (as a
Lisp or <em>fasl</em> file) and return. (You should not open a stream
to a Foreign library or shared object file and pass that stream to
<a href="../ansicl/dictentr/load.htm"><b>load</b></a>.)
</li>
<li id="52">
The argument filename is converted to a pathname, called the
<em>argument pathname</em>. The argument pathname is now put through
search list processing, yielding the searched pathname. If the search
was successful, the argument pathname is set to the <em>searched
pathname</em>. (If the search is unsuccessful, <a href="../ansicl/dictentr/load.htm"><b>load</b></a> will signal an error.)
</li>
<li id="53">
If the <i>foreign</i> keyword argument to <a href="../ansicl/dictentr/load.htm"><b>load</b></a> is specified true, foreign load
processing is done, as described <a href="#foreign-file-processing-3">below</a>.
</li>
<li id="54">
if <i>foreign</i> is <code>nil</code> or
unspecified, then the file type is considered. If the searched
pathname has a type listed in <a href="variables/excl/s_load-foreign-types_s.htm"><code>*load-foreign-types*</code></a> (the test is case
insensitive on Windows), foreign load processing is done, as described
<a href="#foreign-file-processing-3">below</a>.
</li>
<li id="55">
If the searched pathname does not have a type listed in <a href="variables/excl/s_load-foreign-types_s.htm"><code>*load-foreign-types*</code></a> the file
is assumed to be a Lisp source or compiled file and it is loaded as a
Lisp file.
</li>
</ol>

<hr><h2 id="56"><a name="foreign-file-processing-3">1.6.1 Foreign File Processing</a></h2>

<p id="57">Foreign file processing behavior can differ slightly, depending on
your version of Lisp.</p>

<p id="58">Versions of Lisp with <code>:dlfcn</code> on <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> (e.g., SunOS 5.x and later):
</p>


<ol>
  <li id="59">If <code>:unreferenced-lib-names</code> was given, then make sure all entry points are
    defined and return. </li>
  <li id="60">If the searched pathname is <code>nil</code>, then signal an error, since <code>dlopen()</code>
    will not find the pathname. </li>
  <li id="61">Use <strong><code>dlopen()</code></strong> to map the searched pathname into the address
    space and return. </li>
</ol>

<p id="62">
Versions of Lisp with <code>:dlwin</code> on <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> (e.g. Windows):
</p>

<ol>
  <li id="63">If the searched pathname is <code>nil</code>, then signal an error, since <code><strong>GetModuleHandle()</strong></code>
    will not find the pathname. </li>
  <li id="64">Use <code><strong>GetModuleHandle()</strong></code> to map the searched pathname into
    the address space and return. </li>
</ol>

<p id="65">
Versions of Lisp with <code>:dlhp</code> on <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> (e.g., HP-UX 11.0):
</p>

<ol>
  <li id="66">If <code>:unreferenced-lib-names</code> was given, then make sure all entry points are
    defined and return. </li>
  <li id="67">If the searched pathname is <code>nil</code> and there is a directory or host component
    to this pathname, then signal an error, since <strong><code>shl_load()</code></strong>
    will not find the pathname. </li>
  <li id="68">Use <strong><code>shl_load</code>()</strong> to map the searched pathname into the
    address space and return. </li>
</ol>

<p id="69">Versions of Lisp with <code>:dlmac</code> on <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> (e.g., Mac OS X machines):
</p>


<ol>
  <li id="70">If <code>:unreferenced-lib-names</code> was given, then make 
    sure all entry points are
    defined and return. </li>
  <li id="71">If the searched pathname is <code>nil</code>, 
    then signal an error, since <code>NSLoadModule</code>
    will not find the pathname. </li>
  <li id="72">Use <strong><code>NSLoadModule</code></strong> to map the searched 
    pathname into the address
    space and return. </li>
</ol>



<hr><h2 id="73"><a name="externals-resolved-3">1.6.2 Externals must be resolved when the .so/.sl/.dylib/.dll file is created</a></h2>

<p id="74">Suppose one library file contains a reference to a function defined
in another file.  For example, suppose we are on a Solaris machine and
<em>t_double.so</em>, contains a call to <strong>foo()</strong> which
is defined in <em>foo.so</em>. When we try to load
<em>t_double.so</em>, we get the following error (on Solaris, see
below for behavior on other platforms):</p>

<pre id="75">
USER(24): :ld t_double.so
; Foreign loading /net/rubix/usr/tech/dm/acl/t_double.so.
Error: loading library "/net/rubix/usr/tech/dm/acl/t_double.so" 
       caused the following error:
 
  ld.so.1: /net/sole/scm3/temp-images/lisp: 
   relocation error: symbol not found: foo: referenced in 
   /net/rubix/usr/tech/dm/acl/t_double.so
</pre>

<p id="76">
Below, we point out that loading <em>foo.so</em> (before or after the
attempt to load <em>t_double.so</em>) will not resolve the unsatisfied
external. The point, which we emphasize here, is any unsatisfied
external must be resolved when the so/sl/.dylib/dll file is created
(e.g. by using -l[libname] arguments passed to ld on Solaris). Even
though the error is signaled when Lisp attempts to load the .so file,
the problem cannot be resolved within Lisp. A new .so file, created
with the correct arguments passed to ld, must be created and that new
.so file must be loaded into Lisp.
</p>

<p id="77">
This problem is not as bad as it might be. Many standard shared
libraries are linked automatically and calls to routines in them will
be resolved when the .so file is loaded into Lisp. The important
point, to state it again, is if you do get an unsatisfied external
error, you must recreate the .so file and then load the modified .so
file into Lisp. The example <a href="#library-depending-3">below</a> shows how a .so file
might be recreated.
</p>

<p id="78">
Here is the behavior in this case on various platforms. On the
following platforms, the load will fail with an error message that
lists an unresolved external symbol:
</p>

<ul>
  <li id="79"><strong>Solaris</strong>: Use the command <strong>ldd <em>your_library.so</em></strong>
    in a shell to generate a list of library dependencies.</li>
  <li id="80"><strong>HP-UX</strong>: Use the command <strong>chatr <em>your_library.sl</em></strong>
    in a shell to generate a list of library dependencies.</li>
</ul>

<p id="81">
On the following platforms, the load will fail without an adequate
explanation.  Unresolved externals is always a possibility for
failure.
</p>

<ul>
  <li id="82"><strong>Dec Unix</strong>: Use the command <strong>odump -Dl <em>your_library.so</em></strong>
    in a shell to generate a list of  library dependencies.</li>
  <li id="83"><strong>AIX</strong>: The message may say "No such file or directory". Use the
    command <strong>dump -H <em>your_library.so</em></strong> in a shell to generate a list of
    library dependencies.</li>
  <li id="84"><strong>Windows NT/2000</strong>: You can use the NT 
    application <strong>Quickview</strong>
    to examine which DLL's the DLL you are trying to load depends on. </li>
  <li id="85"><strong>Windows 98/Me</strong>: We neither provide nor point
    to tools to give you further
    information. We are aware of that such tools might be available on the 
    Web (one user suggested looking at the information on the 
    http://www.dependencywalker.com/ site). But if you did not build the DLL, 
    it might be best to contact the DLL's author for further
    information.</li>
</ul>



<hr><h2 id="86"><a name="library-depending-3">1.6.3 One library file cannot depend on an already loaded library file</a></h2>

<p id="87">Each file must be complete in itself: all necessary routines must either be defined in
the file or must be in a library specified when the file is created. On Windows, Dec Unix,
and AIX, by default, the linker prevents building a shared library with unresolved
external symbols. </p>

<p id="88">Consider the example on a Solaris machine: <strong>t_double()</strong> (defined in <em>t_double.so</em>)
calls <strong>foo()</strong> (defined in <em>foo.so</em>). Even if you have already loaded
<em>foo.so</em>, trying to load <em>t_double.so </em>will fail, as follows:</p>

<pre id="89">
USER(23): :ld foo.so
; Foreign loading /net/rubix/usr/tech/dm/acl/foo.so.
USER(24): :ld t_double.so
; Foreign loading /net/rubix/usr/tech/dm/acl/t_double.so.
   Error: loading library "/net/rubix/usr/tech/dm/acl/t_double.so"
          caused the following error:
 
ld.so.1: /net/sole/scm3/temp-images/lisp: 
  relocation error: symbol not found: foo: referenced in 
  /net/rubix/usr/tech/dm/acl/t_double.so
 
Restart actions (select using :continue):
0: retry the load of t_double.so
[1] USER(25): 
</pre>

<p id="90">
There are two solutions to this problem. You can combine all necessary
files (t_double.so and foo.so in our case) into a single file. On
Solaris, this could be done with the following command starting with
the .o files used to make the .so files:
</p>

<pre id="91">
% ld -G -o combine.so foo.o t_double.o
</pre>

<p id="92">
Alternatively, you can specify the file holding the needed routines
(<em>foo.so</em> in our example) as a library for the file needing
them (<em>t_double.so</em> in our example).  On Solaris again, a
command like:</p>

<pre id="93">
% ld -G -o t_double.so t_double.o -R /net/rubix/usr/dm/acl -lfoo
</pre>



<hr><h2 id="94"><a name="entry-points-updated-3">1.6.4 Entry points are updated automatically</a></h2>

<p id="95">Suppose you load a library file which defines
<strong>bar()</strong> and then use <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> to define
<strong>bar</strong>, which calls <strong>bar()</strong>. Then you
load another .so file which defines <strong>bar()</strong>.  What
happens?</p>

<p id="96">Lisp will automatically modify <strong>bar</strong> so that 
it calls the
<strong>bar()</strong> defined in the newly loaded file (and it prints
a warning that it is doing so).</p>

<p id="97">
Let us make this clear with an example on a Solaris
machine. Consider the two files <em>bar1.c</em> and
<em>bar2.c</em>:
</p>

<pre id="98">
/* bar1.c */
void bar()
{
    printf("This is BAR 11111 in bar1.c!\n");
    fflush(stdout);
}
 
/* bar2.c */
void bar()
{
    printf("This is BAR 22222 in bar2.c!\n");
    fflush(stdout);
}
</pre>

<p id="99">
<em>bar1.so</em> defines <strong>bar()</strong> and <em>bar2.so</em>
also defines <strong>bar()</strong>.  We first load <em>bar1.so</em>
and use <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> to define
<strong>bar</strong>, and then load <em>bar2.so</em>.
</p>

<pre id="100">
USER(37): :ld bar1.so
; Foreign loading /net/rubix/usr/tech/dm/acl/bar1.so.
USER(38): (ff:def-foreign-call bar nil :returning :void :strings-convert nil)
BAR
USER(39): (bar)
This is BAR 11111 in bar1.c!
NIL
USER(40): :ld bar2.so
; Foreign loading /net/rubix/usr/tech/dm/acl/bar2.so.
Warning: definition of "bar"
         moved from /net/rubix/usr/tech/dm/acl/bar1.so
         to /net/rubix/usr/tech/dm/acl/bar2.so.
USER(41): (bar)
This is BAR 22222 in bar2.c!
NIL
USER(43): 
</pre>



<hr><h2 id="101"><a name="duplicate-entry-points-3">1.6.5 Duplicate entry points are never a problem</a></h2>

<p id="102">Since one library file cannot depend on another unless specified
when it was built, there is a never a problem with duplicate entry
points. It is important, however, to be sure that you know which
foreign routine is being called. </p>



<hr><h2 id="103"><a name="modify-so-3">1.6.6 If you modify a so/sl/dylib/dll file that has been loaded, you must load the modified file!</a></h2>

<p id="104">Failure to do so may cause Lisp to fail unrecoverably.</p>

<p id="105">
Suppose on Solaris you have <strong>bar()</strong> defined in
<em>bar1.so</em> and you load <em>bar1.so</em> into Lisp. You also
define the function <strong>bar</strong> with <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>. Then, you decide
to modify <em>bar1.c</em> and <em>bar1.so</em>. Once the new
<em>bar1.so</em> has been created, you must load it into Lisp before
calling bar.  Otherwise, Lisp may fail.
</p>

<p id="106">The problem is that the function <strong>bar</strong> knows it
should look for the definition of <strong>bar()</strong> in
<em>bar1.so</em> and it knows where to look in that file. If
<em>bar1.so</em> is modified in any way, the place where Lisp will
look for the definition of <strong>bar()</strong> is likely
wrong. Lisp, however, does not know that and will look at that
location anyway, taking whatever it finds to be valid code. The result
can be disastrous, since typically Lisp hangs unrecoverably. In that
case, Lisp may have to be killed from a shell and restarted.
</p>





<hr><h2 id="107"><a name="including-foreign-code-at-install-2">1.7 Foreign code cannot easily be included at installation time</a></h2>

<p id="108">In earlier versions of Allegro CL on Unix, it was possible and
relatively easy to build an executable image that included foreign
code. Because of changes in the way images are built and the fact that
the executable and image files are different (which is a new feature
on Unix platforms), it is no longer easy to build foreign code into an
image. The only way is to write a <strong>main()</strong> which does
the necessary linking. See <a href="main.htm">main.htm</a>.</p>



<hr><h2 id="109"><a name="ff-and-multiprocessing-2">1.8 Foreign functions and multiprocessing</a></h2>

<p id="110">
There are two models of multiprocessing used by Allegro CL (as
described in <a href="multiprocessing.htm">multiprocessing.htm</a>): the
<strong>:os-threads</strong> model and the non
<strong>:os-threads</strong> model. (<strong>:os-threads</strong>
appears on the <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> list of implementations that use
it). 
</p>

<p id="111">
In the non <strong>:os-threads</strong> model, foreign code is not
interruptable and Lisp code never runs until foreign code returned
control to Lisp, typically by completing but sometimes when the
foreign code called back to Lisp. In the <strong>:os-threads</strong>
model, Lisp code on one process may run while foreign code in another
process may be waiting or be interrupted. This means that certain
implicit features of foreign code may no longer hold. Among them is
the most significant:
</p>

<p id="112">
<b>Lisp pointers passed to foreign code are not guaranteed to be valid by
default</b>. In earlier releases, because Lisp code never ran while
foreign code was running, a Lisp pointer passed to foreign code was
guaranteed to be valid until the foreign code completed or called back
to Lisp. In the <strong>:os-threads</strong> model, because Lisp code
and foreign code can run in different OS processes, Lisp code may be
run concurrently with foreign code. A garbage collection may move Lisp
objects rendering the pointer in the foreign code invalid. We
recommend storing all values used by both Lisp and foreign code in
foreign (not garbage-collected) space or dynamically allocated on the
stack. It is also possible to block Lisp code from running until
foreign code completes.
</p>

<p id="113">
See the <b><i>release-heap</i></b> keyword argument to
<a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>. It prevents or
permits other threads from running along with the foreign code.
</p>

<h3 id="114">A note on calling into Lisp from threads started by foreign code</h3>

<p id="115">
Note that in all implementations of Allegro CL it is possible for a
foreign function called from Lisp to explicitly start computation in
additional threads, as supported by the OS (by having foreign code
make the appropriate system calls to start the threads). One could
imagine any of these new threads using the foreign function interface
to invoke a Lisp function defined as foreign-callable (see <a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a>). In an
Allegro CL with the non <strong>:os-threads</strong> model of
multiprocessing, doing this is almost certain to have disastrous
consequences.  It is wholly unsupported but there is no protection in
the foreign function interface to prevent it from happening.  The only
legitimate calls to a foreign-callable function will occur in the
Lisp's own thread of control, as call-backs from foreign code that was
itself called from lisp.
<p id="116">
</p>
In an <strong>:os-threads</strong> Allegro CL, however, it is
legitimate for a thread started outside Lisp to call into Lisp via any
foreign-callable function.  Some extra work has to be done to create a
Lisp process to represent that thread within the lisp world. That
extra work is performed by a "customs agent" process, but this is done
automatically when the scheduler is started with <a href="operators/mp/start-scheduler.htm"><b>start-scheduler</b></a>.
</p>




<hr><h2 id="117"><a name="creating-so-referring-to-acl-2">1.9 Creating Shared Objects that refer to Allegro CL Functionality</a></h2>

<p id="118">
When creating foreign code to load dynamically into Lisp, it is
sometimes necessary to refer to variables within Allegro CL's runtime
such as nilval or UnboundValue, or else to call a function directly
from C such as <strong>lisp_call_address()</strong>. In cases like
these it is necessary to link in the Allegro CL shared-library (either
.<em>dll</em>, .<em>so</em>, or .<em>sl</em>, depending on the
architecture) with the shared-library that is being built. The actual
name of the Allegro CL shared-library is available using the function
<a href="operators/excl/get-shared-library-name.htm"><b>get-shared-library-name</b></a> and can be
added to the link line to resolve symbols within it that are
referenced in the foreign code. The situation on Mac OS X is different.
See <a href="#macosx-shared-3">Section 1.9.1 Linking to Allegro CL shared library on Mac OS X</a>.
</p>
<p id="119">
It is also possible to avoid delay linking the library until runtime.
The advantage is that the library location can easily be determined at
runtime, while at shared-library creation time finding the Allegro CL
shared-library in a robust fashion (without worrying about
LD_LIBRARY_PATH or equivalent and without hardwiring the location) can
be difficult. See <a href="#smaller-shared-3">Section 1.9.2 Delaying linking the Allegro CL shared-library until runtime</a> for
details.
</p>

<p id="120">For example, on a Sparc,</p>

<pre id="121">
% cat foo.c

#include "lisp.h"

LispVal
get_nil ()
{
     return nilval;
}

% cc -c -K pic -DAcl32Bit -I[ipath] foo.c
</pre>

<p id="122">
<em>[ipath]</em> is the location of <em>lisp.h</em> (usually<em>
[Allegro directory]/misc/</em>). Note that on platforms that
support 64 bit Lisps (HP's and HP Alphas, Sparcs, Mac OS X, etc.), the
flag <code>-DAcl64Bit</code> must be used instead of
<code>-DAcl32Bit</code> when compiling for the 64-bit Lisp.
</p>
<p id="123">
Now, before linking, we need to find out
where the Allegro CL shared-library is, so in the Lisp (for example,
your own name and path might be different):
</p>

<pre id="124">
user(4): (get-shared-library-name)
"libacl80.so"
user(5): (translate-logical-pathname "sys:")
#p"/usr/acl80/"
user(6):
</pre>

<p id="125">
Then back in the shell and build the shared library (this example is
from a Solaris machine):
</p>

<pre id="126">
ld -G -o foo.so foo.o /usr/acl80/libacl80.so
</pre>

<p id="127">
Note that other libraries, including system libraries, might need
to be linked in order to complete the <strong>ld</strong>. Then, back
in the Lisp, the load can be done:
</p>

<pre id="128">
user(6): :ld ./foo.so
; Foreign loading ./foo.so
user(7): (ff:def-foreign-call get_nil () :returning :lisp)
get_nil
user(8): (get_nil)
nil
user(9): 
</pre>

<hr><h2 id="129"><a name="macosx-shared-3">1.9.1 Linking to Allegro CL shared library on Mac OS X</a></h2>

<p id="130">
Allegro CL does the NSLoadModule of libacl8*.dylib (the Allegro CL
shared library) with the options NSLINKMODULE_OPTION_BINDNOW |
NSLINKMODULE_OPTION_RETURN_ON_ERROR. The first of these options is
just like the RTLD_NOW option of dlopen, and the second causes a zero
return-value from a failed call to NSLinkModule instead of calling
some error handlers (whose default action would be to kill the
program). Missing from this set of options is the
NSLINKMODULE_OPTION_PRIVATE, the lack of which means that all symbols
that are exported from the module are made global and thus accessible
in the running program.  Unfortunately this means that there can be no
multiply defined externals in either the program or the files it
loads.
</p>
<p id="131">
The file <i>/usr/lib/bundle1.o</i> that gets linked into
a bundle file has an entry point called "dyld_stub_binding_helper".
Whenever any unresolved symbol is used in the loaded bundle file, this
helper calls on the dynamic loaded (dyld) to find the symbol in the
running image. Thus the entry points are looked up in a truly dynamic
manner, and linking against the Allegro CL library is unnecessary.
</p>
<p id="132">
But it is also impossible to link against the Allegro CL
shared-library, because being a bundle type object, it is
self-contained, and the operating system doesn't allow relinking
against this kind of shared library.
</p>
<p id="133">
Thus the shared-libraries that can be dynamically
loaded into a program can be thought of as
separate entities which communicate via
the dynamic loader.
</p>



<hr><h2 id="134"><a name="smaller-shared-3">1.9.2 Delaying linking the Allegro CL shared-library until runtime</a></h2>

<p id="135">
When your foreign function needs to call into Lisp (for example, to
call <b>lisp_call-address</b> or <b>lisp_value</b>), it may be
complicated when the shared library created from your foreign function
is created to link to the Allegro CL shared-library (aclxxx.dll or
libaclxx.{sl,so,dylib}). It is possible to pass the Allegro CL
shared-library handle to another shared-library so that it doesn't
have to explicitly call entry-points within the Allegro CL
shared-library. As a result, you need not specify the Allegro CL
shared-library location when your shared library is created.
</p>
<p id="136">
The runtime information is provided by the functions <a href="operators/excl/get-shared-library-handle.htm"><b>get-shared-library-handle</b></a> and <a href="operators/excl/get-executable-handle.htm"><b>get-executable-handle</b></a>.
</p>
<p id="137">
Consider the following example, from a Solaris. A shared-library is
created to call <b>lisp_call_address</b> without referring to that
function in the link phase (<b>lisp_call_address</b>' address is
looked up at runtime). Instead, information about the location is
determined at runtime and passed to the foreign functions using the
<code>init_mylib</code> function (see the <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> form in the
comments at the end of the example).
</p>

<pre id="138">
#ifdef HP_CC
extern &quot;C&quot; {
#if !defined(Acl64Bit)
#define hp32 1
#endif
#endif

#ifdef WINDOWS
# define Dllexport _declspec(dllexport)
#else
# define Dllexport
#endif

#define CALLNAME &quot;lisp_call_address&quot;

#ifdef WINDOWS
void *
find_ff_symbol(void* handle, char *name)
{
    return GetProcAddress(handle, name);
}
#endif

#if defined(__APPLE__) &amp;&amp; defined(__ppc__)
#include &lt;mach-o/dyld.h&gt;

#undef CALLNAME
#define CALLNAME &quot;_lisp_call_address&quot;

void *
find_ff_symbol(void *handle, char *name)
{
    NSSymbol sym;
    sym = NSLookupSymbolInModule(handle, name);
    if (sym != NULL) {
	return NSAddressOfSymbol(sym);
    }
    return NULL;
}

#endif

#if defined(hp32)
#include &lt;dl.h&gt;
void *
find_ff_symbol(void *handle, char *symbol)
{
    int value;
    shl_t handlecopy = (shl_t) handle;
  
    if (shl_findsym(&amp;handlecopy, symbol, 0, &amp;value) == 0) {
	return (void *)value;
    } else {
	return (void *)0;
    }
}

#endif

#if !defined(WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(hp32)
#include &lt;dlfcn.h&gt;

void *
find_ff_symbol(void *handle, char *name)
{
    return dlsym(handle,name);
}
#endif
    
void *(*get_lisp_call_address)(int);

int Dllexport
init_mylib(void *handle)
{
    get_lisp_call_address = (void *(*)(int))find_ff_symbol(handle, CALLNAME);
    if(get_lisp_call_address) {
	return 1;
    }
    return 0;
}

/*
 * In lisp, initialize by defining and calling init_mylib as a foreign
 * function:
 *
 * (ff:def-foreign-call init_mylib ((handle :foreign-address))
 *   :returning :int)
 * (init_mylib (excl:get-shared-library-handle))
 *
 *
 * After init, usage of get_lisp_call_address() in inline C code is
 * the same as lisp_call_address():
 *
 *
 * ...
 *
 * int (*lispfunc)(...) = (int(*)())get_lisp_call_address(index);
 *
 * lispfunc(...);
 *
 * ...
 * 
 * where ... denotes arguments and their types in proper C convention.
 *
 */

/* body of mylib code goes here */

#ifdef HP_CC
};
#endif
</pre>




<hr><h2 id="139"><a name="releasing-the-heap-2">1.10 Releasing the heap when calling foreign functions</a></h2>

<p id="140">
When you are running multiprocessing on a platform using the
<code>:os-threads</code> model (see
<a href="multiprocessing.htm">multiprocessing.htm</a>), you have to worry about
foreign functions in different threads modifying values in the Lisp
heap in a thread unsafe way. (This is not a problem when running on a
platform that does not use the <code>:os-threads</code> model
because no lightweight Lisp process will run while foreign code is
being executed.) 
</p>
<p id="141">
Therefore, on platforms using the <code>:os-threads</code>
model, in order for any thread in a process to execute lisp code, it
must have exclusive control of the data and control structures that
define the lisp execution environment. These resources are
collectively called "the Heap" and access to them is controlled by OS
synchronization primitives. Initially, the single thread that
initializes the lisp environment has possession of the Heap. If
multiple threads are running lisp code, Allegro arranges that they
will each have access to the heap at appropriate times. A thread that
runs lisp code for a long time may be preempted at various points so
that control of the heap can be given to another thread. A thread that
makes a call to a foreign function has the option of "releasing the
heap" for the duration of the call. This allows another thread to take
control of the heap while the first thread performs an action that may
require significantly more real time than cpu time. A foreign call
that is cpu-bound, however, would be better off not releasing the
heap, especially if the call took a small amount of processor time
and/or occurred frequently. See the discussion of the
<i>release-heap</i> argument to <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> for information on
how to indicate the heap can be released in a foreign call.
</p>




<hr><hr><h2 id="142"><a name="43-unix-model-1">2.0 The 4.3.x UNIX model for foreign functions</a></h2>

<p id="143">All existing 4.3 exported symbols become deprecated, and preserved
only for compatibility. There is a compatibility module for 4.3.x
style foreign functions code. The module is called <em>ffcompat</em>
and can be loaded with</p>

<pre id="144">
(require :ffcompat)
</pre>

<hr><hr><h2 id="145"><a name="interface-specification-1">3.0 The foreign function interface specification</a></h2>

<p id="146">The remainder of this document describes the foreign function
interface in Allegro CL. Except as noted, the interface is
the same on all platforms.</p>

<p id="147">
The description of foreign types is in the document
<a href="ftype.htm">ftype.htm</a>.
</p>

<hr><h2 id="148"><a name="ff-interface-summary-2">3.1 Foreign function interface function summary</a></h2>

<p id="149">The following table shows the functions used in the foreign
function interface. The <strong>Notes</strong> in the following table
provide brief and by no means complete descriptions of the object
being described. Please follow the link to the description page for
the complete description including warnings and subtleties.</p>

<table border="1" width="95%" height="95%">
  <tr>
    <td width="33%" height="19"><strong>Name</strong></td>
    <td width="33%" height="19"><strong>Arguments</strong></td>
    <td width="34%" height="19"><strong>Notes</strong></td>
  </tr>
  <tr>
    <td width="33%" height="57"><a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a></td>
    <td width="33%" height="57"><em>name-and-options arglist &key option ...</em></td>
    <td width="34%" height="57">This macro defines a foreign function as the symbol-function
    of a Lisp symbol. See <a href="#def-foreign-call-2">Section 3.2 def-foreign-call</a>
    below.</td>
  </tr>
  <tr>
    <td width="33%" height="38"><a href="operators/ff/def-foreign-variable.htm"><b>def-foreign-variable</b></a></td>
    <td width="33%" height="38"><em>name-and-options &key type convention</em></td>
    <td width="34%" height="38">This macro defines a foreign variable to Lisp. See <a href="#def-foreign-variable-2">Section 3.3 def-foreign-variable</a> below.</td>
  </tr>
  <tr>
    <td width="33%" height="57"><a href="operators/ff/def-foreign-type.htm"><b>def-foreign-type</b></a></td>
    <td width="33%" height="57"><em>name-and-options def ...</em></td>
    <td width="34%" height="57">This macro defines a foreign type to Lisp and can make a
    connection between foreign and Lisp types, allowing proper conversion. 
    See <a href="ftype.htm">ftype.htm</a>.</td>
  </tr>
  <tr>
    <td width="33%" height="57"><a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a></td>
    <td width="33%" height="57"><em>name arglist &body body</em></td>
    <td width="34%" height="57">This macro defines a Lisp function which can be directly
    called by a foreign function. See 
    <a href="#lisp-from-c-1">Section 9.0 Using Lisp functions and values from C</a> below.</td>
  </tr>
  <tr>
    <td width="33%" height="57"><a href="operators/ff/register-foreign-callable.htm"><b>register-foreign-callable</b></a></td>
    <td width="33%" height="57"><em>name &optional index-or-reuse convert-to-c-types</em></td>
    <td width="34%" height="57">Registers the location of a Lisp function to allow access by
    foreign code. See <a href="#calling-lisp-from-c-2">Section 9.2 Calling Lisp functions from C: lisp_call_address() and lisp_call()</a>
    below.</td>
  </tr>
  <tr>
    <td width="33%" height="57"><a href="operators/ff/unregister-foreign-callable.htm"><b>unregister-foreign-callable</b></a></td>
    <td width="33%" height="57"><em>index</em></td>
    <td width="34%" height="57">Unregisters a Lisp function registered with <a href="operators/ff/register-foreign-callable.htm"><b>register-foreign-callable</b></a>.
    See <a href="#calling-lisp-from-c-2">Section 9.2 Calling Lisp functions from C: lisp_call_address() and lisp_call()</a> below.</td>
  </tr>
  <tr>
    <td width="33%" height="57"><a href="operators/ff/register-lisp-value.htm"><b>register-lisp-value</b></a></td>
    <td width="33%" height="57"><em>value &optional index</em></td>
    <td width="34%" height="57">Register a Lisp value to allow access by foreign code. See <a href="#accessing-lisp-values-2">Section 9.1 Accessing Lisp values from C: lisp_value()</a> below.</td>
  </tr>
  <tr>
    <td width="33%" height="57"><a href="operators/ff/unregister-lisp-value.htm"><b>unregister-lisp-value</b></a></td>
    <td width="33%" height="57"><em>index</em></td>
    <td width="34%" height="57">Unregisters a Lisp value registered with <a href="operators/ff/register-lisp-value.htm"><b>register-lisp-value</b></a>. See 
    <a href="#accessing-lisp-values-2">Section 9.1 Accessing Lisp values from C: lisp_value()</a> below.</td>
  </tr>
  <tr>
    <td width="33%" height="38"><a href="operators/ff/lisp-value.htm"><b>lisp-value</b></a></td>
    <td width="33%" height="38"><em>index</em></td>
    <td width="34%" height="38">Simulates a call to <strong>lisp_value()</strong>. See <a href="#accessing-lisp-values-2">Section 9.1 Accessing Lisp values from C: lisp_value()</a> below.</td>
  </tr>
  <tr>
    <td width="33%" height="76"><a href="operators/ff/convert-foreign-name.htm"><b>convert-foreign-name</b></a></td>
    <td width="33%" height="76"><em>name &key language</em></td>
    <td width="34%" height="76">Default function used to convert a Lisp name to a foreign
    entry point (prepending and appending characters such as underscores as needed. See <a href="#def-foreign-call-syntax-3">Section 3.2.1 def-foreign-call syntax</a> below.</td>
  </tr>
  <tr>
    <td width="33%" height="38"><a href="operators/ff/get-entry-point.htm"><b>get-entry-point</b></a></td>
    <td width="33%" height="38"><em>name</em></td>
    <td width="34%" height="38">Returns the entry point for <em>name</em>, if there is one.
    Returns <code>nil</code> if there is not.</td>
  </tr>
  <tr>
    <td width="33%" height="40"><a href="operators/ff/list-all-foreign-libraries.htm"><b>list-all-foreign-libraries</b></a></td>
    <td width="33%" height="40">&key <em>return-structs </em>&allow-other-keys</td>
    <td width="34%" height="40">Returns a list of all foreign libraries 
    (so/sl/dylib/dll files) that
    are loaded into the current Lisp image.</td>
  </tr>
  <tr>
    <td width="33%" height="19"><a href="operators/ff/unload-foreign-library.htm"><b>unload-foreign-library</b></a></td>
    <td width="33%" height="19"><em>filename</em></td>
    <td width="34%" height="19">Unmaps (i.e. unloads) the so/sl/dylib/dll files previously loaded
    with <a href="../ansicl/dictentr/load.htm"><b>load</b></a> specified by <em>filename</em>.</td>
  </tr>
  <tr>
    <td width="33%" height="19"><a href="operators/ff/char_s_-to-string.htm"><b>char*-to-string</b></a>
    [<strong>Obsolete</strong>, use <a href="operators/excl/native-to-string.htm"><b>native-to-string</b></a>
    instead]</td>
    <td width="33%" height="19"><em>address </em>&optional<em> string make-string-p</em></td>
    <td width="34%" height="19">Takes the address of a C string and returns an equivalent Lisp
    string. </td>
  </tr>
  <tr>
    <td width="33%" height="19"><a href="operators/excl/native-to-string.htm"><b>native-to-string</b></a></td>
    <td width="33%" height="19"><em>address</em> &key <em>string make-string?
    external-format</em></td>
    <td width="34%" height="19">Takes the address of a C string and returns an equivalent Lisp
    string. This function has other uses in International Allegro CL 
    (see <a href="iacl.htm">iacl.htm</a>).
    See <a href="#passing-strings-1">Section 5.0 Passing strings between Lisp and C</a> below.</td>
  </tr>
  <tr>
    <td width="33%" height="19"><a href="operators/ff/string-to-char_s.htm"><b>string-to-char*</b></a>
    [<strong>Obsolete</strong>, use <a href="operators/excl/string-to-native.htm"><b>string-to-native</b></a>
    instead]</td>
    <td width="33%" height="19"><em>string </em>&optional<em> address</em></td>
    <td width="34%" height="19">Takes a Lisp string and writes a C string to malloc space. </td>
  </tr>
  <tr>
    <td width="33%" height="19"><a href="operators/excl/string-to-native.htm"><b>string-to-native</b></a></td>
    <td width="33%" height="19"><em>string </em>&key<em> :address :external-format </em></td>
    <td width="34%" height="19">Takes a Lisp string and writes a C string to malloc space.
    This function has other uses in International Allegro CL 
    (see <a href="iacl.htm">iacl.htm</a>).
    See <a href="#passing-strings-1">Section 5.0 Passing strings between Lisp and C</a> below.</td>
  </tr>
  <tr>
    <td width="33%" height="19"><a href="operators/excl/with-native-string.htm"><b>with-native-string</b></a></td>
    <td width="33%" height="19"><em>(string-var string-exp &key (start 0) end
    native-length-var external-format) &body body</em></td>
    <td width="34%" height="19">This macro provides an efficient, portable, and non-garbage
    (from the Lisp garbage collector's point of view) 
    way of converting lisp-strings to
    addresses acceptable for foreign functions expecting native 
    string arguments. This macro
    has other uses in International Allegro CL 
    (see <a href="iacl.htm">iacl.htm</a>).</td>
  </tr>
  <tr>
    <td width="33%" height="19"><a href="operators/ff/foreign-strlen.htm"><b>foreign-strlen</b></a></td>
    <td width="33%" height="19"><em>address</em></td>
    <td width="34%" height="19">Returns the length of the C string located at address. See <a href="#passing-strings-1">Section 5.0 Passing strings between Lisp and C</a>
    below.</td>
  </tr>
</table>

<hr><h2 id="150"><a name="foreign-addresses-3">3.1.1 A note on foreign addresses</a></h2>

<p id="151">Locations of foreign objects (usually objects stored outside the
Lisp) are typically specified by addresses. A true address is a
machine integer. Lisp integers are not machine integers (because
certain bits have special meaning in fixnums and bignum have a header)
but a true machine integer can be extracted easily enough so long as
the system knows to do it. Foreign functions defined to Lisp with
<a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> may take foreign
type objects, or vectors or foreign-addresses (integers, vectors, or
foreign-pointer objects) as arguments.</p>

<p id="152">
A <em>foreign type</em> is either one of the built-in types (like
<code>:int</code>) or one of a system of foreign structures
defined with <a href="operators/ff/def-foreign-type.htm"><b>def-foreign-type</b></a>.
</p>

<p id="153">
A <em>foreign-pointer</em> is an instance of the class <a href="classes/ff/foreign-pointer.htm"><code>foreign-pointer</code></a> (see
also <a href="operators/ff/make-foreign-pointer.htm"><b>make-foreign-pointer</b></a>) that has a
special slot (with accessor <a href="operators/ff/foreign-pointer-address.htm"><b>foreign-pointer-address</b></a>) intended
to point to raw data.
</p>

<p id="154">
A <em>foreign adress</em> is either a Lisp integer, a Lisp vector, or
a foreign-pointer instance.
</p>

<p id="155">
Note that foreign-types and foreign-pointers have nothing particular
to do with each other. (A foreign-pointer is really a way to identify
an integer as a foreign pointer -- rather than any old value -- to
allow better argument and type checking.)
</p>

<p id="156">
The second required argument to <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> is the argument
list for the foreign function. The elements of that list are lists of
argument names (symbols) followed by the foreign type to which it
should be converted (and perhaps followed by additional values). A
symbol alone is the same as the list <code>(symbol
:int)</code>.</p>

<p id="157">A Lisp value passed as an argument to a foreign function will be converted
appropriately according to the specification in the argument list. </p>

<p id="158">Thus, when a foreign type is specified as an argument to a foreign call, the value
passed will be converted from Lisp to C by specific rules. For example, a <code>:int</code> type expects a Lisp integer and converts it to a machine
integer. A <code>:struct</code> is adjusted to point to its first
element, etc.</p>

<p id="159">
When the argument is specified <code>:foreign-address</code>,
the system will accept as a value (1) a Lisp integer (converted to a
machine-integer), (2) a Lisp vector (adjusted to point to its first
element), or (3) a foreign-pointer (converted by extracting the
<a href="operators/ff/foreign-pointer-address.htm"><b>foreign-pointer-address</b></a> from the
object).
</p>
<p id="160">
There is a special foreign type, <code>:aligned</code>. This
type looks like a fixnum is Lisp but the internal bit pattern if that
of an unsigned machine integer with the lowest two (in 32-bit Lisps)
or 3 (in 64-bit Lisps) bits 0. As long as your code can handle
pointers aligned on 4 (32-bit) or 8 (64-bit) boundaries,
then <code>:aligned</code> values can be passed between Lisp and
foreign code allowing the full address space to use fixnums only, thus
avoiding the overhead of bignum arithmetic and the chance of
unexpected consing causing a garbage collection. See <a href="ftype.htm#aligned-pointers-1">Aligned Pointers and the
:aligned type</a> in <a href="ftype.htm">ftype.htm</a> for more
information. You must be very careful when manipulating these value
within Lisp because Lisp will treat them as fixnums (not as unsigned
machine integers) and so operations on them may not have the results
that you might expect.
</p>






<hr><h2 id="161"><a name="def-foreign-call-2">3.2 def-foreign-call</a></h2>

<p id="162">
The macro <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> associates a
foreign function with a Lisp symbol, allowing it to be called as a
Lisp function would be called.
</p>

<p id="163">
The problem in making such an association is that Lisp types and
foreign types are usually different, and so as part of the definition
of a foreign function, the system must be told how Lisp objects passed
as arguments should be converted to foreign types and how a returned
value should be converted to a Lisp type. Further information can be
provided as well: should the call be a candidate for inlining? When
the multiprocessing model is <strong>:os-threads</strong>, should
other processes be able to modify the Lisp heap while the foreign
function is running? And so on.
</p>

<p id="164">
The definition of <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> is on its own
description page, found by following the link. We discuss the syntax
of a call next and then make some other comments and provide
examples.
</p>

<hr><h2 id="165"><a name="def-foreign-call-syntax-3">3.2.1 def-foreign-call syntax</a></h2>

<pre id="166">
<a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> name-and-options arglist &key kwopt ... MACRO
</pre>

<blockquote>
  <p id="167">This macro is used to describe a function written in a foreign language (usually C).
    The action of this macro is to define a Lisp function which when called will pass
  control to the foreign function, making appropriate data transformations on arguments to
  and the return value from the foreign function.</p>
</blockquote>

<pre id="168">
name-and-options -&gt; name-symbol <i>;; default conversion to external name</i>
                 -&gt; (lisp-name-symbol external-name)

external-name    -&gt; [convert-function] [external-name-string]  ;; default convert function is 
                                                               ;; <a href="operators/ff/convert-foreign-name.htm"><b>convert-foreign-name</b></a>

arglist          -&gt; ()      <i>;; Implies default argument processing
                           ;; (like old defforeign :arguments t spec)</i>
                 -&gt; (:void) <i>;; Explicitly looking for no arguments</i>
                 -&gt; (arg ...)

arg              -&gt; name
                 -&gt; (name type-spec)
                   <em>;; If name is nil, a dummy name will be supplied.</em>
                 -&gt; ...
                   <em>;; ... (an ellipsis) must be the string "..." or
                       ;; a symbol in any package (e.g. user::...).
                       ;; If an ellipsis is used, it represents any number 
                       ;; of arguments, untyped, regardless of what 
                       ;; comes before it. If ... is used it must
                       ;; only be used once as the last argument
                       ;; specification.  Any arguments prior to the
                       ;; elipsis are treated as they are without the
                       ;; elipsis, and any arguments from the elipsis
                       ;; onward are treated as if the def-foreign-call
                       ;; had been specified with no prototyping;
                       ;; i.e. the number and type of the arguments from
                       ;; the elipsis and beyond are ignored.</em>

type-spec        -&gt; foreign-type
                 -&gt; (complex-type-spec)

complex-type-spec-&gt; foreign-type [lisp-type [user-conversion]]

lisp-type        -&gt; any Lisp type
                   <i>;; This constrains the runtime arg to this
                   ;; Lisp type.  When trusting declarations we
                   ;; assume the Lisp type and optimize accordingly.</i><br>
                   <i>;; If declarations are appropriate the compiler
                   ;; may generate checks to validate the lisp type.</i>

user-conversion   -&gt; symbol <em>;; see <a href="#user-conv-3">Section 3.2.2 The user-conversion function in a complex-type-spec</a></em>

kwopt             -&gt; :RETURNING type-spec
                   <em>;; Note that if the foreign type mentioned 
                       ;; in the :RETURNING clause is expressed as
                       ;; a list (i.e. begins with a parenthesis) then the 
                       ;; second form of type-spec -- (complex-type-spec)
                       ;; -- must be used.  Otherwise, the first 
                       ;; component of the foreign type is
                       ;; treated as the first component of a 
                       ;; complex-type-spec and a spurious 
                       ;; error is signaled.  For example, if
                       ;; the type is (* Foreigntype), that is 
                       ;; a pointer to a struct of type 
                       ;; Foreigntype, then the correct specification
                       ;; is `:returning ((* Foreigntype))'</em>
                 -&gt; :CONVENTION { :C | :STDCALL | :FORTRAN}
                   <em>;; On NT, C (cdecl) and stdcall are now equivalent.
                       ;; :FASTCALL is not supported.</em>
                 -&gt; :ARG-CHECKING { NIL | T }
                 -&gt; :CALL-DIRECT { NIL  | T }
                 -&gt; :METHOD-INDEX index <em>;; Ordinal index of C++ member
                                      ;; method; vtbl is first argument.</em>
                 -&gt; :CALLBACK { NIL  | T }<em>;; Callback currently forced to T.</em>
                 -&gt; :RELEASE-HEAP { :NEVER | :ALWAYS | :WHEN-OK }

                 -&gt; :PASS-STRUCTS-BY-VALUE { NIL | T } <em>;; If nil, 
                         ;; structures are passed by reference even if
                         ;; they are not so specified with a *.</em>

                 -&gt; :ERROR-VALUE { NIL | :ERRNO | :OS-SPECIFIC } ;; When
                             ;; non-NIL, return error value as
                             ;; second return value from foreign call.

                 -&gt; :DOCUMENTATION { NIL | STRING } <em>;; If a 
                         ;; string, the documentation string for the
                         ;; new foreign function.</em>

</pre>



<hr><h2 id="169"><a name="user-conv-3">3.2.2 The user-conversion function in a complex-type-spec</a></h2>

<p id="170">
In the syntax diagram in
<a href="#def-foreign-call-syntax-3">Section 3.2.1 def-foreign-call syntax</a> above,
we have these specifications:
</p>

<pre id="171">
arg              -&gt; name
                 -&gt; (name type-spec)
                 [...]
type-spec        -&gt; foreign-type
                 -&gt; (complex-type-spec)

complex-type-spec-&gt; foreign-type [lisp-type [user-conversion]]

lisp-type        -&gt; any Lisp type
                 [...]

user-conversion   -&gt; symbol <em>;; [link to this section]</em>
</pre>

<p id="172">
<i>user-conversion</i>, if supplied, must be a symbol naming a
function which should be defined before the call to <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> (if it is not, a
warning is signaled) and must be defined before the defined foreign
function is called.
</p>
<p id="173">
<i>user-conversion</i> can be supplied for arguments to
the foreign function (as part of the value of
the <i>arglist</i> argument, the second required
argument) or for return values from the foreign function (as part of
the value of the <i>:returning</i> keyword argument).
The function converts a Lisp type to a foreign type for arguments and
a foreign type to a Lisp type for returned values.
</p>
<p id="174">
The conversion function must accept four arguments. It should return
appropriate values based on the value of the first
(<i>action</i>) argument. If action
is <code>:convert</code>, the function should return a converted
value.
</p>
<ol>
<li id="175">
<b><i>action</i></b>: the value will be one of the
following keywords:
<ul>
<li id="176">
<code>:identify</code>: with this value for action, the function
should return <code>:arg</code> or <code>:return</code> as
it applies to an argument or a return value.
</li>
<li id="177">
<code>:convert</code>: does the actual conversion of value, from
a Lisp value of type <i>lisp-type</i> to a foreign value
of type <i>c-type</i> for argument conversion, and from
a <i>c-type</i> to a <i>lisp-type</i> for
return conversion.
</li>
<li id="178">
<code>:convert-type</code>: when action has this value, the
function must return ones of the symbols :lisp, integer, or
fixnum. The function is called with this action after the conversion
(for an argument) and before the conversion (for a return)
</li>
<li id="179">
<code>:check</code> (for argument conversions only): the
argument may be checked for validity and an error signaled if it is
invalid. We say "may" because the function -- which is user-written --
may in fact not do any checking. However, the function returning
rather than erroring is taken by the caller to mean the argument is
valid.
</li>
<li id="180">
<code>:allocate</code> (for return conversions only): A box may
be allocated and returned to hold the object that will be returned
from the foreign function. This action will be requested before the
foreign-function is run, and the <i>value</i> argument
will be <code>nil</code> (though
the <i>c-type</i> and <i>lisp-type</i>
arguments will be valid). This gives a chance for a box to be
allocated with no worry about the return value being moved by a
garbage collection. The conversion function may also allocate during
the <code>:convert</code> action, but care must be taken to not
allow the return value to move during such allocation.
</li>
<li id="181">
<code>:will-allocate</code> (for return conversions only): this
action may be requested at compile-time, and expects a boolean to be
returned specifying whether or not the <code>:allocate</code>
action will do anything.  Returning <code>nil</code> will
cause the <code>:allocate</code> action not to be requested,
which will speed up open-coded operation.
</li>
</ul>
</li>
<li id="182">
<b><i>value</i></b>: the value to be converted. Not
supplied in all cases.
</li>
<li id="183">
<b><i>c-type</i></b>: the foreign type as specified in
the complex-type-spec.
</li>
<li id="184">
<b><i>lisp-type</i></b>: the Lisp type, as specified in the
complex-type-spec.
</li>
</ol>
<p id="185">
Here are a couple of examples, one for converting an argument and one
for converting a return value. (These are actual predefined conversion
functions).
</p>

<pre id="186">
;; CONVERT-NON-ZERO-INT:
;; Checks that the argument is a non-zero integer, and then converts
;; according to normal integer conversion rules.

(defun convert-non-zero-int (action val ctype ltype)
  (declare (ignore ctype ltype))
  (case action
    (:convert val) ;; The integer convert-type will take care of this
    (:convert-type 'integer)
    (:identify :arg)
    (:check
     (unless (and (integerp val) (not (zerop val)))
       (.type-error val 'integer 
            "Foreign argument ~s is not a non-zero integer." val)))))

;; CONVERT-INT-RET-TO-STRING:
;; Intended for use in a (* :char) return declaration.  The returned
;; value is boxed as an int and given as the VAL to this function 
;; which does a NATIVE-TO-STRING.  Note that the
;; NATIVE-TO-STRING call uses the default external-format, so if any
;; specific format conversions are desired, they would have to be done
;; as an :unsigned-long specification followed by an explicit call
;; to NATIVE-TO-STRING (i.e. not using this default function)
(defun convert-int-ret-to-string (action val ctype ltype)
  ;; Allows an intuitive interface to returning (* :char) from a
  ;; foreign function.  The previous method required specifying the
  ;; return type as :int and then calling native-to-string on it
  ;; explicitly.
  (declare (ignore ctype ltype))
  (case action
    (:convert (native-to-string val))
    (:convert-type 'integer)
    (:identify :return)
    (:allocate nil)
    (:will-allocate nil)))
</pre>



<hr><h2 id="187"><a name="def-foreign-call-returning-3">3.2.3 def-foreign-call: the :returning keyword argument</a></h2>

<p id="188">
The <code>:returning</code> keyword argument specifies what the
foreign function will return when it completes. This value, suitably
modified to a Lisp value, will be returned by the Lisp function
associated with the foreign function.
</p>
<p id="189">
The value specified for <code>:returning</code> can be:
</p>
<ol>
<li id="190">
A foreign
type (defined by <a href="operators/ff/def-foreign-type.htm"><b>def-foreign-type</b></a>). 
</li>
<li id="191">
A list of
a foreign type and a Lisp type; example: <code>(:double
single-float)</code>. 
</li>
<li id="192">
A list of a foreign type, a Lisp type, and a symbol naming a
user-conversion function; example: <code>(:double single-float
my-conversion-function)</code>. Conversion functions are described
in <a href="#user-conv-3">Section 3.2.2 The user-conversion function in a complex-type-spec</a>.
</li>
<li id="193">
<code>((* :char))</code>, or
<code>((* :char) </code><code><i>string</i></code><code>)</code>, etc.; these cause
<a href="operators/excl/native-to-string.htm"><b>native-to-string</b></a> to be
called automatically after the return.
</li>
<li id="194">
The value
<code>:lisp</code>, meaning a Lisp object will be returned and
no conversion should be done. This is a dangerous option since if the
returned value is not actually a Lisp object, a gc failure may
occur. If there has been a garbage collection since the Lisp type
location was captured bu the foreign code, a gc failure may also occur
because location information may be wrong. A warning is
signaled if <code>:lisp</code> is specified for the return
value.
</li>
<li id="195">
The value <code>:foreign-address</code>, which will
be interpreted as an unsigned integer and converted to a positive Lisp
integer.
</li>
<li id="196">
The value <code>:aligned</code>. The value returned must be an
aligned value (a machine integer with the lowest three bits in 64-bit
Lisps and the lowest two bit in 32-bit Lisps 0). This will be passed
unchanged to Lisp, where the value will appear as a fixnum.  See
<a href="ftype.htm#aligned-pointers-1">Aligned Pointers and
the :aligned type</a> in <a href="ftype.htm">ftype.htm</a> for more
information.
</li>
<li id="197">
The value <code>:void</code>, meaning nothing will
be returned and the Lisp function should return <code>nil</code>. (There are some additional deprecated options:
see the description of <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>.)
</li>
</ol>
<p id="198">
The default for <code>:returning</code> is the foreign type
<code>:int</code>, which is a value of type (1) in the list
above. The integer value is converted upon return to Lisp type integer
(a fixnum with a possible overflow to a bignum). This default value is
not appropriate when the foreign function is returning a long, an
unsigned long, or a pointer of some sort. However, the fact that it is
not appropriate is masked on 32-bit architectures by the fact that, as
it happens, an <code>:int</code> is effectively equivalent to
those values.
</p>
<p id="199">
On 64-bit architectures, however, this is not true so
<code>:int</code> cannot serve for a long, an unsigned long, or
a pointer of some sort. Therefore, when returning a pointer, the type
should be <code>:unsigned-long</code> and when returning another
integer value, the type should be <code>:int</code> or
<code>:long</code> or <code>:unsigned-long</code>, as
appropriate.
</p>



<hr><h2 id="200"><a name="def-foreign-call-example-3">3.2.4 def-foreign-call examples</a></h2>

<p id="201">Here are some examples of <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> usage:</p>

<pre id="202">
(def-foreign-call add2 (x y))
</pre>

<p id="203">
Call a function, probably named "add2" in C, whose first arg
is named "x" and is an integer in Lisp and which is
converted to an int for passing to C.  If the integer is larger than
can be held in a C int, it is truncated. As with the first arg, the
second arg named "y" is an integer converted to a C int. The
return value is interpreted as a C int type, and is converted to a
Lisp integer (which may either be a fixnum or consed as a
bignum).
</p>

<pre id="204">
(def-foreign-call t_double ((x :double)
                            (y :double single-float)
                            (z :int fixnum))
  :returning :double))
</pre>

<p id="205">
Call a function, probably named "t_double" in C, whose first
arg is a double-float both in Lisp and in C, and whose second arg is a
single-float in Lisp but is converted to double float for passing into
C (this is the calling convention used by some non ANSI C compilers
and by others when the arguments are not prototyped), and the third
argument is a fixnum Lisp passed as an integer to C. The function
returns and boxes a double-float value to Lisp.
</p>

<pre id="206">
(def-foreign-call (t-float dash-to-underscore) ((x :double)
                                                (y (:float :no-proto))
                                                (z :int fixnum)
                                                (w (* :char) string))
  :returning #-(or (and sun4 (not svr4)) sun3q) :float
             #+(or (and sun4 (not svr4)) sun3q) (:double single-float)

(def-foreign-call (t-float "t_float") ((x :double)
                                                (y (:float :no-proto))
                                                (z :int fixnum)
                                                (w (* :char) string))
  :returning #-(or (and sun4 (not svr4)) sun3q) :float
             #+(or (and sun4 (not svr4)) sun3q) (:double single-float)
</pre>

<p id="207">
These two examples do the same thing: call a function, named
"t_float" in C (assuming in the first case proper conversion
by <strong>dash-to-underscore</strong>, which must already be defined
and should downcase the symbol name and replace dashes with
underscores), whose first arg is a double-float both in Lisp and in
C. Like the previous example, the second arg is a float in Lisp, and
is converted to double float for passing into C. The third arg named
"z" is a fixnum passed as an int, and "w" is a
(null-terminated) Lisp string, whose first-character-address is passed
to C (beware, the string may move if a gc is allowed). Depending on
the architecture, the C function will return either a double (from
older C compilers) or a float, each interpreted and boxed as a Lisp
single-float value.
</p>

<p id="208">
We give both examples to show how a lisp name (the symbol
<code>t-float</code>) is converted to a foreign name
("t_float"). You can either specify a function that takes a
symbol and returns the correct string (so <code>(dash-to-underscore
't-float)</code> returns <code>"t_float"</code>) or
you can simply specify the correct string. Note again that
<strong>dash-to-underscore</strong> must be already defined when the
def-foreign-call form in evaluated.
</p>

<pre id="209">
(def-foreign-call c_array ((str (* (* :char)) (simple-array simple-string (*)))

                          (n :int fixnum))
    :returning :char)
</pre>

<p id="210">
Call a function whose C name is probably c_array, whose
"str" argument is an array of strings, properly converted
(by copying from the Lisp parts). The second arg "n" is a
Lisp fixnum shifted to make a C int. The C function returns a char
which is made into a Lisp character.
</p>





<hr><h2 id="211"><a name="def-foreign-variable-2">3.3 def-foreign-variable</a></h2>

<p id="212">
The <a href="operators/ff/def-foreign-variable.htm"><b>def-foreign-variable</b></a> macro is
used to describe a variable exported by a foreign language (usually
C). The action of this macro is to define a Lisp
<strong>symbol-macro</strong> which when evaluated will obtain the
address of the foreign variable and either retrieve or set the value
of the variable based on the access-type.
</p>
<p id="213">
the <i>type</i> argument of <a href="operators/ff/def-foreign-variable.htm"><b>def-foreign-variable</b></a> is the
access type of the variable, and can be any of the valid access types
for <a href="operators/system/memref.htm"><b>memref</b></a>
and <a href="operators/system/memref-int.htm"><b>memref-int</b></a>. The
default access type is <code>:unsigned-long</code>. Note
the <i>type</i> is not a foreign type.
</p>

<hr><h2 id="214"><a name="def-foreign-variable-syntax-3">3.3.1 def-foreign-variable syntax</a></h2>

<pre id="215">
<a href="operators/ff/def-foreign-variable.htm"><b>def-foreign-variable</b></a> name-and-options &key kwopt ... MACRO
</pre>

<blockquote>
  <p id="216">This macro is used to describe a variable exported by a foreign language (usually C).
    The action of this macro is to define a Lisp symbol-macro which when evaluated will
  obtain the address of the foreign variable and either retrieve or set the value of the
  variable based on the access-type.</p>
</blockquote>

<pre id="217">
name-and-options -&gt; name-symbol <i>;; default conversion to external name</i>
                 -&gt; (lisp-name-symbol external-name)

external-name    -&gt; [convert-function] [external-name-string]

 kwopt         -&gt; :type access-type
               -&gt; :CONVENTION { :C | :FORTRAN}

</pre>



<hr><h2 id="218"><a name="def-foreign-variable-example-3">3.3.2 def-foreign-variable examples </a></h2>

<p id="219">
Here are some examples of <a href="operators/ff/def-foreign-variable.htm"><b>def-foreign-variable</b></a> usage:
</p>

<pre id="220">
user(1): (ff:def-foreign-variable sigblockdebug)
sigblockdebug
user(2): sigblockdebug
0
user(3): (setq sigblockdebug 1)
1
user(4): (ff:def-foreign-variable (print-lso-relocation "print_lso_relocation"))
print-lso-relocation
user(5): print-lso-relocation
0
user(6): (setq print-lso-relocation 1)
1
user(7): 
</pre>

<p id="221">In these examples, variables from the Allegro CL internal runtime
are set up to allow Lisp to access the variables in a lispy way. Since
these variables are not documented, it would take a C debugger to
examine and verify that the values of the C variables had indeed been
changed.</p>

<p id="222"><strong>WARNING</strong>: Do not attempt to use this macro on the C
"errno" variable, nor on any other variable that might be
bound on a per-thread basis; doing so might cause (incorrect)
information to be returned for the wrong thread.</p>





<hr><hr><h2 id="223"><a name="arg-passing-conventions-1">4.0 Conventions for passing arguments</a></h2>

<p id="224">Arguments to function calls can be passed in two ways, by value and
by address. When an argument is passed by value, a copy of the value
is placed somewhere (typically on the stack) where the function can
access it. When an argument is passed by address, a pointer to its
actual location is given to the function. Arguments in C are usually
(but not always) passed by value, while arguments in Fortran are
normally passed by address.</p>

<hr><h2 id="225"><a name="modifying-arguments-2">4.1 Modifying arguments called by address: use arrays</a></h2>

<p id="226">A function that receives an argument called by value can modify that value. There are
two problems with such modifications: 
</p>

<ul>
  <li id="227">Lisp may not see the modification when you want it to (because Lisp makes a copy of the
    object and passes the address of the copy -- the copy is indeed modified but the original
    is not).</li>
  <li id="228">Lisp may see the modification when you do not expect it to. If you pass a floating point
    value, it may be modified and Lisp may see the modification even though that is not
    intended.</li>
</ul>

<p id="229">
We deal with each situation in turn. The solution is the same in both
cases: pass the address of an array.
</p>



<hr><h2 id="230"><a name="seeing-modifications-2">4.2 Lisp may not see a modification of an argument passed by address</a></h2>

<p id="231">
When an argument is passed by address in C or Fortran code and the
called function changes the value of the argument, the argument will
stay changed even after control returns from the called function. The
actual stored value of the argument will have been permanently
modified. This is expected behavior and is generally what is intended
and desired. 
</p>

<p id="232">
Users therefore should be warned that in many cases (arrays being the
main exception) when Lisp code calls a foreign function that modifies
one of the arguments passed by address, the Lisp value of that
argument will be unchanged. The reason is that Lisp represents objects
differently from C or Fortran and so often cannot pass the actual
address of the Lisp object to the foreign code, since the foreign code
would not correctly interpret the value pointed to. Instead, Lisp
makes a copy of the Lisp object, changing the representation
appropriately, and passes the address of the copy. Although this
copied value is modified by the foreign code, Lisp ignores the copied
value after the function returns, looking only at the unmodified Lisp
object. 
</p>

<p id="233">To repeat the above warning: Fortran functions do not always affect the value of a Lisp
object when this is passed to a Fortran function. The following example illustrates this
behavior. Say we have the Fortran file <i>fnames.f</i> containing the function
<strong>itimes2()</strong>: </p>

<pre id="234">
  function itimes2(x)
  integer x
  x = 2*x
  itimes2 = x
  return
  end 
</pre>

<p id="235">This function appears to double the (C or Fortran) integer value stored in the location
specified by x. We compile and load the file into Lisp and then run the function. Here are
the results: </p>

<pre id="236">
USER(21): (load "fnames.so")
t
USER(22): (ff:def-foreign-call itimes2 ((x :int fixnum))
                               :convention :fortran :returning :void)
;; send in a fixnum, but pass by address
ITIMES2
USER(23): (setq x 19)
19
USER(24): (itimes2 x)
38 ;; gives 38 as expected
USER(25): x
19 ;; but x is unchanged.
</pre>

<p id="237">
The problem is that a Lisp fixnum is not the same as a Fortran (or
C) integer, and thus the foreign-function interface must convert
it. It copies the Lisp fixnum, converts it to a Fortran integer, and
then passes the address of the converted copy to the Fortran
function. When passing a fixnum array, though, there is no longer
an automatic conversion of the array element-type. Instead of
fixnum, an element-type with representation compatible with fortran
should be used. The expected Fortran behavior can be achieved by passing an
array as follows
</p>

<pre id="238">
USER(30): (ff:def-foreign-call itimes2 ((x :int (simple-array #-64bit '(signed-byte 32)
                                                              #+64bit '(signed-byte 64)
							      (1))))
            :convention :fortran :returning :void)
ITIMES2
USER(31): (setq x (make-array 1 :element-type #-64bit '(signed-byte 32)
                                              #+64bit '(signed-byte 64)
                              :initial-element 19))
#(19)
USER(32): (itimes2 x)
38 ;; gives 38 as expected
USER(33): x ;; as does x
#(38)
</pre>



<hr><h2 id="239"><a name="unexpected-change-to-argument-2">4.3 Lisp unexpectedly sees a change to an argument passed by address</a></h2>


<p id="240">
Again, when an argument is passed by address in C or Fortran code
and the called function changes the value of the argument, the
argument will stay changed even after control returns from the called
function. The actual stored value of the argument will have been
permanently modified.
</p>

<p id="241">
This can cause trouble when, for example, you pass a floating point
value to a FORTRAN routine that modifies the value. Consider the
following FORTRAN subroutine:
</p>

<pre id="242">
      subroutine dtest(x)
      double precision x
  
      x = x + 1.0d0
      return
      end
</pre>



<p id="243">
It increases the value of its argument by 1.0d0. We compile this
function, load it into Lisp, and define it as a foreign function with
<a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>:
</p>

<pre id="244">
(ff:def-foreign-call dtest ((x :double double-float)) 
                               :convention :fortran
                               :returning :void)
</pre>

<p id="245">
Now we run it, though the behavior you see may be different from what
is reported here. In some cases the contant value is changed (as
shown). In other cases, Lisp simply hangs unrecoverably. In any case,
things are too broken to continue (computation which believes 0.0d0
equals 1.0d0 is unlikely to be useful).
</p>

<pre id="246">

USER(3): (dtest 0.0d0)  ;; Lisp may hang at this point rather than
                        ;; returning control to the Listener.
nil
USER(4): 0.0d0
1.0d0
</pre>

<p id="247">
Whoa! What happened to 0.0d0? Well, here is what happened. 0.0d0 is a
Lisp object of type double-float. As such, it has a type code and a
pointer to its actual value, 0.0d0.  When dtest is called with 0.0d0
as an argument, the location of the value is passed.  FORTRAN then
modifies that location. The trouble is that Lisp still thinks that
location contains 0.0d0 and so when Lisp reads 0.0d0, it gets the
value in the location and finds 1.0d0 instead.
</p>

<p id="248">
In fact, Lisp reuses floating-point values whenever it can. Since
there is no way within Lisp to modify a value, there should be no
problem with using the same value over and over and doing so will save
time and space.
</p>

<p id="249">
It could be argued that Lisp should protect itself by making a copy of
the floating-point value and passing that to FORTRAN. However, that
would put a cost on many foreign calls where protection was not
necessary. Instead, there is a simple workaround for users who wish to
call by address code that modifies floats: specify the float as a
length 1 vector and pass the vector:
</p>

<pre id="250">
(ff:def-foreign-call dtest ((x (:array :double)))
                                :convention :fortran
                                :returning :void)

USER(8): (setq x1 (make-array 1 :element-type 'double-float 
                                :initial-element 0.0d0))
#(0.0d0)
USER(9): (dtest x1)
nil
USER(10): x1
#(1.0d0)
USER(11): 0.0d0
0.0d0
</pre>

<p id="251">
Fortran cannot distinguish between the address of the start of an
array and the address of a single value, so passing the address of the
double-float array x1 is correct and works as we want.
</p>



<hr><h2 id="252"><a name="passing-integers-2">4.4 Passing fixnums, bignums, and integers</a></h2>

<p id="253">
Another difficulty arising out of differing Lisp and non-Lisp
representations of values is illustrated by the example
<strong>itimes2()</strong> &nbsp;<a href="#seeing-modifications-2">above</a>. The argument
passed to the foreign function was a fixnum, not an integer. Integers
can be bignums or fixnums. C or Fortran integers may be larger than
all possible Lisp fixnums and smaller than most but not all
bignums. If a fixnum is passed to foreign code, it is always correctly
represented, but a bignum can be represented only if it is small
enough. The foreign-function interface will truncate any bignum that
does not fit into the foreign integer representation without
warning. Users can avoid this by not using integer as a value for
<em>arglist</em>, the second required argument to <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> and thus not
passing bignums, except when the argument value was generated by
foreign code. The return value from foreign code (the value of the
<em>returning</em> keyword argument) defaults to type
<code>:int</code>, and since some foreign integers are too big
to be fixnums, they may be bignums. But, since they came from foreign
code, they will be correctly represented as foreign integers when
passed back to foreign code. Only in the case where you are sure the
value can be represented as a machine integer do we recommend integer
as a value for <em>arglist</em> (more precisely, as an element in the
list which is the value). 
</p>



<hr><h2 id="254"><a name="array-to-pass-values-example-2">4.5 Another example using arrays to pass values</a></h2>

<p id="255">
An example illustrates the use of arrays. Say there is a compiled C
shared object file <i>myreverse.so</i>:
</p>

<pre id="256">
int myreverse(n, x)
double *x; /* pointer to array of doubles */
int n; /* array length */
{
   int i;
    double d;
    for (i=0; i &lt;= n/2; i++) {
        d = x[i];
        x[i] = x[n-1-i];
        x[n-1-i] = d;
    }
    return n;
} 
</pre>

<p id="257">
In Lisp you might define (after loading <i>myreverse.so</i>) this
function as follows:
</p>

<pre id="258">
USER(40): (ff:def-foreign-call myreverse ((i :int fixnum) (x (:array :double))))
MYREVERSE
USER(41): (setq x (make-array 3 :element-type 'double-float
                              :initial-contents '(1.0d0 2.0d0 3.0d0)))
#(1.0d0 2.0d0 3.0d0)
USER(42): (myreverse (length x) x)
3
USER(43): x
#(3.0d0 2.0d0 1.0d0) 
</pre>



<hr><hr><h2 id="259"><a name="passing-strings-1">5.0 Passing strings between Lisp and C</a></h2>

<p id="260">
Allegro Common Lisp provides a few functions to help converting
strings from Lisp to C and back again. In this section, we discuss the
issues and provide some examples.
</p>
<p id="261">
Starting in release 6.0, specifying <code>((* :char))</code>, or
<code>((* :char) </code><code><i>string</i></code><code>)</code>, etc.  as the value of
the <i>returning</i> to <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> causes <a href="operators/excl/native-to-string.htm"><b>native-to-string</b></a> to be called automatically
after the return. This is a safe change as far as compatibility goes,
because pre-6.0 versions would error on such a specification. The
alternative specification described here still works, and should be
used if any external-format other than <code>:default</code> is
desired. Thus in the example just below, you can specify <code>'((*
:char))</code> instead of <code>:int</code> as the value of
<code>:returning</code> and you will see the string rather than
the address of the string returned. Of you cannot apply (and do not
need to apply) <a href="operators/ff/foreign-strlen.htm"><b>foreign-strlen</b></a> to the result.
</p>
<p id="262">
Note that `C strings' are conceptual only. A `C string' is really not
a type, but a usage of a character pointer and its storage. A Lisp
string is an actual type and can be distinguished from other pointers.
There are other uses for a C character pointer besides strings, but
strings are most often passed in interface functions. By default, the
<a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> interface
expands a <code>((* :char))</code> to <code>((* :char)
string)</code>, which causes a Lisp string to be either created (on
return) or checked for (when passed as an argument). If such
checking or creation is not desired, (as would be the case where the
Lisp value would be just an integer or an array of a different type)
specify the actual type of the value of the argument, e.g
</p>
<pre id="263">
(def-foreign-call foo ((x (* :char) integer)) 
                  :returning ((* char) integer))

;; or

(def-foreign-call foo ((x (* :char) 
                          (simple-array (unsigned-byte 8) (*)))))
</pre>
<p id="264">
If you have an address of a C string, you can pass it to <a href="operators/excl/native-to-string.htm"><b>native-to-string</b></a> and a Lisp
string with the same contents will be returned. (You can specify a
string to receive the C string as a keyword argument to <a href="operators/excl/native-to-string.htm"><b>native-to-string</b></a>, as described
in the full description of that function).
</p>

<p id="265">
The function <a href="operators/ff/foreign-strlen.htm"><b>foreign-strlen</b></a> takes an address
of a C string and returns its length.
</p>

<pre id="266">
;; This example calls a foreign function, GET-MESSAGE, that
;; returns a pointer to a string.
;; The C language file getmessage.c contains:

#include &lt;stdio.h&gt;
 
char *mess=&quot;this is a test&quot;;
char *getmessage()
{
    return mess;
}
 
;; Compile the C language file and load it into Lisp.

;; GETMESSAGE returns an integer pointer to the string.
USER(12): (ff:def-foreign-call getmessage (:void) 
              :returning :int)
GETMESSAGE
USER(13): (getmessage)
8790592
;; EXCL:NATIVE-TO-STRING converts the integer returned by getmessage
;; to a string.
USER(13): (excl:native-to-string (getmessage))
&quot;this is a test&quot;
 
;; Use FOREIGN-STRLEN to find the length
;; of the string returned by GETMESSAGE.
USER(14): (ff:foreign-strlen (getmessage))
14
</pre>

<p id="267">
With the <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> foreign function
definer, one can specify string as one of the arguments. That will
cause Lisp strings to automatically be converted to C style char*
arrays at function call time.
</p>

<p id="268">
To copy a Lisp string to a C style char * string outside of using
<a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> is to use the
function <a href="operators/excl/string-to-native.htm"><b>string-to-native</b></a>.
</p>
<p id="269">
Our example passes a string to C, which calculates its length and
returns it.
</p>

<pre id="270">
:: UNIX example
;;
;; This example calls a foreign function, PUTMESSAGE, that
;; returns a pointer to a string. Note that this is a simple
;; example. PUTMESSAGE could be def-foreign-call'ed to take a
;; SIMPLE-ARRAY as an argument.
;;
;; The C language file put-message.c contains:

#include &lt;stdio.h&gt;
 
/* putmessage expects a pointer to a string as an argument.*/
/* putmessage prints that string to stdout.*/
putmessage(s)
char *s;
{
    puts(s);
    fflush(stdout);
}
 
;; Compile the C language file and load into Lisp.

;; PUTMESSAGE takes a pointer to a string (an integer) as 
;; an argument
USER(20): (ff:def-foreign-call putmessage (integer)
              :returning :void)
PUTMESSAGE
;; Create a string in lisp.
USER(21): (setf lisp-message &quot;This is a message from lisp&quot;)
&quot;This is a message from lisp&quot;
 
;; Run PUTMESSAGE with a lisp string as an argument.
USER(22): (putmessage (excl:string-to-native lisp-message))
This is a message from lisp
 
NIL
</pre>

<p id="271">
Here is the example for Windows:
</p>

<pre id="272">
;;  Windows example
;;
;;  Allegro CL makes available to C programs the function 
;;  aclprintf() which operates just like printf and the result 
;;  is printed to the Allegro Common Lisp Console.
;;  To show the console window right click on the
;;  Lisp icon on the system tray and choose Show Console.

#|

--------- the file put-message.c

extern void aclprintf(char *, ...);


void _declspec(dllexport) putmessage(char *str)
{
    aclprintf("message from lisp: '%s'\n", str);
}



|#

;; Compile the C language file and load into Lisp.

;; PUTMESSAGE takes a pointer to a string (an integer) as 
;; an argument

user(2): (ff:def-foreign-call (putmessage "putmessage")
             ((str (* :char))) :returning :void)
putmessage
user(3): (putmessage "a lisp string")
nil

;;  On the console window you see printed:

message from lisp: 'a lisp string'
</pre>

<p id="273">
You may want to pass strings from Lisp to C and from C to
Lisp. Passing strings from Lisp to C is pretty easy. A Lisp string
will be converted correctly. Passing an array of strings is more
complex. Examples of both are shown in <a href="#passing-strings-lisp-c-2">Passing strings from Lisp to
C</a> and <a href="#passing-array-of-strings-2">Special case: passing an array of
strings from Lisp to C</a>.
</p>

<hr><h2 id="274"><a name="passing-strings-lisp-c-2">5.1 Passing strings from Lisp to C</a></h2>

<p id="275">
Lisp will correctly convert Lisp strings when passing them to C and
therefore passing a string from Lisp to C is quite easy. Consider the
following example.
</p>

<p id="276">
We define a C function <strong>stringl()</strong> which takes a string
as an argument and returns its length. 
</p>

<pre id="277">
;;;   C code for UNIX:

# include &lt;stdio.h&gt;
# include &lt;string.h&gt;

int stringl(char *s)
{
    return strlen(s);
}

;; C code for Windows:

#ifdef _WIN32
#define DllExport __declspec(dllexport)
#else
#define DllExport
#endif

# include &lt;stdio.h&gt;
# include &lt;string.h&gt;

DllExport int stringl (char *s)
{
    return strlen(s);
}
</pre>

<p id="278">
We compile this function and load the resulting .so/.sl/.dll/.dylib file
into Lisp. We then call <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> as follows and
then call the C function:
</p>

<pre id="279">
user(50): (ff:def-foreign-call stringl ((string (* :char))) 
                                       :strings-convert t
                                       :returning :int)
string1
user(51): (stringl "hello")
 
5
user(52):
</pre>



<hr><h2 id="280"><a name="passing-array-of-strings-2">5.2 Special Case: Passing an array of strings from Lisp to C</a></h2>

<p id="281">
Passing an array of strings from Lisp to C is somewhat more complex,
as the next example shows. A common usage in C is typified by the
following program fragment: 
</p>

<pre id="282">
#define null 0
char *z[] = {"strings1", "string2", null};
...
    handle_strings(z);
...
handle_strings(argv)
char **argv;
{
    while( *argv != null ){
          handler_for_string(*argv);
          argv = argv + 1;
    }
}
</pre>

<p id="283">
Similar usage is also common with the array size included:
</p>


<pre id="284">
char *z[] = {"strings1", "string2", "string3"};
...
    handle_strings(3,z);
...
handle_strings(argc, argv)
      char **argv;
      int argc;
{
...
}
</pre>

<p id="285">
The variable <code>argv</code> is an array with each element
pointing to a C string in both cases. (Note, however, that in the
first case a NULL pointer terminates the array.) One may like to call
<strong>handle_strings()</strong> from Lisp (after doing a <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>) by
something like the following:
</p>

<pre id="286">
(handle_strings
    (make-array 3 
                :initial-contents 
                   '("string1" "string2" 0)))
</pre>

<p id="287">
or perhaps
</p>


<pre id="288">
(handle_strings 3 (make-array 3 
                              :initial-contents
                                '("string1" 
                                  "string2" 
                                  "string3")))
</pre>

<p id="289">
depending on the definition of <strong>handle_strings()</strong>
above. However, the foreign-function interface does not normally
convert the individual elements of a Lisp array.
</p>

<p id="290">
One can convert an array of Lisp strings to a foreign object
acceptable as a C char** argument by using a function such as that
below. Note that as written it does fresh allocations on each call, so
a user may wish to tailor it as desired. In particular, a call to
<a href="operators/excl/string-to-native.htm"><b>string-to-native</b></a> returns a
value which must be passed to <a href="operators/excl/aclfree.htm"><b>aclfree</b></a> in order to be reclaimed.
</p>

<pre id="291">
 ;; Take a lisp vector of lisp strings, and return an equivalent
 ;; foreign array of C strings.  Useful for C functions expecting
 ;; 'char **' arguments.
 ;;
 (defun lisp-string-array-to-c-string-array (a)
   (let ((r (ff:allocate-fobject (list ':array '(* :char) (length a)))))
     (dotimes (i (length a))
       (setf (ff:fslot-value-typed '(:array (* :char)) nil r i)
         (string-to-native (aref a i))))
     r))
</pre>

<p id="292">
The array-of-strings (<i>argv</i>) argument to the
foreign function can then be declared as follows:
</p>

<pre id="293">
 (ff:def-foreign-call handle_strings ((argc :int) (argv (* (* :char)))))
</pre>
<p id="294">
The foreign function can then be called as follows:
</p>

<pre id="295">
 (handle_strings 3 (lisp-string-array-to-c-string-array
                     (make-array 3 
                                 :initial-contents '("one" "two" "three"))))
</pre>
<p id="296">
Note that before the current Allegro CL deftype facilities were
available, foreign-function definers <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> and its (now
obsolete) predecessor <a href="operators/ff/defforeign.htm"><b>defforeign</b></a> were designed to
handle arrays of strings specially by use of the argument type
<code>(simple-array simple-string (*))</code>. This argument type
usage is no longer recommended, but it is documented here to describe
backward compatibility.
</p>


<p id="297">
While this is not implemented as a distinct data type in Allegro CL,
the foreign-function interface will recognize this declaration and
convert the array appropriately for C. This is a slow function call as
the interface must allocate space to do the conversion. To get the
desired behavior (e.g. for the second of the above two possibilities
for <strong>handle_strings()</strong>) you should use:
</p>

<pre id="298">
(ff:def-foreign-call handle_strings 
                      ((integer :int)
                       (string (:array (* :char))
                                (simple-array simple-string))))
</pre>

<p id="299">
Note that if you do not declare arguments - e.g. if you use:
</p>

<pre id="300">
(ff:def-foreign-call handle_strings nil)
</pre>

<p id="301">
The array will not be converted correctly on the call to
<strong>handle_strings()</strong>.  Note that this is not typical; the
interface normally converts arguments according to their Lisp data
type whether or not they are declared.
</p>

<p id="302">
If you do make this declaration and pass in an arbitrary Lisp array,
all bets are off.  Only 0 and array elements of type simple-string are
guaranteed to be correctly converted.
</p>




<hr><hr><h2 id="303"><a name="structs-by-value-1">6.0 Passing structures by value</a></h2>

<p id="304">
Structures can be passed and returned by value through the
foreign-function interface. Usually,
programmers pass structures by reference, using <code>*</code>
notation to indicate that what is being passed is a pointer to the
struct.  But in a few cases, such as with graphics objects in the
Cocoa interface, structs are passed by value.  This means that the
slots of the structs are spread out over the argument list as if they
are individual arguments, and then received in the called function
without needing a change in syntax; the fields of the struct can be
specified with dot-notation, e.g.:
</p>

<pre id="305">
typedef struct {
    float x;
    float y;
} Point;

Point *
jog_by_ref(point *pointp, float incx, float incy)
{
    pointp-&gt;x += incx;
    pointp-&gt;y += incy;
    return pointp;
}

Point
jog_by_val(Point point, float incx, float incy)
{
    point.x += incx;
    point.y += incy;
    return point;
}
</pre>

<p id="306">
In the above example, <code>jog_by_ref</code> passes and returns
a <code>Point</code> struct by reference,
and <code>jog_by_val</code> passes and returns
a <code>Point</code> struct by value.  The major difference
between the two examples is that when <code>jog_by_value</code>
returns, the <code>point</code> that was passed in has been
modified, whereas the <code>point</code> that was passed in in
<code>jog_by_val</code> has not been changed.
</p>
<p id="307">
Allowing passing and returning structs by value changes pre-8.2
behavior in a minor but incompatible fashion: previously
when <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>
and <a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a> detected the
passing of a structure, they automatically and silently converted it to
pass-by-reference.  Now they warn, though still performing the
conversion.  The old behavior can be reinstated globally (using the
variable <a href="variables/ff/s_pass-structs-by-value_s.htm"><code>ff:*pass-structs-by-value*</code></a>) or on a per call
basis, using the <i>pass-structs-by-value</i> keyword
argument to <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>
and <a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a>.
</p>
<p id="308">
Associated with passing and returning structures by value is the
variable
<a href="variables/ff/s_pass-structs-by-value_s.htm"><code>ff:*pass-structs-by-value*</code></a> and
the <i>pass-structs-by-value</i> keyword argument to
<a href="operators/ff/def-foreign-call.htm"><b>ff:def-foreign-call</b></a>. Follow
the links for more information. 
</p>
<p id="309">
Here is an example:
</p>

<pre id="310">
;; The struct Point and the functions jog_by_val and
;; jog_by_ref are defined above. Here are some possible
;; definitions in Lisp:

(ff:def-foreign-type Point
  (:struct (x :float)
           (y :float)))


;; Legacy pass-by-reference (warning issued by default):
(ff:def-foreign-call jog_by_ref ((point Point)
                                 (incx :float)
                                 (incy :float))
  :returning Point)


;; Legacy pass-by-reference (warning explicitly suppressed):
(ff:def-foreign-call jog_by_ref ((point Point)
                                 (incx :float)
                                 (incy :float))
  :returning Point
  :pass-structs-by-value nil)


;; Proper pass-by-reference (no warning, no change needed):
(ff:def-foreign-call jog_by_ref ((point (* Point))
                                 (incx :float)
                                 (incy :float))
  :returning ((* Point))
  :pass-structs-by-value nil)

;; New pass-by-value (no warning issued)
(ff:def-foreign-call jog_by_val ((point Point)
                                 (incx :float)
                                 (incy :float))
  :returning Point
  :pass-structs-by-value t)
</pre>





<hr><hr><h2 id="311"><a name="signal-handling-1">7.0 Handling signals in foreign code</a></h2>

<p id="312">
The Lisp image catches all signals from the operating system. In
particular, when an asynchronous interrupt (e.g. SIGINT on Unix)
occurs, the signal handler in Lisp sets a flag and then returns. This
flag is checked inside Lisp functions only when it is safe to do
so. If you are executing in foreign code, any signals that are
received will not be processed until some point after you return to
Lisp. So if your C code gets into an infinite loop, you won't be able
to interrupt it cleanly (you will be able to interrupt -- see
<a href="startup.htm">startup.htm</a>). This also implies that a foreign
function is not interruptible by the Lisp scheduler in implementations
that use the non :os-threads model of multiprocessing, see 
<a href="multiprocessing.htm">multiprocessing.htm</a>.
</p>

<p id="313">
If you need to be able to catch signals in foreign code, you must
establish your own signal handlers when you enter the foreign code and
restore the Lisp signal handlers before you return to Lisp. Perhaps
the easiest way to do this is to `wrap' your foreign code in a
function that takes care of these tasks. This wrapper function calls
your real function, and it returns the value returned by the real
function.
</p>

<p id="314">
Here is an example of such a function, which catches interrupts
(Signets). This example uses the signal() function for
simplicity. (Some versions of Unix supply other, more advanced,
functions.)
</p>

<pre id="315">
#include &lt;setjmp.h&gt;
jmp_buf catch;
int (*old_handler)();
 
int
wrapper(arg1, ..., argn)
...
{
    auto int return_value;
    extern int new_handler(),
    real_function();
 
    if ((return_value = setjmp(catch)) != 0)
           return return_value;
    old_handler = signal(sigint, new_handler);
    return_value = real_function(arg1, ..., argn);
    signal(sigint, old_handler);
    return return_value;
}
 
int
new_handler()
{
    signal(sigint, old_handler);
    longjmp(catch, -1);
} 
</pre>

<p id="316">
The wrapper function first calls <strong>setjmp()</strong> to
establish a C stack-frame environment for a subsequent longjmp() to
return to. (This is the C equivalent of Lisp catch and throw.) The
<strong>setjmp()</strong> function returns zero when the catch is
established; it returns the value of the second argument to
<strong>longjmp()</strong> otherwise. If the <strong>setjmp()</strong>
was the target of a <strong>longjmp()</strong> (from within the
interrupt handler), we return the value returned by the
<strong>longjmp()</strong> (here -1 to signal an abnormal
return). 
</p>

<p id="317">
The wrapper then installs the new SIGINT handler, saving the
address of the old one.  Once the interrupt handler is established,
the real function is called and we save the return value (here an
integer). Next we restore the Lisp signal handler, then return the
value returned by the real function to Lisp. 
</p>

<p id="318">
If an interrupt occurs while this C code is executing,
<strong>new_handler()</strong> gains control. It restores the Lisp
signal handler, and then jumps to the established catch: control
returns to the point of the setjmp(), which this time returns
-1. Foreign code execution is interrupted, and we cleanly return to
Lisp. 
</p>

<p id="319">
Note that the Lisp callback functions <strong>lisp_value()</strong>
and <strong>lisp_call_address()</strong> (described in
<a href="#accessing-lisp-values-2">Section 9.1 Accessing Lisp values from C: lisp_value()</a> and
<a href="#calling-lisp-from-c-2">Section 9.2 Calling Lisp functions from C: lisp_call_address() and lisp_call()</a>) should never be
called from a foreign signal handler. If your signal handler does call
<strong>lisp_value()</strong> or <strong>lisp_call_address()</strong>,
failures may occur should the Lisp need to garbage collect while in
the signal handler. The reason for this failure is that the system
stack may not have been set up to indicate a call from Lisp to
C. Also, if the signal is delivered while the garbage collector is
running, then the entire Lisp heap may be inconsistent and accesses to
the Lisp heap may result in attempting to follow pointers to
nonexistent data.
</p>

<hr><hr><h2 id="320"><a name="io-in-foreign-code-1">8.0 Input/output in foreign code</a></h2>

<p id="321">
Input and output from foreign code may require special
consideration to obtain reasonable behavior. 
</p>

<p id="322">
Because foreign output operations will be interspersed with Lisp
output operations, it is necessary to flush output in foreign code
before returning to Lisp if it is desirable to maintain synchronous
behavior. For example, if a C function writes information to the
standard output, it may not be displayed contemporaneously unless
<strong>fflush()</strong> is used before returning to Lisp.
</p>

<p id="323">
When performing input and output from Fortran, it may be necessary
to set up the Fortran I/O environment before performing any
operations. For 4.<i>n</i> BSD Unix systems, using the standard
AT&T Fortran compiler or one of its derivatives, the following
steps are necessary to perform I/O successfully. 
</p>

<p id="324">
Suppose you want to call the following simple subroutine from Allegro CL: 
</p>

<pre id="325">
  subroutine fiotest
  write(6, '("this is some fortran output.")')
  call flush(6)
  return
  end 
</pre>

<p id="326">
Because the above program contains an input/output statement, certain
subroutines from the Fortran I/O library must be loaded. (Note that
the call to subroutine <strong>fflush()</strong> is
implementation-dependent.) These subroutines initialize the I/O units
by `preconnecting' unit 5 to standard input, unit 6 to standard
output, and unit 0 to standard error. If this initialization is not
done, various errors can occur. For example, some versions of the
Fortran library routines will execute an abort() if I/O has not been
initialized, causing Lisp to dump core. Other versions merely ignore
requests for output.  Some versions will create disk files named
fort.<i>[n]</i> where <i>[n]</i> is the Fortran unit
number. The routine <strong>f_init()</strong> of the Fortran I/O
library will perform the proper initialization. This initialization
need only be done once for every Lisp session.
</p>

<p id="327">
Assuming the compiled version of the above program is contained in the
file <i>fiotest.so</i>, on a UNIX machine, here
is a transcript of how to load the program into Allegro CL:
</p>

<pre id="328">
;; After loading the Fortran subroutine and
;; the F77 and I77 
;; libraries into the Lisp
;; we use FF:DEF-FOREIGN-CALL to create a Lisp function
;; F_INIT that points to the function _f_init() in
;; the Fortran library:
USER(61): (ff:def-foreign-call f_init nil :returning :void)
F_INIT
;; We define our Fortran test subroutine to Lisp.

USER(62): (ff:def-foreign-call fiotest nil :convention :fortran
              :returning :void)
FIOTEST
;; We initialize the Fortran I/O system, . . .
USER(63): (f_init)
nil
;; . . . then call our Fortran subroutine.
USER(64): (fiotest)
This is some fortran output.
nil 
</pre>

<hr><hr><h2 id="329"><a name="lisp-from-c-1">9.0 Using Lisp functions and values from C</a></h2> 

<p id="330">
This section describes the Allegro CL facility that permits C
functions to call Lisp functions and access Lisp values. The C
functions must have been loaded into Lisp, and must have been called
from Lisp. 
</p>

<p id="331">
Because some Lisp objects may move in memory when a garbage collection
occurs, calling out to Lisp must be used with great care on the part
of the C programmer. As an example, if an array is passed to a C
function which calls out to a Lisp function and a garbage collection
occurs, then after the C function returns, the pointer to the array
will point to nothing; the array data will have moved somewhere
else. So if a C function accesses a Lisp value and calls out to Lisp,
then it is recommended that the Lisp value be registered and accessed
as described next. 
</p>

<p id="332">
Another alternative is to store the value in a location where they are
not moved.  Allegro CL supports static arrays which are guaranteed
never to move once they have been allocated (they are allocated in
foreign rather than Lisp space). Static arrays are discussed in
<a href="gc.htm">gc.htm</a>. However, static arrays are not completely
general. This section covers cases where you are interested in
accessing objects other than arrays or in types of arrays not
supported by static arrays.
</p>

<p id="333">
To give a particular example, let us say: 
</p>

<ol>
  <li id="334">You register a Lisp object (e.g. an array). (this is detailed 
    <a href="#accessing-lisp-values-2">below</a>.) </li>
  <li id="335">You use <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> to
    define a C function with return type :lisp. </li>
  <li id="336">In the C program you retrieve and use the registered Lisp value. </li>
  <li id="337">You call out to a Lisp function and a garbage collection occurs - the Lisp value in C is
    no longer valid. </li>
  <li id="338">The C function returns the Lisp value it retrieved earlier. </li>
  <li id="339">Then on the next garbage collection Lisp dies because of an illegal object reference:
    the Lisp value returned by the C function no longer points to valid data. </li>
</ol>

<p id="340">
The problem only occurs if a garbage collection happens during the
call to the Lisp function. What you should do is to make sure that any
Lisp value you return to Lisp or work with within a C function is
retrieved only after there is no possibility of calling out to a Lisp
function where a garbage collection may occur. To fix the example
above so it is safe, you should add another step after step 4: 
</p>

<blockquote>
  <blockquote>
    <p id="341">4a. Retrieve the registered Lisp value again. </p>
  </blockquote>
</blockquote>

<p id="342">
Other scenarios can be played out. For example, if C code changes
array data using an invalid array pointer, Lisp will never see the
changes, and Lisp's data space may be corrupted by the indirection
through a bad pointer. 
</p>

<p id="343">
For purposes of allowing call-backs from foreign code, Allegro CL
maintains two tables of Lisp objects: one is the function table and
the other is the value table. The Lisp program can register functions
or values by requesting that they be stored in the respective
table. The size of these tables will grow dynamically as needed (in
contrast to earlier releases where the function table could not be
increased in size). The use of these tables is explained in the
following two sections. 
</p>

<hr><h2 id="344"><a name="accessing-lisp-values-2">9.1 Accessing Lisp values from C: lisp_value()</a></h2>

<p id="345">
Before accessing a Lisp value from C, it should be registered
first. When a Lisp value is registered, an index is returned as a
`handle' on the Lisp object. A C function is provided that will return
a pointer to the Lisp object given its index. This is preferable to
passing addresses of Lisp objects to C functions, since Lisp objects
will generally move with each garbage collection. If a garbage
collection is triggered from C code - by calling back from C to Lisp -
the addresses of Lisp objects originally passed to the C function from
Lisp may become invalid. And since one will have lost one's only
handle on these Lisp objects, their addresses, there will be no way to
find their new addresses. If instead one were to pass the registration
indices of these Lisp objects, one could readily find their new
addresses using these indices following a call-back to Lisp. 
</p>

<p id="346">
Note that passing the addresses of Lisp objects to C functions is not
recommended only in those cases where a garbage-collection may be
triggered by the C code. Passing values of Lisp objects (converted to
C values by virtue of declarations made with <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>) is not
discouraged. However, some Lisp data types are passed to C as pointers
(for example, double-float data). Such data types should be registered
and passed to C by their indices if the C code might cause a garbage
collection. 
</p>

<p id="347">
The function <a href="operators/ff/register-lisp-value.htm"><b>register-lisp-value</b></a>
registers Lisp values in the value table. The function <a href="operators/ff/unregister-lisp-value.htm"><b>unregister-lisp-value</b></a> clears
the registration.
</p>

<p id="348">
Once a value is registered, the C program can obtain the value from
the value table with the C function: 
</p>

<pre id="349">
long lisp_value(index)
     int index; 
</pre>

<p id="350">
where <code>index</code> is the index of the registered value in
the value table in Lisp. This C function will always return the
current value at index even after a garbage collection has
occurred. The result value from lisp_value() will be a C pointer to a
Lisp object. Macros are provided to help C analyze the Lisp object and
convert it to something meaningful. These macros are found in the C
include file <i>lisp.h</i>, usually distributed in the
<i>home/misc/</i> directory with Allegro CL. 
</p>

<p id="351">
Note that when one passes Lisp values to foreign functions that
have been declared using <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>, most Lisp
data types are converted to corresponding C data types
automatically. When one obtains Lisp values by calling
<strong>lisp_value()</strong>, the conversion must be performed
explicitly by the foreign code. 
</p>

<p id="352">
The Lisp function <a href="operators/ff/lisp-value.htm"><b>lisp-value</b></a> may be useful for
debugging code. It simulates the C function
<strong>lisp_value()</strong>, but it may be called from within Lisp
at any time. 
</p>



<hr><h2 id="353"><a name="calling-lisp-from-c-2">9.2 Calling Lisp functions from C: lisp_call_address() and lisp_call()</a></h2>

<p id="354">
A Lisp foreign-callable must satisfy two requirements: (1) it must be
defined using the special macro <a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a>, and (2) it
must be registered via the function 
<a href="operators/ff/register-foreign-callable.htm"><b>register-foreign-callable</b></a>.
</p>





<p id="355">
Establishing a callback from foreign code into lisp is complicated for
two reasons: (1) Lisp functions observe different calling conventions
than C functions, and (2) Lisp functions (and their code vectors) will
generally move with each garbage collection. The <a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a> macro
provides a convenient mechanism for associating formal Lisp arguments
with the C arguments. Then, when a Lisp function is registered, a
small `wrapper' is created that can be called from C and which will
set up the arguments correctly for the Lisp function. This wrapper
calls the Lisp function with a single argument, a descriptor that
points to the arguments stacked by C.
</p>

<p id="356">
<a href="operators/ff/register-foreign-callable.htm"><b>register-foreign-callable</b></a> returns
a function pointer to the C wrapper thus generated. This function
pointer is valid across both garbage collections and calls to
dumplisp. Further, an index is associated with this function pointer
and is also returned as a `handle' to it. A C function is provided
that looks up the index and returns the function pointer associated
with it.
</p>



<p id="357">
The function <a href="operators/ff/register-foreign-callable.htm"><b>register-foreign-callable</b></a>
registers Lisp functions in the function table. The function <a href="operators/ff/unregister-foreign-callable.htm"><b>unregister-foreign-callable</b></a>
clears the entry from the table.
</p>




<p id="358">
If the returned function address is not used directly, the C program
can get a pointer to the registered Lisp function by using the C
function <strong>lisp_call_address()</strong>. The form is
</p>


<pre id="359">
void *lisp_call_address(int index)
</pre>

<p id="360">
where <code>index</code> is the index of the registered
function in the function table.
</p>

<p id="361">
A C program can call a Lisp function using the syntax
<code>(*f)(arg1, arg2, ..., argn)</code>, where f is the integer
returned by <strong>lisp_call_address()</strong>. It is important to
realize the `address' of a Lisp function returned by
<strong>lisp_call_address()</strong> is not the same as the address of
the Lisp function object associated with the Lisp symbol. It is not
possible to call a Lisp function directly from C, one must always use
the `wrapper' provided by <a href="operators/ff/register-foreign-callable.htm"><b>register-foreign-callable</b></a>.
</p>

<p id="362">
See the various appendices
(<a href="#ff-on-windows-1">Appendix A Foreign Functions on Windows</a>,
<a href="#ff-on-solaris-1">Appendix B Building shared libraries on Solaris</a>,

<a href="#ff-on-linux-1">Appendix C Building shared libraries on Linux</a>,
<a href="#ff-on-freebsd-1">Appendix D Building shared libraries on FreeBSD</a>,
<a href="#ff-on-macosx-1">Appendix E Building shared libraries on Mac OS X</a>) for information on
creating Shared Object/Library/DLL etc. files suitable for including
compiled foreign code in Lisp and also see
<a href="#creating-so-referring-to-acl-2">Section 1.9 Creating Shared Objects that refer to Allegro CL Functionality</a>.
</p>

<p id="363">
For example, say we have loaded the compiled C file: 
</p>


<pre id="364">
void c_calls_lisp(fun, index)
     long (*fun)();
{
     void (*lisp_call)(void),*lisp_call_address();
     (*fun)(); 
      /* direct call to lisp function */
     lisp_call = lisp_call_address(index);
     (*lisp_call)();
      /* call to lisp function using index */
} 
</pre>

<p id="365">
and had the following session in Lisp: 
</p>

<pre id="366">
USER(70): (setq called 0)
0
USER(71): (defun-foreign-callable lisp-talks ()
             (format t "This is lisp called for ~
                        the ~:r time.~%"
               (setq called (1+ called))))
lisp-talks
USER(72): (progn
           (multiple-value-setq (ptr index prev-ptr)
             (register-foreign-callable 'lisp-talks))
           (list ptr index prev-ptr))
(1404302 0 nil)
;; ptr is 1404302, index 0 in
;; function table, previous function none
USER(73): (ff:def-foreign-call c_calls_lisp (integer fixnum) :returning :void)
C_CALLS_LISP
USER(74): (c_calls_lisp ptr index)
This is Lisp called for the first time.
This is Lisp called for the second time. 
</pre>



<p id="367">
<strong>Note</strong>: the address returned by <a href="operators/ff/register-foreign-callable.htm"><b>register-foreign-callable</b></a> will be
valid, even after a gc or a <a href="operators/excl/dumplisp.htm"><b>dumplisp</b></a>, so you can use that rather than
<strong>lisp_call_address()</strong> if you
wish. <strong>lisp_call_address()</strong> is very efficient and its
main advantage is that address can be bignums and so storing and
working with them rather than working with indexes (which are always
fixnums) can be less efficient.
</p>


<p id="368">
The C representation and the Lisp representation of data types are
not necessarily the same. When a C function calls a Lisp function, the
Lisp function needs to have its arguments declared so that it `knows'
what the C arguments were and how to convert them.  This declaration
scheme is implemented in a macro <a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a>. 
For this reason it is important to properly prototype the function
pointer you will be using to call the lisp callback.  C uses default
argument types for unprototyped, or old-style, no arglist, prototypes.
Unexpected results or errors will likely occur if you do not properly
prototype the function pointer.

</p>

<p id="369">
We give an example: say that we define the following C function,
compile it and load it into Lisp: 
</p>


<pre id="370">
void add(x, y, index)
int x, y, index;
{
    void (*lisp_call)(int, int),*lisp_call_address();
    lisp_call = lisp_call_address(index);
    (*lisp_call)(x, y);
} 
</pre>

<p id="371">
Then the following Lisp session could take place: 
</p>

<pre id="372">
USER(80): (ff:def-foreign-call add (integer integer fixnum)
             :returning :void)
ADD
USER(81): (defun-foreign-callable add-two-c-args
              ((x :signed-long) (y :signed-long))
              (setq xy (+ x y)))
   ;; set a global variable
   ;; to the sum of x and y
ADD-TWO-C-ARGS
USER(82): (setq index (cadr (multiple-value-list
                             (register-foreign-callable 
                                'add-two-c-args))))
1
USER(83): (add 4 5 index) ;; call to the foreign function
nil
USER(84): xy
;; test the value of the
;; global variable xy
9 
</pre>

<p id="373">
Note that in the example above, we get exactly the same result by
omitting the type declarations for the function add-two-c-args -
i.e. we could have defined it as: 
</p>

<pre id="374">
(defun-c-callable add-two-c-args (x y)
     (setq xy (+ x y))) 
</pre>

<p id="375">
since the default is to assume the arguments are signed-longs. 
</p>



<hr><h2 id="376"><a name="calling-foreign-callables-2">9.3 Calling foreign callables from Lisp</a></h2>

<p id="377">
A foreign-callable (defined via <a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a> or the
deprecated <a href="operators/ff/defun-c-callable.htm"><b>defun-c-callable</b></a>) is meant to
be called by a foreign function. The arguments are converted
explicitly by the foreign-callable from foreign argument types to Lisp
types, and the return value is possibly converted from Lisp to an
appropriate foreign type, if specified. However, there may be times
when such code needs to be debugged, and the user wishes to call the
foreign-callable directly from Lisp for such purposes. 
</p>

<p id="378">
The function called <strong>lisp-call</strong>, which existed in
some earlier releases, has been removed, and instead, the user can
simply call the foreign-callable directly from Lisp. The
foreign-callable now uses a dual-entry-point technique, which allows
the Lisp call to be caught and the arguments pre-converted before
making the "real" call to the body of the
foreign-callable. 
</p>

<p id="379">
It is important to understand the pre-conversion technique used in a
foreign-callable Lisp call; it depends not on the declared arguments
in the foreign-callable, but in the actual arguments passed to the
foreign-callable from Lisp. Lisp calls to foreign callables convert
all arguments in the following way: 
</p>

<table border="0" width="95%">
  <tr>
    <td width="17%"><strong>fixnum</strong></td>
    <td width="83%">arithmetic shifted to create a 30-bit integer</td>
  </tr>
  <tr>
    <td width="17%"><strong>bignum</strong></td>
    <td width="83%">reassembled into 32-bit integer, properly sign-extending but truncating
    any LS Bits beyond 32.</td>
  </tr>
  <tr>
    <td width="17%"><strong>single-float</strong></td>
    <td width="83%">unboxed to float</td>
  </tr>
  <tr>
    <td width="17%"><strong>double-float</strong></td>
    <td width="83%">unboxed to double </td>
  </tr>
  <tr>
    <td width="17%"><strong>character</strong></td>
    <td width="83%">converted to char (within an int) type</td>
  </tr>
  <tr>
    <td width="17%"><strong>other</strong></td>
    <td width="83%">not converted</td>
  </tr>
</table>

<p id="380">
A Lisp call to a foreign-callable will never reconvert its return
value, because it always returns a Lisp value (for foreign-callables
that have been registered to convert their return values, it is
actually the callback mechanism that performs the conversion, and not
the foreign-callable itself). 
</p>

<p id="381">
Note that these conversions are not as extensive as the general
conversions done in foreign calls; this mechanism is intended as only
a quick debug tool. For more extensive callback testing, define an
actual foreign function with explicit argument types which calls back
to Lisp. 
</p>




<hr><hr><h2 id="382"><a name="ff-on-windows-1">Appendix A: Foreign Functions on Windows</a></h2>

<p id="383">
This section contains notes on foreign functions for the UNIX Allegro CL
programmer porting to Windows. We recommend using Microsoft Visual C++
(MSVC++). 
</p>

<p id="384">
The steps to using foreign functions on Windows are: 
</p>

<ol>
<li id="385">
Make a <em>.dll</em> of your C files, including:
<ol type="a" start="1">
<li id="386">
declare the correct calling convention for functions externally
visible to Lisp,
</li>
<li id="387">
prevent C++ name mangling,
</li>
<li id="388">
import the symbols you want to use from other <em>.dll</em>s,
</li>
<li id="389">
export the symbols you want to use from Allegro CL (so they are
visible to <a href="operators/ff/get-entry-point.htm"><b>get-entry-point</b></a>), and
</li>
<li id="390">
compile and link the C files properly.
</li>
</ol>
</li>
<li id="391">
Load the <em>.dll</em> into Allegro CL.
</li>
<li id="392">
Define the Lisp side of the foreign function linkage using <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> and
<a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a>.
</li>
</ol>

<h3 id="393">
DLL file cannot be changed while it is loaded into a program
</h3>

<p id="394">
Please note that you cannot create a new <i>.dll</i> with the same
name as a <i>.dll</i> file already loaded into Lisp (or loaded into
another program). If you have a <i>.dll</i> file loaded into lisp, use
<a href="operators/ff/unload-foreign-library.htm"><b>unload-foreign-library</b></a> to unload it
before recreating it and loading it again.
</p>

<hr><h2 id="395"><a name="making-a-dll-2">Appendix A.1 Making a .dll</a></h2>

<p id="396">
To access C++ functions from Lisp you must ensure C++ name mangling
does not occur. The easiest way to do this is to use a file extension
of <em>.c</em> instead of <em>.cpp</em>.  If you must use the
<em>.cpp</em> file extension, then use the <code>extern
"C"</code> linkage specification, like this:
</p>

<pre id="397">
	extern "C"
	int foo (int a) {
	    return (a + 1);
	}
</pre>

<p id="398">
Import the symbols you need from other libraries by specifying the
<em>.lib</em> file to the linker. There are two important entry points
in <i>acl[version].dll</i> (<em>[version]</em> changes
with each release of Allegro) which users of the foreign function
interface might need: <code>lisp_call_address</code> and
<code>lisp_value</code>. To use these entry points from your
<em>.dll</em>, you must import the symbols using the linker using
<i>acl[version].lib</i> provided in the Allegro directory. For
example, to compile the example in 
<a href="#calling-lisp-from-c-2">Section 9.2 Calling Lisp functions from C: lisp_call_address() and lisp_call()</a> above,
you would need to specify <em>acl[version].lib</em> on your
<em>cl</em> command line, like this (assuming the function
<code>c_calls_lisp</code> is in the file <em>foo.c</em>):
</p>

<pre id="399">
cl -D_MT -MD -LD -Fefoo.dll foo.c
   <em>[Allegro CL directory]</em>\acl<em>[version]</em>.lib
user32.lib gdi32.lib
   kernel32.lib comctl32.lib comdlg32.lib
   winmm.lib advapi32.lib msvcrt.lib
</pre>

<p id="400">
After evaluating <code>(load "foo.dll")</code> in Lisp, the
rest of the session in
<a href="#calling-lisp-from-c-2">Section 9.2 Calling Lisp functions from C: lisp_call_address() and lisp_call()</a> is the same.
</p>

<p id="401">
The general issue of cross linking is discussed in 
<a href="#creating-so-referring-to-acl-2">Section 1.9 Creating Shared Objects that refer to Allegro CL Functionality</a> above.
</p>

<p id="402">
Export the symbols you want to be visible from Lisp by using a linker
<em>.def</em> file, or by using the
<code>_declspec(dllexport)</code> declaration:
</p>

<pre id="403">
	extern "C" _declspec(dllexport)
	int foo (int a) {
	    return (a + 1);
	}
</pre>

<p id="404">
Lastly, compile and link your C code into a <em>.dll</em>: 
</p>

<ul>
  <li id="405">use the <code>-D_MT</code> C compiler option to compile your C code
    to insure the compilation will produce multi-threaded safe C code,</li>
  <li id="406">use the <code>-MD</code> linker option to link your object files to
    insure you link with the multi-threaded safe C runtime libraries,</li>
  <li id="407">use the <code>-LD</code> linker option to produce a <em>dll</em>
    instead of an <em>exe</em>, and</li>
  <li id="408">link with libraries <em>user32.lib</em>, <em>gdi32.lib</em>, <em>kernel32.lib</em>, <em>comctl32.lib</em>,
    <em>comdlg32.lib</em>, <em>winmm.lib</em>, <em>advapi32.lib</em>, and <em>msvcrt.lib</em>
    (you may not use external symbols from each of these libraries, but it does no harm to
    link against them all--it is the complete list of Windows libraries that you might need).</li>
</ul>



<hr><h2 id="409"><a name="making-fortran-dll-2">Appendix A.2 Making a Fortran .dll</a></h2>

<p id="410">
Open Watcom open source project (<a href="http://www.openwatcom.org/">http://www.openwatcom.org/</a>)
FORTRAN needs the following steps to work with Allegro CL. Watcom
allows for several calling sequences, but only one style is compatible
with the argument and return value passing that Allegro CL uses to be
compatible with Windows C++. To achieve this, the
<code>/sc</code> option must be used to specify stack-based
argument passing, and the following pragma must be used (starting in
column 1):
</p>

<pre id="411">
*$pragma aux <em>floatfunc</em> value [8087]
</pre>

<p id="412">
for each <em>floatfunc</em> in the source that returns a float
value. Our experience is that these pragmas may cause warning messages
on other architectures, but will otherwise work without causing
errors.
</p>

<p id="413">
Also, a file with a <em>.lnk</em> extension should be created, which
specifies the link options; advanced Fortran users may want to specify
link options on the command line, however. For our example, we will
describe a file called bar.lnk:
</p>

<blockquote>
  <pre id="414">
system nt_dll initinstance terminstance
import calltolisp 'call_lisp.dll'
export floatfunc
export funca
export funcb
file bar
</pre>
</blockquote>

<p id="415">
Note that exports are necessary for each function that will be
accessed from the Lisp side. Also, it is possible to call-back into
Lisp from Fortran, though it must be done indirectly through a C
function in a specified .dll file.
</p>

<p id="416">
Once the source files are set up, the following commands can be run:
</p>

<blockquote>
  <pre id="417">wfc386 /bd /ms /sc /fpi87 bar.f
wlink @bar
wlib bar +bar.dll</pre>
</blockquote>



<hr><h2 id="418"><a name="lisp-side-of-ff-2">Appendix A.3 The Lisp side of foreign functions</a></h2>


<h3 id="419">Compatibility</h3>

<p id="420">
As on UNIX, foreign functions are defined to Lisp using <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>. The
older (and now obsolete) <a href="operators/ff/defforeign.htm"><b>defforeign</b></a> interface works. When
a foreign function defined with <a href="operators/ff/defforeign.htm"><b>defforeign</b></a> is called directly, it
acts (with respect to threads) as if it was declared with the
<code>:release-heap :never</code>
option. (<i>release-heap</i> is a keyword argument to
<a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> but not to
<a href="operators/ff/defforeign.htm"><b>defforeign</b></a>.) Use the
<code>:call-direct</code> argument to <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>, as well as
other necessary arguments, to allow direct C calling to be compiled
inline by the Lisp compiler.
</p>

<p id="421">
Windows usually expects callbacks to be declared
<code>:stdcall</code>. You should check your Windows
documentation carefully to verify the required calling
convention. From the Lisp side, you will need to use a declaration
to <a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a>:
</p>

<pre id="422">
(declare (:convention {:c | :stdcall | :method})
         (:unwind value))
</pre>

<p id="423">
The <code>(:unwind </code><em>value</em><code>)</code>
declaration says that throwing past this boundary is to be performed
by returning <em>value</em> (<b>not</b> evaluated) to the C caller
after arranging when control eventually returns to the
Lisp-that-called-C-before-this-callback, the throw will be continued
from that point.  This effect does not require any special action on
the part of the Lisp-to-C calling code, except that it had to have
been built with a C link (no leaf calls).
</p>

<p id="424">
Absence of an <code>:unwind</code> declaration is equivalent to
having <code>(declare (:unwind 0))</code>.
</p>

<p id="425">
Either <code>:c</code> or <code>:stdcall</code> can now be
used interchangeably as the value of the
<i>convention</i> on <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> definitions.
The stack will be properly updated, regardless of the style the
foreign function expects to be called with. Callbacks however, must be
declared with the proper convention.
</p>



<hr><h2 id="426"><a name="dll-complete-example-2">Appendix A.4 A complete example</a></h2>

<pre id="427">
C:\TMP&gt;<strong>type foo.c</strong>
#ifdef _WIN32
#define DllExport __declspec(dllexport)
#else
#define DllExport
#endif

DllExport int test_fun(int foo)
{
    return foo + 101;
}
</pre>

<p id="428">
Compile <em>foo.c</em> into <em>foo.dll</em>:
</p>

<pre id="429">
C:\TMP&gt;<strong>cl  -D_MT -MD -nologo -LD -Zi -W3 -Fefoo.dll foo.c user32.lib
	  gdi32.lib kernel32.lib comctl32.lib comdlg32.lib winmm.lib
	  advapi32.lib msvcrt.lib</strong>
foo.c
   Creating library foo.lib and object foo.exp
</pre>

<p id="430">Then, in Lisp:</p>

<pre id="431">
user(1): <strong>(load "foo.dll")</strong>
; Foreign loading foo.dll.
t
user(2): <strong>(ff:def-foreign-call (test "test_fun") (a))</strong>
test
user(3): <strong>(test 10)</strong>
111
user(4): 
</pre>

<p id="432">
or, using the old <a href="operators/ff/defforeign.htm"><b>ff:defforeign</b></a> interface:
</p>

<pre id="433">
user(1): <strong>(load "foo.dll")</strong>
; Foreign loading foo.dll.
t
user(2): <strong>(ff:defforeign 'test
	  :arguments '(integer)
	  :entry-point "test_fun"
	  :return-type :integer)</strong>
t
user(3): <strong>(test 10)</strong>
111
user(4): 
</pre>




<hr><hr><h2 id="434"><a name="ff-on-solaris-1">Appendix B: Building shared libraries on Solaris</a></h2>

<p id="435">
On Solaris, you must produce <em>.so</em> files which are loadable
into Allegro CL. The <em>-K pic</em> flag is optional (only on Solaris), and
creates slightly different modes of sharing when used. 
</p>
<h2 id="436">
32-bit
</h2>
<p id="437">
As an example:
</p>

<blockquote>
  <pre id="438">% cc -c -K pic foo.c
% ld -G -o foo.so foo.o</pre>
</blockquote>

<p id="439">Fortran is similar:</p>

<blockquote>
  <pre id="440">% f77 -c bar.f
% ld -G -o bar.so bar.o</pre>
</blockquote>

<p id="441">
It is often useful to use the <em>-z defs</em> option to find which
references are not yet resolved. If an undefined symbol is detected
that should be present in the Lisp (such as lisp_call_address) then
that shared-library must be included in the command line. For example,
for a call to <strong>lisp_call_address()</strong> in
<em>libacl80.so</em>:
</p>

<blockquote>
  <pre id="442">% ld -G -o foo.so foo.o libacl80.so</pre>
</blockquote>

<p id="443">
The general issue of cross linking is discussed in 
<a href="#creating-so-referring-to-acl-2">Section 1.9 Creating Shared Objects that refer to Allegro CL Functionality</a> above.
</p>

<p id="444">
<i>lisp.h</i> is an include file that describes the
format of Allegro CL Lisp objects. Because the Sparc has two ports,
32-bit and 64-bit, one of the flags <code>-DAcl32Bit</code> or
<code>-DAcl64Bit</code> must be passed into the C compiler if
<i>lisp.h</i> is used.
</p>
<h2 id="445">
64-bit
</h2>
<p id="446">
Further, for the 64-bit version, you must specify
<code>-xarch=v9</code> on the <b>cc</b> line for sparc 64-bit
and <code>-xarch=amd64</code> for amd64/x86-64/emt32. You must
also link with 64-bit libraries, which is usually done with
<code>-L/usr/lib/sparcv9</code>.
</p>

<hr><hr><h2 id="447"><a name="ff-on-linux-1">Appendix C: Building shared libraries on Linux</a></h2>

<h3 id="448">
32 bit
</h3>
<p id="449">
On Linux (either on machines with Intel or AMD processors or
machines with PowerPC processors), you must produce <em>.so</em> files
which are loadable into Allegro CL. Compile with the <em>-fPIC</em>
flag. As an example:
</p>

<blockquote>
  <pre id="450">% cc -c -fPIC foo.c -o foo.o
% ld -shared -o foo.so foo.o</pre>
</blockquote>

<p id="451">Fortran is similar:</p>

<blockquote>
  <pre id="452">% f77 -c bar.f
% ld -shared -o bar.so bar.o</pre>
</blockquote>

<p id="453">
The general issue of cross linking is discussed in 
<a href="#creating-so-referring-to-acl-2">Section 1.9 Creating Shared Objects that refer to Allegro CL Functionality</a> above.
</p>

<h3 id="454">
64 bit
</h3>

<p id="455">
Further, for the 64-bit version, you must specify
<code>-m64</code> on the <b>cc</b> line. Otherwise, follow the
32-bit instructions.
</p>


<hr><hr><h2 id="456"><a name="ff-on-freebsd-1">Appendix D: Building shared libraries on FreeBSD</a></h2>

<p id="457">On FreeBSD, you must produce <em>.so</em> files which are loadable into Allegro CL. Compile
with the <em>-fPIC -DPIC</em> flags. As an example:</p>

<blockquote>
  <pre id="458">% cc -c -fPIC -DPIC foo.c -o foo.o
% ld -Bshareable -Bdynamic -o foo.so foo.o</pre>
</blockquote>

<p id="459">Fortran is similar:</p>

<blockquote>
  <pre id="460">% f77 -c bar.f
% ld -Bshareable -Bdynamic -o bar.so bar.o</pre>
</blockquote>

<p id="461">
The general issue of cross linking is discussed in 
<a href="#creating-so-referring-to-acl-2">Section 1.9 Creating Shared Objects that refer to Allegro CL Functionality</a> above.
</p>



<hr><hr><h2 id="462"><a name="ff-on-macosx-1">Appendix E: Building shared libraries on Mac OS X</a></h2>

<p id="463">
On Mac OS X, you must produce a specific type of .dylib file which can
be loaded into Allegro CL. These are called bundle files on Mac OS X,
and are fully packaged shared libraries. Unfortunately, they may not
be reused as input to ld() once they have been created, in contrast
with shared-objects on other architectures. However, they may contain
undefined symbols, which may be resolved lazily when the
shared-objects are loaded. These may include symbols in libacl*.dylib
such as lisp_value and lisp_call_address, without having to link
against the library.
</p>
<h4 id="464">
32-bit compilation
</h4>
<p id="465">
Compile
with the <em>-dynamic</em> flag. As an example:</p>

<pre id="466">
% cc -dynamic -m32 -arch i386 -c foo.c -o foo.o
% ld -bundle /usr/lib/bundle1.o -arch i386 -flat_namespace -undefined suppress -o foo.dylib foo.o
</pre>

<p id="467">
<code>-m32 -arch i386</code> on the <b>cc</b> line and
<code>-arch i386</code> on the <b>ld</b> line indicate 32-bit.
</p>

<h4 id="468">
64-bit compilation
</h4>
<p id="469">
Since 64-bit is the default, it does not additional flags. Compile
with the <em>-dynamic</em> flag. As an example:</p>

<pre id="470">
% cc -dynamic -c foo.c -o foo.o
% ld -bundle /usr/lib/bundle1.o -flat_namespace -undefined suppress -o foo.dylib foo.o
</pre>

<p id="471">Fortran interfacing is not supported at this time.</p>


<p id="472">
The general issue of cross linking is discussed in 
<a href="#macosx-shared-3">Section 1.9.1 Linking to Allegro CL shared library on Mac OS X</a>.
</p>

<p id="473">
<i>lisp.h</i> is an include file that describes the
format of Allegro CL Lisp objects. Because the Mac OS X has two ports,
32-bit and 64-bit, one of the flags <code>-DAcl32Bit</code> or
<code>-DAcl64Bit</code> must be passed into the C compiler if
<i>lisp.h</i> is used.
</p>

</body><hr><p id="2"><small>Copyright (c) 1998-2017, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page has had minimal revisions compared to the 10.0 page.</small><br><small>Created 2017.2.15.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Minimally revised from 10.0.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/foreign-functions.htm">10.0 version</a></td></tr></table></html>