<html><head><meta name="viewport" content="width=device-width, initial-scale=1"> <meta http-equiv="content-type" content="text/html; charset=UTF-8"> <link rel="stylesheet" href="acldoc-styles.css" type="text/css"><title>Compiling</title></head><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/compiling.htm">10.0 version</a></td></tr></table><h1 id="2">Compiling</h1><p id="3">This document contains the following sections:</p><a href="#images-without-1">1.0 Lisp images without a compiler</a><br><a href="#compile-file-1">2.0 compile-file</a><br>&nbsp;&nbsp;&nbsp;<a href="#defining-persistence-2">2.1 Persistence of defining forms encountered by compile-file</a><br>&nbsp;&nbsp;&nbsp;<a href="#fasl-files-2">2.2 Fasl files</a><br><a href="#compiling-ind-forms-1">3.0 Compiling individual forms or groups of forms</a><br><a href="#compiler-warnings-1">4.0 Compiler warnings: undefined function, inconsistent name usage, unreachable code</a><br><a href="#eof-1">5.0 EOF encountered error</a><br><a href="#variables-cf-1">6.0 Variables which control information printed by compile-file</a><br><a href="#file-types-1">7.0 File types</a><br><a href="#decl-opts-1">8.0 Declarations and optimizations</a><br>&nbsp;&nbsp;&nbsp;<a href="#current-settings-2">8.1 Examining the current settings and their effect</a><br>&nbsp;&nbsp;&nbsp;<a href="#declared-fixnums-2">8.2 Declared fixnums example</a><br>&nbsp;&nbsp;&nbsp;<a href="#arg-count-2">8.3 Argument count checking example</a><br>&nbsp;&nbsp;&nbsp;<a href="#arg-type-2">8.4 Argument type for a specialized function example</a><br>&nbsp;&nbsp;&nbsp;<a href="#bound-sym-ex-2">8.5 Bound symbol example</a><br>&nbsp;&nbsp;&nbsp;<a href="#tail-merge-disc-2">8.6 Tail merging discussion</a><br>&nbsp;&nbsp;&nbsp;<a href="#change-opt-sw-2">8.7 Changing compiler optimization switch settings</a><br>&nbsp;&nbsp;&nbsp;<a href="#verify-decl-2">8.8 Verifying declarations</a><br>&nbsp;&nbsp;&nbsp;<a href="#sw-t-or-nil-2">8.9 Switch can be t or nil meaning always on or always off</a><br>&nbsp;&nbsp;&nbsp;<a href="#trusted-type-2">8.10 The excl:trusted-type declaration</a><br><a href="#choose-speed-safety-1">9.0 Pointers for choosing speed and safety values</a><br>&nbsp;&nbsp;&nbsp;<a href="#opt-for-fast-fp-2">9.1 Optimizing for fast floating-point operations</a><br>&nbsp;&nbsp;&nbsp;<a href="#supported-ops-2">9.2 Supported operations</a><br><a href="#decl-help-1">10.0 Help with declarations: the :explain declaration</a><br><a href="#other-decl-opt-1">11.0 Other declarations and optimizations</a><br>&nbsp;&nbsp;&nbsp;<a href="#inline-ignored-2">11.1 Inline declarations ignored</a><br>&nbsp;&nbsp;&nbsp;<a href="#defstruct-acc-2">11.2 Defstruct accessors</a><br>&nbsp;&nbsp;&nbsp;<a href="#stack-consing-2">11.3 Stack consing, avoiding consing using apply, and stack allocation</a><br>&nbsp;&nbsp;&nbsp;<a href="#adding-typep-trans-2">11.4 Adding typep-transformers</a><br>&nbsp;&nbsp;&nbsp;<a href="#tpl-forms-2">11.5 Compiler handling of top-level forms</a><br>&nbsp;&nbsp;&nbsp;<a href="#misspellings-2">11.6 Warnings are signaled for misspelling in type declarations</a><br><p id="4">The Common Lisp standard requires that a Common Lisp system have a
compiler and a loader. Since running interpreted code in any Common
Lisp system is slow compared to running compiled code, most users will
want to compile functions after trying them out in interpreted mode. A
compiled function will run many times faster than its interpreted
counterpart. </p><p id="5">There are several implementation-dependent facets to a Common Lisp
compiler. These include the naming of source and object files, how
declarations are handled, and how floating-point and other
optimizations are performed. These issues are discussed in this
document.</p><p id="6">
Symbols relating to the compiler that are not standard CL symbols
(like <a href="../ansicl/dictentr/compile.htm"><b>cl:compile</b></a>) are
typically in the <code>:compiler</code> package.
</p><hr><hr><h2 id="7"><a name="images-without-1">1.0 Lisp images without a compiler</a></h2>

<p id="8">
Building an image with <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> (see
<a href="building-images.htm">building-images.htm</a>) with <em>include-compiler</em>
&nbsp;<code>nil</code> (or <em>include-compiler</em> true and
<em>discard-compiler</em> also true) results in a compilerless Lisp
image.
</p>

<p id="9">
Standard runtime images (see <a href="runtime.htm">runtime.htm</a>) may not
have the compiler included. In such images, it is an error to call
<a href="../ansicl/dictentr/compile.htm"><b>compile</b></a> or <a href="../ansicl/dictentr/compile-.htm"><b>compile-file</b></a> directly or indirectly. The value
of the <a href="variables/excl/s_compiler-not-available-warning_s.htm"><code>*compiler-not-available-warning*</code></a> (discussed
further below) variable is ignored in standard runtime images and thus
does not affect whether or not an error is signaled. The condition
signaled is <code>runtime-restriction</code>. 
</p>

<p id="10">
The remainder of this section discusses images which are not standard
runtime images.
</p>

<p id="11">It is possible to load the compiler into a compilerless image. You
do so by evaluating <code>(require :compiler)</code>. However, it may
be difficult or impossible to compile everything that would have been
compiled had the compiler been present earlier (difficult or
impossible because you do not know what the things are). Therefore,
parts of Lisp will run slower than necessary after the compiler is
loaded with no space saving (since you loaded the compiler). In short,
if you intend to use the compiler, start with an image that includes
it!</p>

<p id="12">But note that you can build an image with the compiler included
during the build and discarded after the build completes. This might
be very useful when creating an application for distribution when you
are not licensed to distribute an image with the compiler. If you
specify :include-compiler <code>t</code> and
:discard-compiler <code>t</code> in a call to <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> or <a href="operators/excl/generate-application.htm"><b>generate-application</b></a> (which accepts
build-lisp-image arguments), the compiler will be present while the
image is built and discarded at the end. Thus, things like applying
advice (see <a href="fwrappers-and-advice.htm">fwrappers-and-advice.htm</a>) can be done
and compiled during the build. (Note that the new fwrapper facility,
described in the same document, works with objects that can be
pre-compiled.)</p>

<p id="13">If you use a compilerless Lisp, the system will (in the default)
print a warning every time you or the system tries to call <a href="../ansicl/dictentr/compile.htm"><b>compile</b></a>. For example, consider the
following script from a compilerless Lisp image:</p>

<pre id="14">
USER(1): (defun foo nil nil)
FOO
USER(2): (compile 'foo)
Warning: Compiler not loaded -- function left uncompiled
NIL
NIL
NIL
USER(3):
</pre>

<p id="15">
The text of the warning changes according to what the system was
unable to compile. We emphasized that <a href="../ansicl/dictentr/compile.htm"><b>compile</b></a> can be called by the system since some
operations, including calling <a href="operators/excl/advise.htm"><b>advise</b></a> under certain circumstances, calling
the (obsolete) function <a href="operators/ff/defforeign.htm"><b>defforeign</b></a> (but not calling its
replacement macro <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>) in a
<em>fasl</em> file, and doing non-standard method combinations in CLOS
or MOP usage, do cause the compiler to be called and the warning to be
printed. It is possible to suppress these warnings, either globally or
locally. The variable <a href="variables/excl/s_compiler-not-available-warning_s.htm"><code>*compiler-not-available-warning*</code></a> controls
whether the warning is printed or not.
</p>

<p id="16">
We do not recommend setting <a href="variables/excl/s_compiler-not-available-warning_s.htm"><code>*compiler-not-available-warning*</code></a> to <code>nil</code> because interpreted code will run significantly
more slowly than compiled and users should know when the compiler was
called so they can expect degraded performance.
</p>

<p id="17">
It is possible to suppress the warning locally. The warnings
actually signal the condition <a href="classes/excl/compiler-not-available-warning.htm"><code>compiler-not-available-warning</code></a>. Thus, it is
possible to suppress these warnings by wrapping the following code
around sections likely to produce such unwanted warnings:
</p>

<pre id="18">(handler-bind ((excl:compiler-not-available-warning
 #'(lambda (c) (declare (ignore c)) (muffle-warning))))

&lt;code-which--may-directly-or-indirectly-calls-compile&gt;)
</pre>

<p id="19">Note again that it is possible to build an image with the compiler
included during the build and discarded at the end. Things processed
during the build will be processed with the compiler but the final
image will not have it (and thus suitable for delivery when the
license does not permit distribution of images containing the
compiler, such as standard runtime images, see
<a href="runtime.htm">runtime.htm</a>). See the description of the
<em>include-compiler</em> and <em>discard-compiler</em> arguments to
<a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> in
<a href="building-images.htm">building-images.htm</a>.</p>

<hr><hr><h2 id="20"><a name="compile-file-1">2.0 compile-file</a></h2>

<p id="21">
The Common Lisp function <a href="../ansicl/dictentr/compile-.htm"><b>compile-file</b></a> is used to compile a file
containing Common Lisp source code. We describe that function here to
point out some Allegro-CL-specific arguments. The link above is to the
ANSI description.
</p>

<hr><h3 id="22"><a name="compile-file-op-bookmarkxx"></a>compile-file</h3><h3 id="23">Function</h3><h4 id="24">Package: common-lisp</h4>

<p id="25"><b>Arguments: </b><i>
input-filename 
</i>&amp;key <i>output-file xref verbose print fasl-circle load-after-compile</i> (<i>script</i> t)</p>

<p id="26">
This function returns three values. The first value is the truename of
the output file, or <code>nil</code> if the file could not
be created. The second value is <code>nil</code> if no
compiler diagnostics were issued, and true otherwise. The third value
is <code>nil</code> if no compiler diagnostics other than
style warnings were issued. If the third returned value is
true, there were serious compiler diagnostics
issued or the other conditions of type <code>error</code> or type
<code>warning</code> were signalled during compilation.
</p>
<p id="27">
This function will compile the Common Lisp forms
in <em>input-filename</em>. <em>input-filename</em> must be a
pathname, a string, or a stream (earlier versions of Allegro CL
accepted a symbol as the filename argument but this is now explicitly
forbidden by the ANSI standard).
</p>
<p id="28">
<b><i>input-filename</i></b> is merged
with <a href="../ansicl/dictentr/default-.htm"><code>*default-pathname-defaults*</code></a>. If the
<b><i>input-filename</i></b> name has no type, then
<strong>compile-file</strong> uses the types in the
list <a href="variables/system/s_source-file-types_s.htm"><code>*source-file-types*</code></a>. The name of the output
file may be specified by the <b><i>output-file</i></b>
keyword argument. The default type of the output file is specified by
the variable <a href="variables/excl/s_fasl-default-type_s.htm"><code>*fasl-default-type*</code></a>.
</p>
<p id="29">
The output file will have a text header (readable, e.g., by the Unix
command <strong>head</strong>) which provides information such as the
time of creation and the user who created the file.
</p> 

<p id="30">
The
<b><i>xref</i></b> keyword argument is a boolean that controls whether
cross-referencing information is stored in the output file. The
default value of the <b><i>xref</i></b> keyword argument is the value of
<a href="variables/excl/s_record-xref-info_s.htm"><code>*record-xref-info*</code></a>.
</p>
<p id="31">
The <b><i>verbose</i></b> keyword argument is a boolean that controls
printing of the filename that is currently being compiled. The default
value of the <b><i>verbose</i></b> keyword argument is the value of <a href="../ansicl/dictentr/compile0.htm"><code>*compile-verbose*</code></a>. 
</p>
<p id="32">
The <b><i>print</i></b> keyword argument is a boolean that controls whether
<strong>compile-file</strong> prints the top-level form currently
being compiled. The default value of the <b><i>print</i></b> keyword
argument is the value of <a href="../ansicl/dictentr/compile0.htm"><code>*compile-print*</code></a>.
</p>
<p id="33">
The <b><i>fasl-circle</i></b> keyword argument is an Allegro CL extension
(i.e. may not be supported in versions of Common Lisp other than
Allegro CL). If the value of this argument is <code>nil</code>, there are two effects:
</p>


<ul>
<li id="34">
<strong>make-load-form</strong> processing is not done. CLOS instances
can be written to <b><i>fasl</i></b> files only if
<strong>make-load-form</strong> processing is done and structures are
dumped as tagged vectors (instead of using
<strong>make-load-form</strong> processing).
</li>
<li id="35">
The requirement that the compiler is required to preserve
<strong>eql</strong>-ness within a file compiled by
<strong>compile-file</strong> -- will not be met.
</li>
</ul>
<p id="36">
On the other hand, compilation speed is typically faster when this
argument is <code>nil</code>.  This argument defaults to
the value of <a href="variables/excl/s_fasl-circle-default_s.htm"><code>*fasl-circle-default*</code></a>.
</p>

<p id="37">
The <b><i>load-after-compile</i></b> keyword argument is
an Allegro CL extension (i.e. may not be supported in versions of
Common Lisp other than Allegro CL). If the value of this argument is
true (default is <code>nil</code>), the fasl (compiled
Lisp) file will be loaded when compilation completes. See also
the <a href="tpl-commands/cload.htm"><b>:cload</b></a> top-level command,
which also compiles an loads files.
</p>


<p id="38">
The <b><i>script</i></b> keyword argument, when true
(the default), allows scripts with initial lines starting with #! to
be compiled. Those lines are ignored by the Lisp compiler
when <b><i>script</i></b> is true.
</p>
<p id="39">
For example, consider the following script file test.cl:
</p>
<pre id="40">
#! /fi/cl/10.0/bin/linuxamd64.64/mlisp -#T
(format t "Hello world!~%")
</pre>

<p id="41">
When we run it in a UNIX shell, we get:
</p>

<pre id="42">
% test.cl
Hello world!
% 
</pre>
<p id="43">
Compiling it with compile-file works okay with <code>script
t</code> and fails with <code>script nil</code>:
</p>

<pre id="44">
cl-user(20): (compile-file "test.sh" :script t)
;;; Compiling file test.sh
;;; Writing fasl file test.fasl
;;; Fasl write complete
#P"/net/gemini/home/dm/test.fasl"
nil
nil
cl-user(21): (compile-file "test.sh" :script nil)
;;; Compiling file test.sh
; While file-compiling #'"test.sh" in #P"test.sh":
Error: No dispatch function defined for #\!. [file position = 2]
  [condition type: reader-error]

Restart actions (select using :continue):
 0: retry the compilation of test.sh
 1: continue compiling test.sh but generate no output file
 2: Return to Top Level (an "abort" restart).
 3: Abort entirely from this (lisp) process.
[1] cl-user(22): 
</pre>
<p id="45">
Calling Allegro CL in a UNIX script and the meaning of arguments like
-#T are described in <a href="startup.htm#starting-unix-script-3">Starting on UNIX using a shell script</a>
in <a href="startup.htm">startup.htm</a>.
</p>

<p id="46">
If a definition of an object (with a defining macro like <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a>, <a href="../ansicl/dictentr/defmacro.htm"><b>defmacro</b></a>, <a href="../ansicl/dictentr/defstruc.htm"><b>defstruct</b></a>, etc.) within a file being
compiled with <b>compile-file</b> persists in Lisp after the
compilation is complete, the definition is said to be persistent. See
<a href="#defining-persistence-2">Section 2.1 Persistence of defining forms encountered by compile-file</a> for details. The
short story is, absent explicit direction (such as with
an <a href="../ansicl/dictentr/eval-whe.htm"><b>eval-when</b></a>), the
only persistent defining form is <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a>.
</p>

<p id="47">
The <a href="tpl-commands/cf.htm"><b>:cf</b></a> top-level command
invokes <strong>compile-file</strong>. <a href="tpl-commands/cf.htm"><b>:cf</b></a> does not accept keyword arguments but
does accept multiple input-filename arguments.  <a href="tpl-commands/cf.htm"><b>:cf</b></a> reads its arguments as strings, so you
should not surround input-filenames with double quotes. Thus
</p>

<pre id="48">
:cf foo.cl 
</pre>

<p id="49">is equivalent to </p>

<pre id="50">
(compile-file "foo.cl")
</pre>

<hr>

<hr><h2 id="51"><a name="defining-persistence-2">2.1 Persistence of defining forms encountered by compile-file</a></h2>

<p id="52">
Suppose in a running Lisp, the symbols <code>foo</code> and
<code>foom</code> do not name any objects, indeed do not even
exist in any package. Consider the following file named
<i>foo.cl</i>:
</p>

<pre id="53">
;; file foo.cl begin
(in-package :user)

(defpackage :foo (:use :cl :excl))
(defmacro foom (x) x)
(defun foo (y) (cons y y))
(defclass foo () ())
(defvar foo nil)

;; file foo.cl end
</pre>

<p id="54">
We now compile the file using <b>compile-file</b>:
</p>

<pre id="55">
(compile-file "foo.cl")
</pre>

<p id="56">
After the file compilation completes, in the running Lisp, does
<code>foo</code> now name a package, a function, a class, and a
global variable? Does <code>foom</code> name a macro? 
</p>
<p id="57">
The answer is, only the package is now defined in the Lisp:
</p>
<pre id="58">
cl-user(16): (describe 'foo)
foo is a symbol.
  It is unbound.
  It is internal in the common-lisp-user package.
cl-user(17): (find-package :foo)
#&lt;The foo package&gt;
cl-user(18): (describe 'foom)
foom is a symbol.
  It is unbound.
  It is internal in the common-lisp-user package.
cl-user(19): 
</pre>
<p id="59">
The ANSI spec does not say whether defining forms persist after a
compile-file (i.e. the definition should be available in the running
Lisp when compilation is complete). The behavior of Allegro CL in
releases prior to 7.0 was uneven, with some defining forms persisting
and others not. Starting in release 7.0, the behavior is consistent:
only <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> forms
persist.
</p>
<p id="60">
We believe this new consistency will make it easier to know what the
best compilation strategy is, particularly now that we support
compiler enviroments (see
<a href="environments.htm">environments.htm</a>). Because it is easy to ensure
definitions persist by using <a href="../ansicl/dictentr/eval-whe.htm"><b>eval-when</b></a>'s, we believe that the extra
programming burden is slight.
</p>
<p id="61">
Here is a list of defining macros. Those marked with (*) persisted in
earlier releases but no longer persist. More complicated situations
are also noted:
</p>
<ul>
<li id="62">
<a href="../ansicl/dictentr/declaim.htm"><b>declaim</b></a> (*)
</li>
<li id="63">
<a href="../ansicl/dictentr/defclass.htm"><b>defclass</b></a>
</li>
<li id="64">
<a href="../ansicl/dictentr/defconst.htm"><b>defconstant</b></a>
</li>
<li id="65">
<a href="../ansicl/dictentr/define-2.htm"><b>define-compiler-macro</b></a>
</li>
<li id="66">
<a href="../ansicl/dictentr/define-c.htm"><b>define-condition</b></a>
</li>
<li id="67">
<a href="../ansicl/dictentr/define-0.htm"><b>define-modify-macro</b></a>
</li>
<li id="68">
<a href="../ansicl/dictentr/define-s.htm"><b>define-setf-expander</b></a>
(*)
</li>
<li id="69">
<a href="../ansicl/dictentr/defmacro.htm"><b>defmacro</b></a>
</li>
<li id="70">
<a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> (always
was and is now persistent)
</li>
<li id="71">
<a href="../ansicl/dictentr/defparam.htm"><b>defparameter</b></a> (special
declaration persisted, no longer does)
</li>
<li id="72">
<a href="../ansicl/dictentr/defsetf.htm"><b>defsetf</b></a> (*)
</li>
<li id="73">
<a href="../ansicl/dictentr/defstruc.htm"><b>defstruct</b></a>
</li>
<li id="74">
<a href="../ansicl/dictentr/deftype.htm"><b>deftype</b></a>
</li>
<li id="75">
<a href="../ansicl/dictentr/defparam.htm"><b>defvar</b></a> (special
declaration persisted, no longer does)
</li>
<li id="76">
<a href="../ansicl/dictentr/define-1.htm"><b>define-symbol-macro</b></a>
(*)
</li>
</ul>

<p id="77">
If you wish a defining form to persist, wrap it in an appropriate
<a href="../ansicl/dictentr/eval-whe.htm"><b>eval-when</b></a> form, such
as:
</p>
<pre id="78">
(eval-when (compile load eval) (defmacro foo ...))
</pre>

<h3 id="79">
Some examples
</h3>

<p id="80">
Definitions do not persist (absent <a href="../ansicl/dictentr/eval-whe.htm"><b>eval-when</b></a>'s) from one file to another
within a compilation unit:
</p>
<pre id="81">
;; file foo1.cl begin
(in-package :user)

(defvar *foo1* nil)
;; file foo1.cl end

;; file foo2.cl begin
(in-package :user)

(defvar *foo2* nil)

(defun bar ()
  *foo1*)
;; file foo2.cl end

cl-user(1): :cf foo1
;;; Compiling file foo1.cl
;;; Writing fasl file foo1.fasl
;;; Fasl write complete
cl-user(2): :cf foo2
;;; Compiling file foo2.cl
; While compiling bar:
Warning: Free reference to undeclared variable *foo1* assumed special.
;;; Writing fasl file foo2.fasl
;;; Fasl write complete

cl-user(3): (with-compilation-unit ()
               (compile-file "foo1.cl")
               (compile-file "foo2.cl"))
;;; Compiling file foo1.cl
;;; Writing fasl file foo1.fasl
;;; Fasl write complete
;;; Compiling file foo2.cl
; While compiling bar:
Warning: Free reference to undeclared variable *foo1* assumed special.
;;; Writing fasl file foo2.fasl
;;; Fasl write complete
#p"foo2.fasl"
t
t
cl-user(4): 
</pre>



<hr><h2 id="82"><a name="fasl-files-2">2.2 Fasl files</a></h2>

<p id="83">
Compiled Lisp files are called fasl files. ('Fasl' stands for fast
loading.) By default, compile-file creates a file with type fasl
containing the compiled Lisp code. See
<a href="#file-types-1">Section 7.0 File types</a> for information on how to
change the default type of a compiled file.
</p>
<p id="84">
Fasl files are not human readable, but they do have headers which
contain readable information, including:
</p>
<ul>
<li id="85">

The name of the file which was compiled to create the fasl file.

</li>
<li id="86">

The version of Lisp used to compile the file (including the platform type).

</li>
<li id="87">

The R/S (runtime system) number and the fasl version number. These
generally have to be the same or the file will not load into the
image.

</li>
</ul>

<p id="88">
There are 10 readable lines at the top of a fasl file. The UNIX
<b>head()</b> command will print the readable head of a fasl file
(assuming it prints the usual 10 lines by default).
</p>

<p id="89">
If you try to load an inappropriate fasl file into a Lisp image, an
error is signaled. One such error is <a href="classes/excl/file-incompatible-fasl-error.htm"><code>file-incompatible-fasl-error</code></a>, which is signaled
when you try to load a fasl file compiled in an earlier version (so
the R/S number and the fasl version do not match). Another error is
<a href="classes/excl/fasl-casemode-mismatch.htm"><code>fasl-casemode-mismatch</code></a>,
which is signaled when an attempt is made to load a file compiled in
case-insensitive-upper (ansi) into a case-sensitive-lower (modern)
mode image.
</p>





<hr><hr><h2 id="90"><a name="compiling-ind-forms-1">3.0 Compiling individual forms or groups of forms</a></h2>

<p id="91">
The macro <a href="operators/excl/ensuring-compiled-body.htm"><b>ensuring-compiled-body</b></a> is
like <a href="../ansicl/dictentr/progn.htm"><b>progn</b></a> in that it executes
its body forms sequentially, but if encountered in interpreted code, it
wraps the body in a <code>lambda</code> and passes it to
<a href="operators/excl/compile-lambda-expr-in-env.htm"><b>compile-lambda-expr-in-env</b></a>
for compilation, and then <a href="../ansicl/dictentr/funcall.htm"><b>funcall</b></a>s the result. Thus the code will be
executed compiled in all cases. No (accessible) function is
created. Surrounding code not wrapped in <a href="operators/excl/ensuring-compiled-body.htm"><b>ensuring-compiled-body</b></a> is not compiled.
</p>


<hr><hr><h2 id="92"><a name="compiler-warnings-1">4.0 Compiler warnings: undefined function, inconsistent name usage, unreachable code</a></h2>

<p id="93">
The Allegro CL compiler signals warnings when it detects potential
difficulties with the code being compiled. We describe some of these
warnings here. These are not errors and the compilation will complete
and compiled code will be produced. The warnings simply flag potential
problems, perhaps uncovering a coding error which will cause a program
problem even though the code compiles.
</p>

<p id="94">
The following condition classes are among those that might be signaled:
</p>

<ul>
<li id="95">
<a href="classes/excl/compiler-inconsistent-name-usage-warning.htm"><code>compiler-inconsistent-name-usage-warning</code></a>:
signaled whenever variable or tag names are used in a manner
inconsistent with their possibly intended usage, either unused (and
for variables, not declared ignore or ignorable), or, again for
variables, declared ignore but used.
</li>
<li id="96">
<a href="classes/excl/compiler-unreachable-code-warning.htm"><code>compiler-unreachable-code-warning</code></a>: signaled
whenever a <a href="../ansicl/dictentr/cond.htm"><b>cond</b></a>
clause or a <a href="../ansicl/dictentr/caseccas.htm"><b>case</b></a>
clause cannot be reached, presumably because of the presence of a
<code>t</code> or <code>otherwise</code> clause
before the unreachable clause.
</li>
<li id="97">
<a href="classes/excl/compiler-undefined-functions-called-warning.htm"><code>compiler-undefined-functions-called-warning</code></a>:
signaled when the compiler notices that there are calls to
not-yet-defined functions in a function being compiled. This will not
be signaled when the function is defined in the same file or is
defined within the body of <a href="../ansicl/dictentr/with-com.htm"><b>with-compilation-unit</b></a>.
</li>
<li id="98">
<a href="classes/excl/compiler-no-in-package-warning.htm"><code>compiler-no-in-package-warning</code></a>: this warning
is no longer used. Allegro Presto required files to have an <a href="../ansicl/dictentr/in-packa.htm"><b>in-package</b></a> form but Allegro
Presto is no longer supported. See <a href="loading.htm#presto-1">The Allegro Presto facility has been removed</a>
in <a href="loading.htm">loading.htm</a> for further information.
</li>
</ul>



<hr><hr><h2 id="99"><a name="eof-1">5.0 EOF encountered error</a></h2>

<p id="100">If you try to compile a file that contains an incomplete form
(because of, e.g., a missing closing parenthesis),
<strong>compile-file</strong> signals an error with condition
<code>end-of-file</code>. Consider the following file
<em>missing-paren.cl</em>:</p>

<pre id="101">
(defun foo nil nil)
(defun bar (a b) (+ a b)
</pre>


<p id="102">
The closing parenthesis is missing from the definition of
<strong>bar</strong>. When Lisp tries to compile this file, it signals
an error:
</p>

<pre id="103">
USER(3): :cf missing-paren.cl
 ; --- Compiling file /net/rubix/usr/tech/dm/missing-paren.cl ---
 ; Compiling FOO
 Error: eof encountered on stream&quot;
 #&lt;EXCL::CHARACTER-INPUT-FILE-STREAM
 #p&quot;/net/rubix/usr/tech/dm/missing-paren.cl&quot; pos 45 @ #xa99c12&gt;
 starting at position 20.
 [condition type: END-OF-FILE]

Restart actions (select using :continue):
 0: retry the compilation of /net/rubix/usr/tech/dm/missing-paren.cl
 1: continue compiling /net/rubix/usr/tech/dm/missing-paren.cl but generate no
 output file
[1] USER(4):
</pre>


<p id="104">Note the line:</p>

<pre id="105">
starting at position 20.
</pre>

<p id="106">
That indicates that the incomplete form starts at position 20 in
the file. Opening the file in Emacs and entering the command C-u 20
C-f (assuming standard keybindings, that means move forward 20
characters) should bring you to the beginning of the incomplete
form.
</p>

<hr><hr><h2 id="107"><a name="variables-cf-1">6.0 Variables which control information printed by compile-file</a></h2>

<p id="108">
The variables <a href="../ansicl/dictentr/compile0.htm"><code>*compile-print*</code></a> and <a href="../ansicl/dictentr/compile0.htm"><code>*compile-verbose*</code></a> provide the defaults for the
<b><i>print</i></b>
and <b><i>verbose</i></b> arguments to
<strong>compile-file</strong>.  Those arguments control how much
information <strong>compile-file</strong> will print out.  These
variables are a standard part of common lisp.
</p>

<hr><hr><h2 id="109"><a name="file-types-1">7.0 File types</a></h2>

<p id="110">The default source-file type in Allegro CL is <em>cl</em>. The
default compiled-file type in Allegro CL is <em>fasl</em>, which is a
mnemonic for <i>fast-loadable</i> file.  The default file types may be
changed to suit your preferences. </p>

<p id="111">The variable <a href="variables/system/s_source-file-types_s.htm"><code>*source-file-types*</code></a> is a list of pathname
types of Common Lisp source files. The initial value of this variable
is the list</p>

<pre id="112">
("cl" "lisp" "lsp" nil)
</pre>


<p id="113">This means that if no file type is specified for the argument of
<strong>compile-file</strong> (or the top-level command <a href="tpl-commands/cf.htm"><b>:cf</b></a>), files with types
<em>cl</em>, <em>lisp</em>, <em>lsp</em>, and no type will be looked
for. For example </p>

<pre id="114">
(compile-file "foo") 
</pre>

<p id="115">will cause the compiler to first look for the file <i>foo.cl</i>,
then for <i>foo.lisp</i>, the foo.lsp, and finally <i>foo</i>. Users
may want to change the value of <a href="variables/system/s_source-file-types_s.htm"><code>*source-file-types*</code></a>. Some prefer not to
allow files with no type to be looked at, since this prevents Lisp
from trying to compile inappropriate files, or even a
directory. Evaluating the form </p>

<pre id="116">
(setq sys:*source-file-types* '("cl" "lisp" "lsp"))
</pre>

<p id="117">will cause the compiler to look for files with file type <em>cl</em>, <em>lisp</em> and
<em>lsp</em>. Then </p>

<pre id="118">
(compile-file "foo") 
</pre>


<p id="119">will look for <i>foo.cl</i>, <i>foo.lisp</i>, and foo.lsp but not
<i>foo</i>. The first file found will be the one compiled. </p>

<p id="120">
If you change <a href="variables/system/s_source-file-types_s.htm"><code>*source-file-types*</code></a>, you may also wish to
change <a href="variables/system/s_load-search-list_s.htm"><code>*load-search-list*</code></a> and <a href="variables/system/s_require-search-list_s.htm"><code>*require-search-list*</code></a> so
that the functions load and require will look for files with the
desired file types as well. See <a href="loading.htm#search-lists-1">Search lists</a> and its subsections in
<a href="loading.htm">loading.htm</a> for a description of these variables.
</p>

<p id="121">When a file is compiled, a new file containing the compiled Lisp
code is created. This file will have the type specified by the
variable <a href="variables/excl/s_fasl-default-type_s.htm"><code>*fasl-default-type*</code></a>. The initial value of this
variable is "fasl". You may change its value to any string
you wish. If you change the value of this variable, you should also
modify the load and require search lists so those functions will find
the correct files. Throughout the documentation, files containing
compiled Lisp code are called fasl files and are assumed to have a
file type of <em>fasl</em>. You should understand that <em>fasl</em>
really denotes the value of <a href="variables/excl/s_fasl-default-type_s.htm"><code>*fasl-default-type*</code></a>.
</p>

<hr><hr><h2 id="122"><a name="decl-opts-1">8.0 Declarations and optimizations</a></h2>



<p id="123">Compiling Lisp code involves many compromises. Achieving very high
speed generally involves sacrificing graceful recovery from errors and
even the detection of errors. The latter may cause serious problems
such as wrong answers or errors that result from the propagation of
the original undiscovered error. On the other hand, interpreted code
is very easy to debug but is too slow for practical
applications. 
</p>
<p id="124">
Fortunately, most program needs can be satisfied on some
middle ground. The software development cycle generally begins with
interpreted code and ends with well-optimized code. Progressing
through this cycle, higher speed is achieved without significant loss
of confidence because of the increase in the correctness and
robustness of the Lisp code as development proceeds. (It is important
to note that optimizations do not affect the behavior of correct code
with expected inputs. However, it is not always easy to prove that the
inputs will always be what they are expected to be or that a complex
program is indeed `correct.') This section provides enough information
so that a programmer may make intelligent decisions about performance
compromises. <a href="#choose-speed-safety-1">Section 9.0 Pointers for choosing speed and safety values</a> further
discusses the issue. </p>

<p id="125">Among specific trade-offs in compiling code are the verification of
the number and types of arguments passed to functions, providing
adequate information for debugging, and including code to detect
interrupts. The Allegro CL compiler has been designed to be highly
parameterized. Optimizations performed by the compiler may be
controlled to a significant degree by the user. The compiler of course
supports the primitive Common Lisp safety, space, speed, debug, and
compilation-speed optimization declarations. (Allegro CL accepts
integer values between 0 and 3 inclusive, higher values representing
greater importance to the corresponding aspect of code generation.)
More significantly, Allegro CL provides a number of optimization
switches that control specific aspects of code generation. These
switches are in the form of variables that are bound to functions of
the five optimization parameters safety, space, speed, debug, and
compilation-speed.
</p>

<p id="126">
The initial values of the optimization qualities are set when Allegro
CL is built, controlled by the <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> arguments :opt-safety,
:opt-space, :opt-speed, and :opt-debug (see <a href="building-images.htm#arguments-without-inherited-defaults-1">Arguments to
build-lisp-image 2: defaults not inherited from the running
image</a> in <a href="building-images.htm">building-images.htm</a>).
</p>

<p id="127">The default values for safety, space, and speed in an image created
by <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> and in
prebuilt images supplied in the Allegro CL distribution is 1. The
default value for debug is 2. The
default value for compilation-speed is 1.</p>

<p id="128">You can set the values of the four qualities in various ways. One
way is globally, with <a href="../ansicl/dictentr/proclaim.htm"><b>proclaim</b></a> as follows: </p>

<pre id="129">
(proclaim '(optimize (safety <em>n1</em>) 
                     (space <em>n2</em>) 
                     (speed <em>n3</em>) 
                     (debug <em>n4</em>)
                     (compilation-speed <em>n5</em>)))
</pre>

<p id="130">
where <em>n1</em>, <em>n2</em>, <em>n3</em>, <em>n4</em>,
and <em>n5</em> are integers from 0 to 3.  The values may also be set
with the top-level
command <a href="tpl-commands/optimize.htm"><b>:optimize</b></a>. This command
also displays the current values of the qualities (there is no
portable way to access those values in Common Lisp).
</p>

<hr><h2 id="131"><a name="current-settings-2">8.1 Examining the current settings and their effect</a></h2>



<p id="132">
The function <a href="operators/excl/explain-compiler-settings.htm"><b>explain-compiler-settings</b></a> prints the value
that will be returned by each compiler switch if called with specific
settings of the optimization qualities. Called with no arguments, it
describes the behavior with the current settings. It takes keyword
arguments named by the optimization qualities
(<code>safety</code>, <code>space</code>,
<code>speed</code>, <code>debug</code>,
and <code>compilation-speed</code>). Values specified for those
arguments causes information on the values of compiler switches using
the specified values (and the current values, where unspecified) to be
printed.
</p>

<p id="133">The variables discussed in the remainder of this section specify
what the various settings of safety, space, speed, debug, and
compilation-speed do. Their values are functions that
return <code>t</code> or <code>nil</code> for
the given settings of safety, space, speed, debug, and
compilation-speed. You may change
the definitions by binding (or setting) the variables to new
functions. </p>

<p id="134">You can also set (or bind) a variable to <code>t</code> or <code>nil</code> and this
will be interpreted as a function that always returns <code>t</code> or <code>nil</code>
(respectively) meaning the associated switch is always on (<code>t</code>) or off (<code>nil</code>).
Any new function used should accept five arguments. The system calls the function with the
(lexically) current values of safety, space, speed debug, and
compilation-speed.</p>

<p id="135">Following the table describing the switches, we give examples of
erroneous code run interpreted (which produces the same error behavior
as running with the switches at their safest setting) and run compiled
with the switches at their least safe setting. What you will notice in
the latter case is that erroneous code either results in a less
informative error or perhaps in a wrong answer but no error. These
examples are not intended to deter you from using compiler
optimizations. Rather, we want to make you aware of the dangers of
less safe code and show what error messages to expect when the
switches are at their high speed settings. All switches are named by
symbols in the <code>compiler</code> package.
</p>



<table BORDER="1" CELLSPACING="1" CELLPADDING="7">
<tr>
<td WIDTH="40%" VALIGN="TOP"><b>Switch</b></td>
<td WIDTH="30%" VALIGN="TOP"><b>Description</b></td>
<td WIDTH="30%" VALIGN="TOP"><b>Initial value true when:</b></td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/compile-format-strings-switch.htm"><code>compile-format-strings-switch</code></a></td>
<td WIDTH="30%" VALIGN="TOP">When true, a format string (the second required argument to
format) is converted to a tree structure at compile time. If <code>nil</code>, the
conversion is done at run time, resulting in slower printing but smaller code.</td>
<td WIDTH="30%" VALIGN="TOP">True when speed is greater than space.</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/declared-fixnums-remain-fixnums-switch.htm"><code>declared-fixnums-remain-fixnums-switch</code></a></td>
<td WIDTH="30%" VALIGN="TOP">If true, the compiler will generate code that
assumes the sums and differences of declared fixnums are
fixnums and that the negative of a single declared fixnum is a fixnum.
<p id="136">
<strong>Warning</strong>: if this switch returns true during
compilation but the sum or difference of two declared fixnums or the
negative of a single fixnum is not a fixnum, the compiled code will
silently produce erroneous results. Taking the negative includes
applying <a href="../ansicl/dictentr/abs.htm"><b>abs</b></a> to a
negative fixnum. Note that <code>(- most-negative-fixnum)</code>
is a bignum. See <a href="#declared-fixnums-2">Section 8.2 Declared fixnums example</a>
below.</p></td>
<td WIDTH="30%" VALIGN="TOP">True only if speed is 3 and safety is 0.</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/generate-interrupt-checks-switch.htm"><code>generate-interrupt-checks-switch</code></a></td>
<td WIDTH="30%" VALIGN="TOP">If true, code is added at the 
beginning of the code vector
for a compiled function and at the end of a loop in a 
compiled function that checks for an interrupt
(Control-C on Unix, Break/Pause on Windows).<p id="137">Note that an infinite loop that does not
call functions will not be interruptable except by multiple Control-C's (Unix) and using
the Franz icon on the system tray (Windows). See <a href="startup.htm">startup.htm</a> for
more information on interrupting when all else fails.</p></td>
<td WIDTH="30%" VALIGN="TOP">True unless speed is 3 and safety is 0.</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/internal-optimize-switch.htm"><code>internal-optimize-switch</code></a></td>
<td WIDTH="30%" VALIGN="TOP">When true, the register-linking internal optimization is
performed, resulting in faster but harder to debug code.</td>
<td WIDTH="30%" VALIGN="TOP">

True when compilation-speed is less than 2 and either speed is
greater than 2 or debug less than
3. Returns <code>nil</code> when compilation-speed is 2 or
3 regardless of other values.
</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/optimize-fslot-value-switch.htm"><code>optimize-fslot-value-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">When true, calls to <a href="operators/ff/fslot-value-typed.htm"><b>fslot-value-typed</b></a> will be opencoded
if possible. See <a href="ftype.htm">ftype.htm</a></td>
<td WIDTH="30%" VALIGN="TOP">True when speed is greater than safety.</td>
</tr>

<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/optimize-large-functions-switch.htm"><code>optimize-large-functions-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">When true, the compiler should continue
to provide high optimization even if the function has become very
large (and thus compilation speed is reduced).
</td>
<td WIDTH="30%" VALIGN="TOP">True when compilation-speed is less that 2.</td>
</tr>


<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/save-local-names-switch.htm"><code>save-local-names-switch</code></a></td>
<td WIDTH="30%" VALIGN="TOP">If true, the names of local variables will be saved in
compiled code. This makes debugging easier.</td>
<td WIDTH="30%" VALIGN="TOP">True when debug is greater than 1.</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/save-local-scopes-switch.htm"><code>save-local-scopes-switch</code></a></td>
<td WIDTH="30%" VALIGN="TOP">If true, information about when local variables are alive is
saved in compiled code, making debugging more easy. </td>
<td WIDTH="30%" VALIGN="TOP">True only when debug is 3.</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/tail-call-self-merge-switch.htm"><code>tail-call-self-merge-switch</code></a></td>
<td WIDTH="30%" VALIGN="TOP">If true, the compiler will perform self-tail-merging (for
functions which call themselves). See <a href="#tail-merge-disc-2">Section 8.6 Tail merging discussion</a> below for more information on tail-merging.</td>
<td WIDTH="30%" VALIGN="TOP">True if speed is greater than 0.</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/tail-call-non-self-merge-switch.htm"><code>tail-call-non-self-merge-switch</code></a></td>
<td WIDTH="30%" VALIGN="TOP">If true, the compiler will perform non-self-tail-merging (for
functions in the tail position different than the function being executed). See <a href="#tail-merge-disc-2">Section 8.6 Tail merging discussion</a> below for more
information on tail-merging.</td>
<td WIDTH="30%" VALIGN="TOP">True if speed is greater than 1 and debug less than 2. (This
is more restrictive than tail-call-self-merge-switch described just above in this table
because all references to the caller function are off the stack in this case but at least
one call remains on the stack in the self-merge case.)</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/trust-declarations-switch.htm"><code>trust-declarations-switch</code></a></td>
<td WIDTH="30%" VALIGN="TOP">
If true, the compiler will trust declarations in code (perhaps other than
dynamic-extent declarations -- see next entry) and produce code (when
it can) that is optimized given the declarations. These declarations
typically specify the type of values of variables. If <code>nil</code>, declarations will be ignored except
<code>(declare notinline)</code> and <code>(declare
special)</code> which are always complied with.</td> <td WIDTH="30%" VALIGN="TOP">True if speed is greater than safety.</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/trust-dynamic-extent-declarations-switch.htm"><code>trust-dynamic-extent-declarations-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">
If true and if <a href="variables/compiler/trust-declarations-switch.htm"><code>trust-declarations-switch</code></a> is also true,
the compiler will trust dynamic-extent declarations in code and
produce code (when it can) that is optimized given the
declarations. Having a switch which controls dynamic-extent
declarations when declarations are trusted (via the
general <a href="variables/compiler/trust-declarations-switch.htm"><code>trust-declarations-switch</code></a>) allows
dynamic-extent declarations to be ignored while other declarations are
trusted. This may be desirable when using multiprocessing, as
described in <a href="#stack-consing-2">Section 11.3 Stack consing, avoiding consing using apply, and stack allocation</a>.
</td>
<td WIDTH="30%" VALIGN="TOP">
True if speed is greater than or equal to safety.
</td>
</tr>

<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/trust-table-case-argument-switch.htm"><code>trust-table-case-argument-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">
If true, the compiler will compile suitable <a href="../ansicl/dictentr/caseccas.htm"><b>case</b></a> statements in a table-driven fashion,
which is faster but less safe. See the variable description (and its
links) for details.
</td>
<td WIDTH="30%" VALIGN="TOP">
True if speed is 3 and safety is 0.
</td>
</tr>

<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/verify-argument-count-switch.htm"><code>verify-argument-count-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">If true, the compiler will add code that checks that the
correct number of arguments are passed to a function. </td>
<td WIDTH="30%" VALIGN="TOP">True if speed is less than 3 or safety is greater than 0.</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP"><a href="variables/compiler/verify-car-cdr-switch.htm"><code>verify-car-cdr-switch</code></a></td>
<td WIDTH="30%" VALIGN="TOP">If true, code calling <strong>car</strong> 
and <strong>cdr</strong>
will check that the argument is appropriate (i.e. a list). 
The switch is only effective on
platforms which have <code>:verify-car-cdr</code> on 
the <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> list.
Platforms lacking that feature ignore this switch since the 
verification is done differently but always.</td>
<td WIDTH="30%" VALIGN="TOP">True if speed is less than 3 or safety is greater than 1.</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/verify-funcalls-switch.htm"><code>verify-funcalls-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">
If false, the compiler will compile certain calls to <a href="../ansicl/dictentr/funcall.htm"><b>funcall</b></a> in such a way that the call
immediately jumps to the <a href="../ansicl/dictentr/funcall.htm"><b>funcall</b></a>'ed function's start
address. This speeds up <a href="../ansicl/dictentr/funcall.htm"><b>funcall</b></a>'ing at the cost of harder
debugging (the stepper and the runtime analyzer call-counter will not
see such calls).
</td>
<td WIDTH="30%" VALIGN="TOP">
True (i.e. slower <a href="../ansicl/dictentr/funcall.htm"><b>funcall</b></a>'s) if speed is less than 3 or
if safety is greater than 1 or if debug is greater than 0.
</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/verify-non-generic-switch.htm"><code>verify-non-generic-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">
If true, code is generated that an object of undeclared type is of the
correct type when it appears as the argument to specialized functions
like svref and rplaca. Thus the argument to svref must be a simple
vector and if this switch is true, code will check that (and give a
meaningful error message). See
<a href="#arg-type-2">Section 8.4 Argument type for a specialized function example</a> for an example. Note that
generic has nothing to do with (CLOS) generic functions. The name way
predates CLOS.
</td>
<td WIDTH="30%" VALIGN="TOP">
True for speed less than 3 or safety greater than 1.
</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/verify-symbol-value-is-bound-switch.htm"><code>verify-symbol-value-is-bound-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">
If true, code will be added to ensure that a symbol is bound before
the value of that symbol is used. The result (as shown in
<a href="#bound-sym-ex-2">Section 8.5 Bound symbol example</a> below) is that an error
with an appropriate message will be signaled in code compiled with
this switch true. In code compiled with this switch <code>nil</code>, behavior is undefined but it may be that no
error is signaled.
</td>
<td WIDTH="30%" VALIGN="TOP">
True if speed is less than 3 or safety is greater than 1.
</td>
</tr>


<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/verify-stack-switch.htm"><code>verify-stack-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">

This switch only affects platforms with
<code>:verify-stack</code> on the <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> list. On such platforms, checking
whether the stack pointer has gone beyond the stack cushion is
expensive. (A stack cushion is an artifical stack limit. If Lisp can
detect when this limit is reached, it can warn that thee stack is
about to be exhausted -- if the stack truly runs out, Lisp will fail.)
Highly recursive functions, at least, should be compiled with this
switch true since they might cause unrecoverable stack overflow. In
general, we do not recommend globally setting speed to 3 and safety to
0, which is what causes this switch to be <code>nil</code>, but instead selectively compiling functions at
that setting when it is known that having this switch nil will not
cause a problem.

</td>
<td WIDTH="30%" VALIGN="TOP">

True if speed is less than 3 or safety is greater than 0.

</td>
</tr>


<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/verify-type-declarations-switch.htm"><code>verify-type-declarations-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">
When true, any lambda or <b>let</b> bindings of the declared variable
and any <b>setq</b>s to that variable get a runtime type check to
ensure that the value is of the correct type, otherwise a continuable
type-error is generated.
</td>
<td WIDTH="30%" VALIGN="TOP">
True if safety is greater than 1.
</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/save-source-level-debug-info-switch.htm"><code>save-source-level-debug-info-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">
This switch does not affect code speed. Instead, it tells the compiler
to save information in fasl files useful for source-level debugging
(see <a href="debugging.htm#source-step-1">The source
stepper</a> in <a href="debugging.htm">debugging.htm</a>) and for
coverage analysis (see <a href="operators/excl/with-coverage.htm"><b>with-coverage</b></a>). This saved information does
not affect the actual compiled code (which will be the same whether
this switch is true or <code>nil</code>) though it does
make fasl files bigger than they otherwise would be.
</td>
<td WIDTH="30%" VALIGN="TOP">
True if debug is greater than 2.
</td>
</tr>
<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/generate-accurate-x86-float-code-switch.htm"><code>generate-accurate-x86-float-code-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">
This switch affects 32-bit x86 processors only. When true, flags are
set that ensure floating-point operations are done in a consistent
mode, so the same calculations have the same result from run to
run. When <code>nil</code>, those flags are not set so the
computation is faster but mat have different results in the lowest
bits from run to run.
</td>
<td WIDTH="30%" VALIGN="TOP">
False (faster, possibly slightly different results from run to run on
32-bit x86) only when speed is 3 and safety is 0.
</td>
</tr>


<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/align-branch-targets-switch.htm"><code>align-branch-targets-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">
This switch affects x86 64-bit platforms  only. It is ignored on all other platforms. The
value many be an integer as well and <code>t</code> or
<code>nil</code>. When true, the compiler ensures certain
code branches are optimally aligned. An integer value controls which
branches are affected. See the <a href="variables/compiler/generate-accurate-x86-float-code-switch.htm"><code>generate-accurate-x86-float-code-switch</code></a>
page for details.
</td>
<td WIDTH="30%" VALIGN="TOP">
The initial value is a function which returns true if speed is 3 and
compilation-speed is 0 or 1.
</td>
</tr>




<tr>
<td WIDTH="40%" VALIGN="TOP">
<a href="variables/compiler/verify-format-argument-count-switch.htm"><code>verify-format-argument-count-switch</code></a>
</td>
<td WIDTH="30%" VALIGN="TOP">
This switch tells the compiler whether to check <a href="../ansicl/dictentr/format.htm"><b>format</b></a> statements during compilation to
determine whether there are a sufficient number of arguments provided.
It differs from other switches in returning 6 possible values
(0, <code>nil</code>, 1, 2, <code>t</code>, 3,
and 4). 0 and <code>nil</code> mean do not checking. 1
means collect information only. 2 and <code>t</code> mean
collect information and also signal a style warning if a form with two
few arguments is encountered. 3 and 4 mean do all of 2 and also signal
a style warning for forms with too many arguments (3 and 4) and one
for forms that are too complex to evaluate (4 only).  See
the <a href="variables/compiler/verify-format-argument-count-switch.htm"><code>verify-format-argument-count-switch</code></a> page
for details.
</td>
<td WIDTH="30%" VALIGN="TOP">
The initial value is a function which returns 1 for safety 0 and
compilation-speed 0 or 1; returns 2 for safety 2 or 3 and
compilation-speed 0 or 1; and returns 0 for compilation speed 2 or 3.
</td>
</tr>


</table>


<p id="138">
Some switches are no longer used but their associated variables still
exist though setting them has no effect. The switches
are <a href="variables/compiler/generate-inline-call-tests-switch.htm"><code>comp:generate-inline-call-tests-switch</code></a>, 
<a href="variables/compiler/peephole-optimize-switch.htm"><code>comp:peephole-optimize-switch</code></a>,
and <a href="variables/compiler/save-arglist-switch.htm"><code>comp:save-arglist-switch</code></a>.
</p>





<hr><h2 id="139"><a name="declared-fixnums-2">8.2 Declared fixnums example</a></h2>

<p id="140">The following two code examples illustrate the effect of
the <a href="variables/compiler/declared-fixnums-remain-fixnums-switch.htm"><code>declared-fixnums-remain-fixnums-switch</code></a>
switch. In the first, we define a function that simply adds its two
arguments and contains declarations that both the arguments are
fixnums. When compiled with this switch
returning <code>nil</code>, the function correctly returns
the bignum resulting from the arguments in the example. When compiled
with this switch returning <code>t</code>, the function
returns a wrong answer. The second example shows that this can even
happen when taking the negative of a single fixnum or (equivalently)
taking the absolute value of a negative fixnum. <a href="../ansicl/dictentr/most-pos.htm"><code>most-positive-fixnum</code></a> and
<a href="../ansicl/dictentr/most-pos.htm"><code>most-negative-fixnum</code></a> have different
absolute values, and so taking the negative of the bigger (in absolute
value) produces a bignum.
</p>

<pre id="141">
;; This example is run in a 32-bit Lisp. The behavior would be the
;; same (with different values) in a 64-bit Lisp.
;;
USER(28): (defun frf (n m) (declare (fixnum n) (fixnum m)) 
            (+ n m))
FRF
USER(29): (setq bn (- most-positive-fixnum 20))
536870891 ;; 20 less than most-positive-fixnum
USER(30): (frf bn 50000)
536920891 ;; This value is a bignum:
USER(31): (bignump *)
T
USER(32): (proclaim '(optimize (safety 0) (speed 3)))
T
USER(33): (compile 'frf)
FRF
NIL
NIL
USER(33): (frf bn 50000)
-268385477 ;; wrong answer!
USER(34):

;; In this example, here run in a 64-bit Lisp,
;; we see (- most-negative-fixnum) is a bignum.
;; That is also true in 32-bit Lisps.

cg-user(2): (defun my-abs (value)
              (declare (optimize (speed 3) (safety 0))
                       (fixnum value))
              (abs value))
my-abs
cg-user(3): (compile *)
my-abs
cg-user(5): (my-abs most-negative-fixnum)
-1152921504606846976  ;; wrong answer, should be positive
cg-user(6): (bignump (- most-negative-fixnum))
t
cg-user(7): 
</pre>




<hr><h2 id="142"><a name="arg-count-2">8.3 Argument count checking example</a></h2>

<p id="143">Very serious errors can occur when this switch returns <code>nil</code> and the wrong number of arguments are
passed. These errors are not necessarily repeatable. We give a simple
example where you get a less than useful error message, but you should
be aware that much more serious (possibly fatal) errors can result
from code where the number of arguments are not checked. About 3
instructions (the exact number is platform dependent and ranges from 1
to 4) are added to a function call when this switch returns <code>t</code>.
</p>

<pre id="144">
USER(1): (defun foo (a b c) (+ a c))
FOO
USER(2): (foo 1 2)
 Error: FOO got 2 args, wanted at least 3.
 [condition type: PROGRAM-ERROR]
[1] USER(3): :pop
USER(4): (proclaim '(optimize (speed 3) (safety 0)))
T
USER(5): (compile 'foo)
 ; While compiling FOO:
 Warning: variable B is never used
FOO
T
T
USER(6): (foo 1)
#&lt;unknown object of type number 4 @ #x8666c&gt;
USER(7):

;;  Note you might also get an error, although not one that
;;  mentions the number of arguments.
</pre>


<p id="145">Note that no error is signaled. Note further that it is possible
for a fatal garbage collection error to result from passing the wrong
number of arguments. </p>



<hr><h2 id="146"><a name="arg-type-2">8.4 Argument type for a specialized function example</a></h2>

<p id="147">The following examples show what happens when the switch returns
<code>t</code> and when it returns <code>nil</code>.</p>

<pre id="148">
USER(39): (defun foo (vec n) (svref vec n))
FOO
USER(40): (setq v (list 'a 'b 'c 'd 'e))
(A B C D E)
USER(41): (foo v 3)
 Error: Illegal vector object passed to svref: (A B C D E)
[1] USER(42): :pop
USER(43): (proclaim '(optimize (speed 3) (safety 0)))
T
USER(44): (compile 'foo)
FOO
NIL
NIL
USER(45): (foo v 3)
 Error: Received signal number 10 (Bus error)
 [condition type: SIMPLE-ERROR]

;;  Or it might seem to work but return a bogus value.
[1] USER(46):
</pre>




<hr><h2 id="149"><a name="bound-sym-ex-2">8.5 Bound symbol example</a></h2>

<p id="150">The following example shows what happens if this switch returns <code>nil</code>. In that case, the
symbol-value location is simply read. If the symbol is in fact unbound, an apparently
valid but in fact bogus value may be obtained. In the example, that bogus value is passed
to the function + and an error is signaled because it is not a valid argument to +.
However, it may be that no error will be signaled and computation will continue, resulting
in later confusing or uninterpretable errors or in invalid results.</p>

<pre id="151">
USER(60): (defun foo (n) (+ n bar))
FOO
USER(61): (foo 1)
 Error: Attempt to take the value of the unbound variable `BAR'.
 [condition type: UNBOUND-VARIABLE]
[1] USER(62): :pop
USER(63): (proclaim '(optimize (speed 3) (safety 0)))
T
USER(64): (compile 'foo)
 ; While compiling FOO:
 Warning: Symbol BAR declared special
FOO
T
T
USER(65): (foo 1)
 Error: (NIL) is an illegal argument to +
 [condition type: TYPE-ERROR]

;;  You may see a different error.
[1] USER(66):
</pre>




<hr><h2 id="152"><a name="tail-merge-disc-2">8.6 Tail merging discussion</a></h2>

<p id="153">Consider the following function definition:</p>

<pre id="154">
(defun foo (lis)
 (pprint lis)
 (list-length lis))
</pre>


<p id="155">
When you call <strong>foo</strong> with a list as an argument, the
list is pretty printed and its length is returned. But note that by
the time <strong>list-length</strong> is called, no more information
about <strong>foo</strong> is needed but, in the interpreter at least,
the call to <strong>foo</strong> remains on the stack. The compiler
can tail merge <strong>foo</strong> in such a way that the call to
<strong>list-length</strong> is changed to a jump. In that case, when
<strong>list-length</strong> is reached the stack looks as if
<strong>list-length</strong> was called directly and
<strong>foo</strong> was never called at all. The side effects of
calling <strong>foo</strong>, in this case, pretty printing the list
passed as an argument, have all occurred by the time
<strong>list-length</strong> is called. </p>

<p id="156">Unwrapping the stack in this fashion is a benefit because it saves
stack space and can (under the correct circumstances) avoid creating
some stack frames all together. However, it can make debugging harder
(because the stack backtrace printed by <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> will not reflect
the actual sequence of function calls, but see the discussion of ghost
frames in <a href="debugging.htm">debugging.htm</a>) and it can skew
profiling data (because, looking at our example, a sample taken after
<strong>list-length</strong> is called will not charge time or space
to <strong>foo</strong> because <strong>foo</strong> is off the
stack).</p>

<p id="157">The two switches <a href="variables/compiler/tail-call-self-merge-switch.htm"><code>tail-call-self-merge-switch</code></a> and <a href="variables/compiler/tail-call-non-self-merge-switch.htm"><code>tail-call-non-self-merge-switch</code></a> control
tail merging.
</p>
<p id="158">
<a href="variables/compiler/tail-call-self-merge-switch.htm"><code>tail-call-self-merge-switch</code></a> will have an
effect when its value is true at the beginning of the function being
self-called (and no other time).  <a href="variables/compiler/tail-call-non-self-merge-switch.htm"><code>tail-call-non-self-merge-switch</code></a> has effect
only when true at the point of the call.
</p>



<hr><h2 id="159"><a name="change-opt-sw-2">8.7 Changing compiler optimization switch settings</a></h2>

<p id="160">
The user may change the code which determines how any of these
variables behaves by redefining the function which is the value of the
variable. We do not recommend changing the global value of the switch
variables as that might affect background compilations (the compiler
is called in the background for various reasons). Instead, you can
wrap the code in file in a compiler-let form or, for calling compile
at the top-level, wrap the call in a lat or let* form.
</p>
<p id="161">
The value of a switch variable should be either a function, as we
describe below, or a suitable value,  that
is <code>t</code> or <code>nil</code> for all
switches except <a href="variables/compiler/verify-format-argument-count-switch.htm"><code>comp:verify-format-argument-count-switch</code></a>
and <code>t</code>, <code>nil</code>, 0, 1, 2,
3, or 4 for that switch.
</p>
<p id="162">
A suitable function must take as arguments <em>safety</em>,
<em>space</em>, <em>speed</em>, <em>debug</em>,
and <em>compiler-speed</em>. It is important that the function be
compiled since it may be called many times during a compilation and an
interpreted function will slow down the compiler. Here is the general
form which modifies a switch variable during file
compilation. <em>var</em> identifies the switch variable you wish to
change. </p>

<pre id="163">
(compiler-let
   ((<em>var</em> 
      (compile nil '(lambda (safety space speed debug compiler-speed) 
       form-1
        ...
        form-n))))
  [definitions, etc. and forms to compile]
  )
</pre>
<p id="164">
where <code>form-n</code> returns <code>nil</code> or
<code>t</code> as a function of <em>safety</em>,
<em>space</em>, <em>speed</em>, <em>debug</em>,
and <em>compiler-speed</em>. 
</p>

<p id="165">Note that we wrapped the function definition with
<strong>compile</strong>. Note too that such a form will not affect
the compilation of the file in which it is itself compiled (since the
variable will not be redefined in time to affect the
<strong>compile-file</strong>).
</p>

<p id="166">For example, if the following code is wrapped around form to
compile in a file, the compiler will not save local scopes if speed is
greater than 1 or if debug is less than 2 or if space is greater than
1. The value of safety has no effect on the switch. </p>

<pre id="167">
(compiler-let
  ((compiler:save-local-scopes-switch
      (compile nil '(lambda (safety space speed debug)
                (declare (ignore debug))
                (cond ((&gt; speed 1) nil)
                      ((&lt; debug 2) nil)
                      ((&gt; space 1) nil)
                      (t t))))))
  ;; forms to compile
  )
</pre>


<p id="168">The initial values of safety and speed are both set during image
build (with <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a>) using the
<em>opt-speed</em>, <em>opt-safety</em>, <em>opt-space</em>,
<em>opt-debug</em>, and <em>opt-compiler-speed</em>
arguments. See <a href="building-images.htm">building-images.htm</a>.</p>



<hr><h2 id="169"><a name="verify-decl-2">8.8 Verifying declarations</a></h2>

<p id="170">
If you declare a variable to be of a particular type, as in
</p>

<pre id="171">
(defun foo (x)
  (declare (optimize (speed 3)) (fixnum x))
  (1+ x))
</pre>

<p id="172">
you are making a promise about your actions: you are promising not to
call <b>foo</b> with a non-fixnum argument. If you do call <b>foo</b>
with a non-fixnum argument (we assume the <a href="variables/compiler/trust-declarations-switch.htm"><code>trust-declarations-switch</code></a> was true, its
default behavior for speed 3), then the result might be an
incorrect value.
</p>
<p id="173">
But there is typically no runtime check that values of the correct
type are being passed to <b>foo</b>. If you call foo with a float or a
bignum, the possibly incorrect result is produced silently.
</p>
<p id="174">
You can have runtime checks added for type declarations and let and
lambda bindings and setq's by compiling while
the <a href="variables/compiler/verify-type-declarations-switch.htm"><code>verify-type-declarations-switch</code></a> switch is
true. See the description for an example. Note that with the default
settings, <a href="variables/compiler/verify-type-declarations-switch.htm"><code>verify-type-declarations-switch</code></a> and the
various relevant trust-* switches are all true only for speed
3/safety 2. But note that is an odd declaration combination: when all are true, extra code will be added to verify type declarations, and if the data
verifies, the code that operates on the declared values will be
optimized to use those declarations. Depending on the expense of the
particular type declaration, the generated code might or might not be
faster than simply allowing generic builtin functions to handle the
case. Consider an overly-helpful declaration like
</p>

<pre id="175">
  (declare (type x (integer 100 127)))
  ... (foo (- x 1))
</pre>

<p id="176">
This code will be a lot more expensive than a simple fixnum
declaration, since the compiler promises to check both limits.
</p>



<hr><h2 id="177"><a name="sw-t-or-nil-2">8.9 Switch can be t or nil meaning always on or always off</a></h2>

<p id="178">The value of a compiler switch can be <code>t</code> or
<code>nil</code> as well as a function. <code>t</code> is interpreted as a function that always return
true and so causes the switch to always be on. <code>nil</code> is interpreted as a function that always returns
false and so causes the switch to always be off. These settings are
particularly useful when binding the variables during a specific
compilation.</p>





<hr><h2 id="179"><a name="trusted-type-2">8.10 The excl:trusted-type declaration</a></h2>

<hr><h3 id="180"><a name="excl:trusted-type-decl-bookmarkxx"></a>excl:trusted-type</h3><h3 id="181">Declaration</h3>

<p id="182">
This declaration has the same meaning and syntax as the Common Lisp
<a href="../ansicl/dictentr/type.htm">type</a> declaration, but
it will be trusted even when the compiler
switch <a href="variables/compiler/trust-declarations-switch.htm"><code>trust-declarations-switch</code></a>
is <code>nil</code>, which means most declarations are not
trusted. This allows you to specify certain declarations as always
trusted even if you are running at high safety.
</p>
<p id="183">
This declaration should be used sparingly if at all. It is designed
for cases where code will not compile unless the type is known (which
occurs, for example, during bootstrapping but rarely in normal cases).
</p>

<hr>





<hr><hr><h2 id="184"><a name="choose-speed-safety-1">9.0 Pointers for choosing speed and safety values</a></h2>

<p id="185">What values should you choose for speed and safety? It is tempting
to set speed to 3 and safety to 0 so that compiled code will run as
fast as possible, and devil take the hindmost. Our experience is that
people who do this say that Allegro CL is fast but lacks robustness,
while people who use the more conservative default settings of 1 and 1
feel that Allegro CL is very robust but occasionally seems a bit
sluggish. Which you prefer is for you to decide. The following points
should be considered. </p>

<ol>
<li id="186">
If you are going to set speed globally to 3, we <i>strongly</i>
discourage you from also globally setting safety to 0 rather than
1. 

There are only 5 differences between the two safety settings: at
safety 0, (1) argument count checking is disabled
(see <a href="variables/compiler/verify-argument-count-switch.htm"><code>verify-argument-count-switch</code></a>); (2)
interrupt checking is disabled (see <a href="variables/compiler/generate-interrupt-checks-switch.htm"><code>generate-interrupt-checks-switch</code></a>); (3)
sums and differences of fixnums are assumed to be fixnums
(see <a href="variables/compiler/declared-fixnums-remain-fixnums-switch.htm"><code>declared-fixnums-remain-fixnums-switch</code></a>);
(4) <b>case</b> is compiled in table-driven fashioon
(see <a href="variables/compiler/trust-table-case-argument-switch.htm"><code>trust-table-case-argument-switch</code></a>); and (5)
on 32-bit x86 only, floating-point calculations are done without the
flags set which guarantee that the results are the same from run to
run (<a href="variables/compiler/generate-accurate-x86-float-code-switch.htm"><code>generate-accurate-x86-float-code-switch</code></a>). Thus
you may not be able cleanly to break out of an infinite loop; passing
the wrong number of arguments may cause unrepeatable, possibly fatal
errors; adding fixnums whose sum is a bignum will silently produce the
wrong answer; and (again 32-bit x86 only) the lower bits of
floating-point calculation may vary from run to run. We recommend that
those switches should only be set in an unsafe manner when compiling
functions where it is very unlikely that the code is incorrect. You
can set safety to 0 when compiling such functions by use of a
declaration within the defun form.

</li>
<li id="187">
If strange errors occur whose cause cannot be discovered, recompile
the code at a more safe setting of speed and safety and run it
again. An error will usually occur (not necessarily in the same
place), the error message should be more informative, and the debugger
should have more information. If no error occurs, it may be that you
have an incorrect declaration (e.g. declaring a value to be a
single-float when it is in fact something else,
like <code>nil</code>). Look particularly at initial
values, making sure the initial value is of the declared type.
</li>
<li id="188">
You might consider resetting the switch variables
to <code>t</code> or <code>nil</code> (as
appropriate) as that can ensure the switch has a known, unambiguous
value unaffected by declarations within a function definition or
anything else.
</li>
</ol>


<hr><h2 id="189"><a name="opt-for-fast-fp-2">9.1 Optimizing for fast floating-point operations</a></h2>

<p id="190">The compiler in Allegro CL has the ability to compile
floating-point operations in-line. In order to take full advantage of
this feature, the compiler must know what can be done in-line. For it
to know this, the user must, through declarations, inform the compiler
of the type of arguments to operations. The compiler will attempt to
propagate this type information to other operations, but this is not
as easy as it might seem on first glance. Because mathematical
operations in Common Lisp are generic, that is they accept arguments
of any type - fixed, real, complex - and produce results of the
appropriate type, the compiler cannot assume results in cases when the
user may think the situation is clear. For example, the user may know
that only positive numbers are being passed to sqrt, but unless the
compiler knows it too, it will not assume the result is real and not
complex. The compiler can tell the user what it does know and what it
is doing. See <a href="#decl-help-1">Section 10.0 Help with declarations: the :explain declaration</a> below. With
this information, the user can add declarations as needed to speed up
the compiled code.  The process should be viewed as interactive, with
the user tuning code in response to what the compiler says it
knows. </p>



<hr><h2 id="191"><a name="supported-ops-2">9.2 Supported operations</a></h2>

<p id="192">The compiler will expand in-line (open-code) a floating-point
numeric function only if the function is one which it knows how to
open-code, and the types of the function's arguments and result are
known at compile time to be those for which the open-coder is
appropriate. Finally, at the point of compilation the compiler switch
function which is the value of comp:trust-declarations-switch must
return true. The default version of this function returns true if
speed is greater than safety but users can change the values for which
this switch returns true. <a href="operators/excl/explain-compiler-settings.htm"><b>explain-compiler-settings</b></a> can be called to see
what the value of that switch (and all others) will be given the
current values of safety, space, speed, and debug.</p>

<p id="193">The floating-point functions below are subject to opencoding. In
each case, the function result must be declared or derivable to be
either single-float or double-float.  (Note that in this
implementation, the type short-float is equivalent to single-float and
long-float is equivalent to double-float.) The arguments to the
arithmetic and trigonometric functions must be specifically one or the
other of the two floating types, or signed integer constants
representable in 32 bits (on 32-bit lisps) or 64 bits (on 64-bit
lisps), or else computed integer values of fixnum range. If these
conditions are not met, the function will not be open-coded and
instead a normal call to the generic version of the function will be
compiled. Note that it is not sufficient to declare a value to be a
float, it must be declared as either a single-float or a
double-float. </p>

<p id="194">We are often asked exactly which functions will opencode in Allegro
CL. Unfortunately, it is not easy to provide an answer. Firstly,
because the compiler is different on each different architecture, the
answer is different in different implementations. Secondly, the same
function may opencode in one case but not in another on the same
machine because of the way it is affected by surrounding
code.  The
<code>:explain</code> and <code>:explain :inlining</code> declarations
described in
the <a href="#decl-help-1">below</a> assists
with determining what did and did not opencode.  However, the
following functions are candidates to be open-coded in most platforms
or in the platforms noted. </p>


    <ul>
      <li id="195">The four binary arithmetic functions: <strong>+ - * / </strong></li>
      <li id="196">The four unary arithmetic functions: <strong>+ - * / </strong></li>
      <li id="197">The simple trigonometric functions: <strong>sin</strong>, <strong>cos</strong>, <strong>tan</strong>
        (32-bit x86 or equivalent only)</li>
      <li id="198">One-argument <strong>float</strong> of a fixnum. </li>
      <li id="199"><strong>abs</strong> (all platforms) and <strong>sqrt</strong> (x86/x86-64, Sparc), </li>
      <li id="200"><strong>aref</strong> and <strong>setf</strong> of <strong>aref</strong> of <code>(simple-array
        single-float (*))</code> </li>
      <li id="201"><strong>aref</strong> and <strong>setf</strong> of <strong>aref</strong> of <code>(simple-array
        double-float (*))</code></li>
    </ul>


<p id="202">Note that the list is not exhaustive in either direction. Not all
the listed functions and operations opencode on all machines and
functions and operations not listed do opencode on some machines. As
said above, the
<code>:explain</code> declaration described in the <a href="#decl-help-1">below</a>
assists with determining what did and did not opencode. </p>



<hr><hr><h2 id="203"><a name="decl-help-1">10.0 Help with declarations: the :explain declaration</a></h2>

<p id="204">The compiler must be supplied with type declarations if it is to
open-code certain common operations without type-checking. The
compiler includes a type propagator that tries to derive the results
of a function call (or special operator) from what it knows about its
arguments (or subforms). The type propagator greatly reduces the
amount of type declaration necessary to achieve opencoding. However,
the programmer may need to examine the inferences made by the
propagator to determine what additional declarations would increase
code speed. Although supplying type declarations to the compiler is
very simple, it is a task surprisingly prone to error. The usual error
is that well-intentioned declarations are insufficient to tell the
compiler everything it needs to know. </p>

<p id="205">For example, the programmer might neglect to declare the seemingly
obvious fact that the result of a certain sqrt of a double-float is
also a double-float. However, sqrt in Common Lisp returns a complex if
its argument is negative, so the compiler cannot assume a real
result. The only impact of insufficient declarations is that some
open-coders will not be invoked. However, it can be awkward for the
user to determine whether or not any particular call was open-coded,
and if not, why. trace and disassemble will provide the information,
but these are clumsy tools for the purpose. </p>

<p id="206">
In order to provide better information about what the compiler is
doing, a new declaration, :explain, has been added to Allegro CL. 
</p>

<hr><h3 id="207"><a name=":explain-decl-bookmarkxx"></a>:explain</h3><h3 id="208">Declaration</h3>

<p id="209"><b>Arguments: </b><i>
[:calls | (:calls t) | (:calls nil)]
[:types | (:types t) | (:types nil)]
[:boxing | (:boxing t) | (:boxing nil)]
[:variables | (:variables t) | (:variables nil)]
[:tailmerging | (:tailmerging t) | (:tailmerging nil)]
[:inlining | (:inlining t) | (:inlining nil)]
</i></p>

<p id="210">
This declaration instructs the compiler to report or not to report
information about argument types and non-in-line calls, boxed floats
and variables stored in registers, tail-merging, and why inlining
might not have succeeded. Reporting is enabled when a quality appears
alone or in a list with <code>t</code>. It is disabled
when a quality appears in a list with <code>nil</code>. Initially, no <code>:explain</code>
qualities are enabled.
</p>
<p id="211">
This declaration may be placed anywhere that a normal declaration may
be, and can be proclaimed (with <a href="../ansicl/dictentr/proclaim.htm"><b>proclaim</b></a> or <a href="../ansicl/dictentr/declaim.htm"><b>declaim</b></a>). The compiler will report
information within the scope of the declaration. Note that results may
differ from one platform to another. Again, the general form of the
declaration is (these forms must be placed in a location where
declares are allowed, of course):
</p>

<pre id="212">
(declare (:explain :quality ...))  ;;  explanation for :quality
                                   ;;  will be output
;; or
(declare (:explain (:quality t) ...) ;;  explanation for :quality
                                     ;;  will be output
;; or
(declare (:explain (:quality nil) ...) ;;  explanation for :quality
                                       ;;  will not be output

;;  Thus
(declare (:explain :types (:boxing nil) (:variables t) :tailmerging))
;;  will enable explaining for :types, :variables, and :tailmerging
;;  and disable it for :boxing.  Explaining for :calls is not affected
;;  (off if it was already off, on if it was already on).
</pre>



<p id="213">
The arguments control various kinds of reporting the compiler will make
during compilation. The arguments may appear in either order, and
either may be omitted. By default, no information of either type is
printed. The declaration causes the compiler to print information
during compilation, and obeys normal declaration scoping rules. It has
no effect on code generation. Here are the various :explain qualities:
</p>
<ul>
<li id="214">
<code>:types</code>: when this quality is in effect, the
compiler will report for each function call it compiles (in-line or
not) the types of each argument along with the result
type. Further information and examples are in <a href="compiler-explanations.htm#calls-types-explain-2">Calls and types
explanation</a> in
<a href="compiler-explanations.htm">compiler-explanations.htm</a>.
</li>
<li id="215">
<code>:calls</code>: when this quality is in effect, the
compiler will report when it generates code for any non-in-line
function call. <code>:types</code> and <code>:calls</code>
operate independently. Further information and examples are in
<a href="compiler-explanations.htm#calls-types-explain-2">Calls and types
explanation</a> in
<a href="compiler-explanations.htm">compiler-explanations.htm</a>. 
<code>:calls</code> should not be used with
<code>:inlining</code> since calls information is provided by
the :inlining explanation.
</li>
<li id="216">
<code>:boxing</code>: when this quality is in effect, the
compiler will tell you when code is generated to box a number if it is
possible for the code not to be boxed. A number is `boxed' when it is
converted from its machine representation to the Lisp
representation. For floats, the machine representation is one (for
singles) or two (for doubles) words. Lisp adds an extra word, which
contains a pointer and a type code. For fixnums, boxing simply
involves a left shift of two bits. For bignums which are in the range
of machine integers, boxing again adds an additional
word. Further information and examples are in <a href="compiler-explanations.htm#boxing-explain-2">Boxing
explanation</a> in
<a href="compiler-explanations.htm">compiler-explanations.htm</a>. 
<code>:boxing</code> should not be used with
<code>:inlining</code> since boxing information is provided by
the :inlining explanation.
</li>
<li id="217">
<code>:variables</code>: when this quality is in effect, the
compiler will report whether local variables (in function definitions)
are being stored in registers or in memory. Since storing variables in
registers results in faster code, the information printed when this
variable is in effect may help in recasting function definitions to
allow for more locals to be stored in registers. Further
information and examples are in <a href="compiler-explanations.htm#variables-explain-2">Variables
explanation</a> in
<a href="compiler-explanations.htm">compiler-explanations.htm</a>.
</li>
<li id="218">
<code>:tailmerging</code>: when this quality is in effect, the
compiler will report why a tail-merge is or is not being done for a
function in tail-position. Further
information and examples are in <a href="compiler-explanations.htm#tailmerging-explain-2">Tail-merging
explanation</a> in
<a href="compiler-explanations.htm">compiler-explanations.htm</a>.
</li>

<li id="219">
<code>:inlining</code>: when this quality is in effect,
information about why a function you might expect to be inlined was
not in fact inlined by the compiler. Further information and examples
are in <a href="compiler-explanations.htm#inlining-explain-2">Inlining explanation</a> in
<a href="compiler-explanations.htm">compiler-explanations.htm</a>.  (Essentially all the
information printed by the <code>:explain :calls</code> and
<code>:explain :boxing</code> declarations is printed by the
<code>:explain :inlining</code> declaration, so you should use
either :inlining or :boxing and :calls, but not both.)
</li>

</ul>


<p id="220">
The reports are printed during the code generation phase of
compilation. Code generation occurs fairly late during compilation,
after macroexpansion and other code transformations have taken
place. The function calls explained by the compiler will therefore
deviate in certain ways from the original user code. For example, a
two-operand <a href="../ansicl/dictentr/unnamed0.htm"><b>+</b></a> operation is
transformed into a call to the more efficient
<strong>excl::+_2op</strong> function. In general, the user should
easily be able to relate the code generator's output to the original
code. 
</p>

<p id="221">
The code generator works by doing a depth-first walk of the
transformed code tree it receives from early compiler phases. In this
tree walk, the <code>:types</code> printout happens during the descent
into a branch of the tree. The <code>:calls</code> printout happens as
the instructions are actually generated, during the ascending return
from the branch.
</p>

<p id="222">
The reason <code>:explain</code> is implemented as a declaration
is so the user can gain fairly fine-grained control of its scope. This
can be important when tuning large functions. The tool does require
editing the source code to be compiled, but presumably the user is in
the process of editing the code to add declarations anyway. These
options may also be enabled and disabled globally by use of <a href="../ansicl/dictentr/proclaim.htm"><b>proclaim</b></a> or <a href="../ansicl/dictentr/declaim.htm"><b>declaim</b></a>, although they may produce
a lot of output.
</p>

<p id="223">
The lines of explanation output are labeled with abbreviations which
identify what type of explanation is being produced and what the
compiler is doing. These abbreviations are listed in the
<a href="compiler-explanations.htm">compiler-explanations.htm</a>.
</p>


<hr>



<hr><hr><h2 id="224"><a name="other-decl-opt-1">11.0 Other declarations and optimizations</a></h2>

<p id="225">There are other declarations which affect (or in some cases do not
affect) the operation of the compiler, as we describe under the next
several headings.</p>

<hr><h2 id="226"><a name="inline-ignored-2">11.1 Inline declarations ignored</a></h2>

<p id="227">
The <code>inline</code> declaration is ignored by the compiler, but
see <a href="../ansicl/dictentr/define-2.htm"><b>define-compiler-macro</b></a>, which will
define a macro for the compiler to use for an operator which is not
declared <code>notinline</code>.
</p>
<p id="228">
At appropriate settings of speed and safety, the compiler will inline
whatever it can. Only predefined system functions can be inlined. User
defined functions are never compiled inline. (The compiler will
observe the <code>notinline</code> declaration, however, so you can
suppress inlining of specific functions if you want.)
</p>

<p id="229">
We have been asked why the inline declaration is ignored. It is not
that we believe that inlining user functions does not provide any
advantages, it is that we believe that there are other improvements
that will provide more advantages. Because we have now implemented
compiler environments (see <a href="environments.htm">environments.htm</a>), we
are in a better position to implement inlining of user functions in a
later release.
</p>

<p id="230">
Note that inlining is not an unmixed blessing. It increases the
amount of space used by a function (since both the function definition
and the block to stick in when the function is inlined have to be
created and stored) and it makes debugging harder (by making the
compiled code diverge from the source code). It is also prone to
subtle errors (on the programmers side) and bugs (on our side).
</p>



<hr><h2 id="231"><a name="defstruct-acc-2">11.2 Defstruct accessors</a></h2>

<p id="232">Defstruct accessors will be compiled inline under two conditions: </p>


  <ol>
    <li id="233">The structure is <i>not</i> of type list. (Accessors for structures of type list are
      never inlined). </li>
    <li id="234">The values of speed and safety are such that the compiler switch <a href="variables/compiler/verify-non-generic-switch.htm"><code>verify-non-generic-switch</code></a>
      returns <code>nil</code>. Using the default value, that switch will return <code>nil</code>
      when speed is 3 and safety is 0 or 1. </li>
  </ol>




<hr><h2 id="235"><a name="stack-consing-2">11.3 Stack consing, avoiding consing using apply, and stack allocation</a></h2>

<p id="236"><strong>Stack consing</strong></p>

<p id="237">
On some machines, stack consing of &rest arguments, closures, and
some lists and vectors is supported. To be stored on the stack, an
object must be declared dynamic-extent, the compiler must trust that
declaration (see <a href="variables/compiler/trust-dynamic-extent-declarations-switch.htm"><code>trust-dynamic-extent-declarations-switch</code></a>),
and the object must be suitable for stack consing. Stack consing means
that objects are stored on the stack and not written to memory. This
can provide a significant space saving if the objects are truly
temporary, which they often are. Here is an example of such a
declaration for an &rest argument. The
function <strong>foo</strong> checks whether the first argument is
identical to any later argument.
</p>

<pre id="238">
(defun foo (a &rest b)
 (declare (dynamic-extent b))
 (dolist (val b)
 (if* (eq a val) then (return t)))) 
</pre>


<p id="239">
Please note that care should exercised when using stack consing and
multiprocessing, since a switch between one thread/process and another
causes (part of) the stack to be saved, so the stack-consed objects
and values are not available to the thread/process being switched
into.  For a binding or object that has dynamic extent, that extent is
only valid when Lisp is executing on the thread/process that creates
the binding or stack-conses the object. When (on Windows, which uses
OS-threads) a thread switch is executed, the extents of all
dynamic-extent data and bindings are temporarily exited, to be
re-established when another thread switch returns to the original
thread. Since only on Windows separate Lisp lightweight processes run
on separate threads, it is important on Unix that dynamic-extent data
(which may be stack-consed) not be referenced while executing on a
different process. On Unix, a <a href="operators/mp/process-wait.htm"><b>process-wait</b></a>
&nbsp;<em>wait-function</em> argument should never be
declared dynamic-extent, since it was funcall'ed from other
stack-groups. However, on Windows, wait functions are run only in
their own threads, so stack consing in wait functions should work.
</p>

<p id="240">
Dynamic-extent declarations are only observed at values of safety,
space, speed, and debug for which <a href="variables/compiler/trust-dynamic-extent-declarations-switch.htm"><code>trust-dynamic-extent-declarations-switch</code></a>
returns true and <a href="variables/compiler/trust-declarations-switch.htm"><code>trust-declarations-switch</code></a> is also true.
</p>

<p id="241">
If a call to <a href="../ansicl/dictentr/make-lis.htm"><b>make-list</b></a> has a
constant size, declarations are trusted, the list is made the value
of a variable, and the variable is declared as dynamic-extent, then it
will be stack-allocated and initialized. The
<i>initial-value</i> keyword can be used to specify the
value. An attempt to make a list of a variable size with <a href="../ansicl/dictentr/make-lis.htm"><b>make-list</b></a> will result in heap consing.
</p>

<p id="242">
Dynamic-extent argument properties are automatically declared on all
<a href="../ansicl/dictentr/defun.htm"><b>defun</b></a> forms. This gives the
compiler the ability to make assumptions about the dynamic extent use
of arguments passed into these functions, and to generate more
efficient code. The compiler generally tracks these properties for
functions that it knows about, e.g. <a href="../ansicl/dictentr/mapcmapc.htm"><b>mapcar</b></a>. Dynamic-extent declarations extend this
to user-defined functions and to redefinitions. Warnings are
also provided for redeclared definitions and for definitions that
occur after the function's first usage. To allow declaration before
the first use, a new macro called <a href="operators/excl/defun-proto.htm"><b>defun-proto</b></a> is provided.
</p>

<p id="243"><strong>Avoiding consing with apply using a &rest</strong></p>

<p id="244">In certain cases <a href="../ansicl/dictentr/apply.htm"><b>apply</b></a> is
now compiled more efficiently, to remove consing. This is the
so-called <i>applyn</i> optimization. Consider the following code:</p>

<pre id="245">
(defun foo (x &rest y)
 (apply some-fun 1 x 2 y))
</pre>


<p id="246">The <code>&rest</code> argument is used for nothing more than
to supply a variable length argument list to
<strong>apply</strong>. This case is now compiled in such a way that
</p>

<ol>
<li id="247">

The last argument to <strong>apply</strong> is not actually used, but
an index to the n'th argument to <strong>foo</strong> is compiled
instead.

</li>
<li id="248">

The <code>&rest</code> argument is considered dead and as if
declared ignored.

</li>
<li id="249">

All aspects of the function are preserved (e.g. possible argument
checking for a minimum but not a maximum number of arguments, etc.)

</li>
</ol>

<p id="250">In this optimized case, the code works exactly as it did when the
<code>&rest</code> argument was consed, but without the
consing. Circumstances that will cause this optimization to not be
used are if the &rest argument:
</p>

<ul>
  <li id="251">is declared special,</li>
  <li id="252">is a closed-over variable,</li>
  <li id="253">is set.</li>
  <li id="254">is used anywhere except as the last argument to <strong>apply</strong>.</li>
</ul>

<p id="255"><strong>Optimization hint</strong>: If you have a function like</p>

<pre id="256">
(defun wrap-it (flag &rest x &key &allow-other-keys)
 (when flag
 (setq x (list* :new-key 10 x)))
 (apply 'wrapped flag x))
</pre>


<p id="257">then the optimization will not take effect. If non-consed operation is desired,
then the following modification will allow the optimization:</p>

<pre id="258">
(defun wrap-it (flag &rest x &key &allow-other-keys)
 (if flag
 (apply 'wrapped flag :new-key 10 x)
 (apply 'wrapped flag x)))
</pre>


<p id="259"><strong>Stack allocation</strong></p>

<p id="260">
The type of arrays (and thus vectors) supported in Allegro CL are
discussed in <a href="implementation.htm#data-types-1">Data types and array types</a> in
<a href="implementation.htm">implementation.htm</a>. Of those, the following types
of vectors can now be stack-allocated (<b>N/A</b> means not
stack-allocable on the indicated platform, in some cases because that
type of specialized array is not supported and in other cases because
that type of specialized simply cannot be allocated on the
stack; <b>*</b> means the <b><i>initial-element</i></b>
value is <b>ignored</b> when the array is stack allocated):
</p>

<table border="1" width="50%">
  <tr>
    <td width="50%"><strong>element type</strong></td>
    <td width="25%"><strong>initializable in 32-bit Lisps? (see below)</strong></td>
    <td width="25%"><strong>initializable in 64-bit Lisps? (see below)</strong></td>

  </tr>
  <tr>
    <td width="50%"><code>t</code></td>
    <td width="25%"><b>yes</b></td>
    <td width="25%"><b>yes</b></td>
  </tr>
  <tr>
    <td width="50%"><code>(unsigned-byte 64)</code></td>
    <td width="25%"><b>N/A</b></td>
    <td width="25%"><b>yes</b></td>
  </tr>
  <tr>
    <td width="50%"><code>(signed-byte 64)</code></td>
    <td width="25%"><b>N/A</b></td>
    <td width="25%"><b>yes</b></td>
  </tr>
  <tr>
    <td width="50%"><code>(unsigned-byte 32)</code></td>
    <td width="25%"><b>yes</b></td>
    <td width="25%">no</td>
  </tr>
  <tr>
    <td width="50%"><code>(signed-byte 32)</code></td>
    <td width="25%"><b>yes</b></td>
    <td width="25%">no</td>
  </tr>
  <tr>
    <td width="50%"><code>(unsigned-byte 16)</code></td>
    <td width="25%">no</td>
    <td width="25%">no</td>
  </tr>
  <tr>
    <td width="50%"><code>(signed-byte 16)</code></td>
    <td width="25%">no</td>
    <td width="25%">no</td>
  </tr>
  <tr>
    <td width="50%"><code>(unsigned-byte 8)</code></td>
    <td width="25%">no</td>
    <td width="25%">no</td>
  </tr>
  <tr>
    <td width="50%"><code>(signed-byte 8)</code></td>
    <td width="25%">no</td>
    <td width="25%">no</td>
  </tr>
  <tr>
    <td width="50%"><code>character</code></td>
    <td width="25%">no</td>
    <td width="25%">no</td>
  </tr>
  <tr>
    <td width="50%"><code>(unsigned-byte 4)</code></td>
    <td width="25%">no</td>
    <td width="25%">no</td>
  </tr>
  <tr>
    <td width="50%"><code>bit</code></td>
    <td width="25%">no</td>
    <td width="25%">no</td>
  </tr>
  <tr>
    <td width="50%"><code>excl:foreign</code></td>
    <td width="25%"><b>yes</b></td>
    <td width="25%"><b>yes</b></td>
  </tr>
  <tr>
    <td width="50%"><code>single-float</code></td>
    <td width="25%"><b>*</b></td>
    <td width="25%">no</td>
  </tr>
  <tr>
    <td width="50%"><code>double-float</code></td>
    <td width="25%"><b>N/A</b></td>
    <td width="25%"><b>*</b></td>
  </tr>
  <tr>
    <td width="50%"><code>fixnum</code></td>
    <td width="25%"><b>yes</b></td>
    <td width="25%"><b>yes</b></td>
  </tr>
</table>

<p id="261">
To get a stack-allocated vector, the following coding practice 
should be used: 
</p>

<pre id="262">
(declare (optimize &lt;values that make <a href="variables/compiler/trust-declarations-switch.htm"><code>trust-declarations-switch</code></a> true&gt;)) 
  ;; with initial variable value, (speed 3) (safety 1) will work
... 
(let ((x (make-array n &lt;<em>options</em>&gt;))) 
  (declare (dynamic-extent x)) ...) 
</pre>

<p id="263">where <code>n</code> is a constant integer, and <em>options</em>
are limited to <code>:element-type</code> (and
<code>:initial-element</code>, if the array is
<strong>initializable</strong> according to the table above). All
other forms might cause heap allocation of the array. Specifying an
<i>initial-element</i> when the array is not, according
to the table above, initializable will cause the array to be heap
allocated <b>except in the cases denoted by a *</b> (single-float
arrays on 32-bit and double-float arrays on 64-bit): in those cases
the array will be stack-allocated but the value specified by the
<b><i>initial-element</i></b> argument will be ignored.
</p>

<p id="264">
Other functions that allow stack-consing if conditions are right are
<a href="../ansicl/dictentr/cons.htm"><b>cons</b></a>, <a href="../ansicl/dictentr/listlist.htm"><b>list</b></a>, <a href="../ansicl/dictentr/listlist.htm"><b>list*</b></a>, <a href="../ansicl/dictentr/make-lis.htm"><b>make-list</b></a>, <a href="operators/ff/with-stack-fobject.htm"><b>with-stack-fobject</b></a>, <a href="operators/ff/with-stack-fobjects.htm"><b>with-stack-fobjects</b></a>,
<a href="operators/excl/with-stack-list.htm"><b>with-stack-list</b></a>,
and <a href="operators/excl/with-stack-list_s.htm"><b>with-stack-list*</b></a>.
</p>



<hr><h2 id="265"><a name="adding-typep-trans-2">11.4 Adding typep-transformers</a></h2>

<p id="266">A typep-transformer allows the compiler to transform a form like</p>

<pre id="267">
(typep x 'foo)
</pre>


<p id="268">into a form like</p>

<pre id="269">
(funcall some-function x)
</pre>


<p id="270">For example, the Allegro CL compiler will already transform typep
forms where the type is defined as:</p>

<pre id="271">
(deftype foo () `(satisfies foop))
</pre>

<p id="272">into</p>

<pre id="273">
(funcall 'foop x)
</pre>


<p id="274">The ability to add typep-transformers described here allows types
defined with a more complicated syntax than (satisfies 'some-function)
to be similarly transformed. The user must supply the appropriate
predicate function and call the following function to associate the
type with the predicate.</p>

<p id="275">The function <a href="operators/excl/add-typep-transformer.htm"><b>add-typep-transformer</b></a> takes a type and a
predicate which will allow the compiler to transform forms like</p>

<pre id="276">
(typep x 'type)
</pre>

<p id="277">into the form:</p>

<pre id="278">
(funcall &lt;predicate&gt; x)
</pre>

<p id="279">The function <a href="operators/excl/remove-typep-transformer.htm"><b>remove-typep-transformer</b></a> removes the
association between the type and the predicate.</p>

<p id="280">For example, suppose we have defined a type called
<code>angle</code>, which is a normalized angular
measurement:</p>

<pre id="281">
(deftype angle () '(real #.(* -2 pi) #.(* 2 pi)))
</pre>

<p id="282">Suppose further that we have a time critical function that takes
two arguments, checks to be sure they are angles, adds them together,
checks to make sure the result is an angle, and returns it:</p>

<pre id="283">
(defun add-two-angles (a b) 
  (declare (optimize (speed 3)))
  (unless (typep a 'angle)
       (error "~s is not an angle" a))
  (unless (typep b 'angle)
       (error "~s is not an angle" b))
  (let ((sum (+ (the angle a) (the angle b))))
    (unless (typep sum 'angle)
       (error "Sum (~s) of angles is not an angle" sum))
     sum))
</pre>

<p id="284">As is, 10,000 calls of this function (given legal arguments) takes
about 1.5 CPU seconds (on my test machine). Suppose we're unhappy with
that and want to speed it up by adding a typep-transformer, without
having to change the coding of <strong>add-two-angles</strong>.
Further suppose that we're usually dealing with single precision
floating point numbers.  Here's a way we can do it. We first define
our predicate function. Note that we put the most likely case
(single-float) as the first choice in the <a href="../ansicl/dictentr/typecase.htm"><b>typecase</b></a> form.</p>

<pre id="285">
(defun anglep (x)
  (declare (optimize (speed 3) (safety 0)))
  (typecase x
    (single-float (and (&gt;= (the single-float x)
			   #.(float (* -2 pi) 0.0s0))
		       (&lt;= (the single-float x)
			   #.(float (* 2 pi) 0.0s0))))
    (fixnum (and (&gt;= (the fixnum x) #.(truncate (* -2 pi)))
		 (&lt;= (the fixnum x) #.(truncate (* 2 pi)))))
    (double-float (and (&gt;= (the double-float x)
			   #.(float (* -2 pi) 0.0d0))
		       (&lt;= (the double-float x)
			   #.(float (* 2 pi) 0.0d0))))))
</pre>


<p id="286">We then call <a href="operators/excl/add-typep-transformer.htm"><b>add-typep-transformer</b></a> to make the compiler
aware of our predicate:</p>

<pre id="287">
(excl:add-typep-transformer 'angle 'anglep)
</pre>


<p id="288">Now if we recompile <strong>add-two-angles</strong> and call it
another 10,000 times with the same arguments, it only takes about .25
CPU seconds, a 6 fold improvement (you may see a different speedup
ratio).</p>



<hr><h2 id="289"><a name="tpl-forms-2">11.5 Compiler handling of top-level forms</a></h2>

<p id="290">
See the discussion in <a href="implementation.htm">implementation.htm</a> and the
description of <a href="variables/compiler/s_cltl1-compile-file-toplevel-compatibility-p_s.htm"><code>*cltl1-compile-file-toplevel-compatibility-p*</code></a>
for information on special handling of certain top-level forms in a
file. The issue is whether the forms are treated (during the compile)
as if wrapped in an 
</p>

<pre id="291">
(eval-when (compile) ...)
</pre>

<p id="292">
A top-level form in a file is one which is not a subform of anything
except perhaps <a href="../ansicl/dictentr/progn.htm"><b>progn</b></a>.  In
CLtL-1 CL, top-level forms involving calls to the following functions
were treated as if wrapped in such an <a href="../ansicl/dictentr/eval-whe.htm"><b>eval-when</b></a> when compiled. In ANSI CL, they are
not.  You can arrange to have the CLtL-1 behavior as described in
<a href="implementation.htm">implementation.htm</a>.  The affected functions are:
</p>

<pre id="293">
      make-package 
      shadow 
      shadowing-import 
      export
      unexport 
      require 
      use-package 
      unuse-package 
      import 
</pre>




<hr><h2 id="294"><a name="misspellings-2">11.6 Warnings are signaled for misspelling in type declarations</a></h2>

<p id="295">
Consider the following definition:
</p>

<pre id="296">
(defun foo (x123 y123 z123)
  (declare (fixnum x123 y123 z124))
  (+ x123 y123 z123))
</pre>

<p id="297">
Unless care is taken in looking at this definition, it is easy not to
notice that there is a spelling error in this definition (<b>z124</b>
instead of <b>z123</b>).  And yet, since declarations are optional in
Common Lisp, such a spelling error would not make a functional
difference in the compiled code, and so it is likely to go completely
unnoticed, even when the code goes into production, unless careful
optimization is done.
</p>
<p id="298">
When compiling this function, this kind of error results in a warning.
Specifically, if a type declaration finds a name which is unknown
lexically, a warning will be generated.  In this eample case, the
warning will be for z124, which apparently should have corresponded
to z123 instead.
</p>
<p id="299">
This warning will not occur for any correct portable code.  The only
questionable situation is the case where the variable is truly unknown,
and thus would have already been giving a warning for a variable that
will be assumed to be special, as in this example:
</p>

<pre id="300">
(defun xxx ()
  (declare (fixnum xyz))
  (1+ xyz))
</pre>

<p id="301">
Now, two warnings will (likely) be given: one for the fact that
<code>xyz</code> is unknown in the declaration, and one for the
fact that xyz is unknown in the code and is this assumed special.
</p>




</body><hr><p id="2"><small>Copyright (c) 1998-2017, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page was not revised from the 10.0 page.</small><br><small>Created 2017.2.15.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/compiling.htm">10.0 version</a></td></tr></table></html>