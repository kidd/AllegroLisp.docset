<html><head><meta name="viewport" content="width=device-width, initial-scale=1"> <meta http-equiv="content-type" content="text/html; charset=UTF-8"> <link rel="stylesheet" href="acldoc-styles.css" type="text/css"><title>The Top Level</title></head><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/top-level.htm">10.0 version</a></td></tr></table><h1 id="2">The Top Level</h1><p id="3">This document contains the following sections:</p><a href="#top-level-intro-1">1.0 Introduction to the Lisp top-level listener</a><br><a href="#prompt-1">2.0 The prompt</a><br><a href="#commands-1">3.0 Commands and expressions </a><br>&nbsp;&nbsp;&nbsp;<a href="#input-case-sensitivity-2">3.1 Case sensitivity of input</a><br>&nbsp;&nbsp;&nbsp;<a href="#getting-help-for-tpl-commands-2">3.2 Getting help for top-level commands</a><br>&nbsp;&nbsp;&nbsp;<a href="#command-history-2">3.3 Command and expression history</a><br>&nbsp;&nbsp;&nbsp;<a href="#history-anomalies-2">3.4 Anomalies with the :history list</a><br><a href="#break-levels-1">4.0 Break levels</a><br>&nbsp;&nbsp;&nbsp;<a href="#break-level-commands-2">4.1 Commands to manipulate break levels:</a><br><a href="#commands-for-compile-and-load-1">5.0 Commands for compiling and loading</a><br>&nbsp;&nbsp;&nbsp;<a href="#arguments-read-as-strings-2">5.1 File arguments are read as strings</a><br><a href="#interaction-with-mp-1">6.0 Top-level interaction with multiprocessing </a><br>&nbsp;&nbsp;&nbsp;<a href="#process-comms-args-2">6.1 Argument processing for  :processes, :focus, :arrest, :unarrest and :kill</a><br>&nbsp;&nbsp;&nbsp;<a href="#process-comm-2">6.2 More on the :processes command</a><br>&nbsp;&nbsp;&nbsp;<a href="#focus-etc-comms-2">6.3 More on the :focus, :arrest, and :unarrest commands</a><br><a href="#commands-for-kill-and-exit-1">7.0 Commands for killing processes and exiting Lisp</a><br><a href="#commands-misc-1">8.0 Miscellaneous top-level commands</a><br><a href="#tpl-timing-1">9.0 Automatic timing information</a><br><a href="#tpl-vars-1">10.0 Top-level variables</a><br><a href="#adding-new-commands-1">11.0 Adding new top-level commands</a><br><hr><hr><h2 id="4"><a name="top-level-intro-1">1.0 Introduction to the Lisp top-level listener</a></h2>

<p id="5">
When Allegro CL starts, by default it runs a <em>lisp
listener</em>. Although the listener has various extended
capabilities, it is basically a loop that repeatedly writes a prompt,
reads a form, evaluates it, and prints the result(s). For this reason
a lisp listener is sometimes also called a <em>read-eval-print
loop</em>. A listener is also sometimes called a <em>top-level
loop</em> because it is the interactive command processor under which
other programs run.
</p>

<p id="6">
The user interacts with Allegro CL by typing to the read-eval-print
loop, which of course can also be driven from a script. The full power
of the Lisp environment to load, debug, and run programs is
immediately available from the listener. In addition to the basic
read-eval-print loop, the listener has a set of commands to perform
certain common operations more quickly and succinctly, such as
re-executing a previously-entered command, loading files, recovering
from errors, and examining the execution stack for debugging.
</p>

<p id="7">
The following examples are places where Allegro CL runs a lisp
listener loop: the Debug window in the Integrated Development
Environment on Windows; the console window on Windows; a listener
buffer when using the Emacs-Lisp interface; and a Lisp started
directly in a Unix shell. Some have additional features (Emacs-Lisp
interface commands in an emacs buffer, menu commands that operate on
the just-typed input in the Debug window) but all have the features
described in this document.</p>

<p id="8">The debugging tools in Allegro CL are integrated into the
listener. They consist of a tracer, a stepper, an inspector, a set of
top-level commands that allow dynamic examination and manipulation of
Lisp data and the run-time evaluation stack, and mechanisms to
single-step through expressions or function calls. The debugger is
documented in <a href="debugging.htm">debugging.htm</a> and the inspector in
<a href="inspector.htm">inspector.htm</a>. </p>

<p id="9">The Allegro CL listener is modeless -- all top-level commands
are always accessible, regardless of the conceptual activity currently
underway, such as tracing a function, debugging, or simply entering
expressions for evaluation. For example, while stepping through the
forms in a function, the user may examine the function's parameters,
abort stepping, display a stack backtrace, ask for help on any
top-level command, or exit Lisp. There is only one set of top-level
commands. There is no command to put Allegro CL into a distinct
<i>debugging mode</i>. Debugging commands are always available. </p>

<p id="10">
Allegro CL has an extension called multiprocessing which permits
several distinct Lisp processes to execute in the same image (using
stack groups on UNIX platforms and OS threads on Windows). This
facility is described in the <a href="multiprocessing.htm">multiprocessing.htm</a>
document. The top-level interacts with multiprocessing in a number of
ways, but most important is that certain debugger commands operate on
a <em>focus</em> process rather than the listener process itself. When
a listener starts it is focussed on its own process.  The interaction
of the top-level with multiprocessing is described in the
<a href="#interaction-with-mp-1">Section 6.0 Top-level interaction with multiprocessing </a>. Other
information is found in the section
<a href="#commands-for-kill-and-exit-1">Section 7.0 Commands for killing processes and exiting Lisp</a>. Programmers
who do not use multiprocessing need not concern themselves with most
of these materials.
</p>

<p id="11">
This document describes the top level in images built with the
<em>include-tpl</em> keyword argument to <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> specified <code>t</code> (or true). Images built with
<em>include-tpl</em> &nbsp;<code>nil</code> have
a minimal top level (and may have a user-supplied top-level as
well). The minimal top level is described in <a href="building-images.htm#minimal-top-levels-1">Minimal top
levels</a> in <a href="building-images.htm">building-images.htm</a> and is not
further discussed in this document.
</p>
<p id="12">
Many symbols implementing top-level functionality are in the
<code>:top-level</code> (nicknamed <code>:tpl</code>)
package. Others are in the <code>:excl</code> package.
</p>

<hr><hr><h2 id="13"><a name="prompt-1">2.0 The prompt</a></h2>



<p id="14">The listener prints the prompt using a format control string or
formatter function (such as returned by the <b>cl:formatter</b> macro)
that consumes 8 arguments. This format control is taken from the
variable <a href="variables/tpl/s_prompt_s.htm"><code>*prompt*</code></a>.</p>

<p id="15">The eight arguments are (in order): </p>

<ol>
  <li id="16">The current process name (a string) or <code>nil</code> if the current process is the initial lisp
    listener.</li>
  <li id="17">The name of the focused process, or <code>nil</code> if there is no focused process.</li>
  <li id="18">A boolean indicating whether stepping is enabled.</li>
  <li id="19">A number indicating the current break level, or <code>nil</code> at break level zero.</li>
  <li id="20">A boolean if the current break level was entered by <a href="../ansicl/dictentr/break.htm"><b>break</b></a> or <a href="../ansicl/dictentr/cerror.htm"><b>cerror</b></a>.</li>
  <li id="21">A boolean if the current break loop was entered by a call to inspect.</li>
  <li id="22">The package in which the next expression will be read (i.e. the current binding of <code>cl:*package*</code>).</li>
  <li id="23">A number indicating the command number. Each evaluation of a Lisp expression or
    top-level command increases the command number by 1.</li>
</ol>

<p id="24">
This prompt scheme provides information about the dynamic state of
the listener.  If the system determines that the value of <a href="variables/tpl/s_prompt_s.htm"><code>*prompt*</code></a> is
inappropriate, it will print a warning (once) and replace it with the
default value.
</p>

<p id="25">
(The Emacs-Lisp interface must also have a regular expression that
will parse the prompt being printed by a listener. See 
<a href="eli.htm">eli.htm</a> for details.  The
default regular expression will correctly handle the default prompt
and many popular variations .  However, no check will be made that the
Emacs regexp is correct and features of the Emacs-Lisp interface will
fail if the prompt pattern is incorrect.)
</p>

<p id="26">Here is what the default prompt looks like when Lisp first starts:</p>

<pre id="27">
USER(1):
</pre>

<p id="28">The prompt indicates that typed expressions will be evaluated in
the common-lisp-user (nickname user) package. The number in
parentheses is the command number. Since the listener has just
started, the command number is one. The command number sequence is
local to the particular listener.  Each listener maintains its
own.</p>

<p id="29">When Lisp enters a break loop the prompt shows the break level in
brackets. Consider the following Lisp session:</p>

<pre id="30">
USER(1): (foo)
Error: attempt to call `FOO' which is an undefined function.
  [condition type: UNDEFINED-FUNCTION]
 
Restart actions (select using :continue):
  0: Try calling FOO again
  1: Return a value
  2: Try calling a different function
  3: Setf the symbol function of FOO and call it again
[1] USER(2): xyz
Error: Attempt to take the value of the unbound variable `XYZ'.
  [condition type: UNBOUND-VARIABLE]
 
Restart actions (select using :continue):
  0: Try calling FOO again
  1: Return a value
  2: Try calling a different function
  3: Setf the symbol function of FOO and call it again
[2] USER(3):
</pre>

<p id="31">In the last prompt printed here the number in brackets -- [2]
-- is the break level. The command number is 3 and the package is
still the common-lisp-user package.</p>

<p id="32">Let us take a more complex example. We clear the previous errors
and then define a function <strong>bar</strong> which calls <a href="../ansicl/dictentr/cerror.htm"><b>cerror</b></a>. Then we execute bar in a new
process using <a href="operators/mp/process-run-function.htm"><b>process-run-function</b></a>:</p>

<pre id="33">
USER(5): (defun bar () 
           (cerror "Just
continue" "A cerror break"))
BAR
USER(6): (mp:process-run-function "Break-process" #'bar)
</pre>

<p id="34">At this point, a *background-interaction* buffer is created in
Emacs (assuming Lisp is running as a subprocess of Emacs using the
Emacs-Lisp interface). That buffer is a separate listener so the
command number starts from 1. We display the prompt you see in that
buffer. Note that it is on two lines. The first line shows the process
(it does not appear if the process is the Initial Lisp Listener).</p>

<pre id="35">
[Current-process: Break-process]
  [1c] USER(1):
</pre>

<p id="36">The `c' after the break level number indicates that the break level
arose from a call to <b>cerror</b> or <b>break</b>. These are standard
operators that invoke the debugger with an explicit provision for
returning from the debugger. Calls to certain other operators (most
significantly, <a href="../ansicl/dictentr/error0.htm"><b>error</b></a>)
guarantee that the call will not return.  Even so, there may and in
general will be other more-remote restart points dynamically
surrounding the execution that may validly be invoked.  The `c'
indicates only whether the operator that invoked the debugger allows a
return.  It is something of a historical feature predating the
widespread adoption of the Common Lisp condition system.</p>

<p id="37">The prompt also changes if you are inspecting or stepping. See
<a href="debugging.htm">debugging.htm</a> and
<a href="inspector.htm">inspector.htm</a>.</p>

<p id="38">Because the prompt processes a lot of information, changing it is
not trivial. Some example of top-level prompts are included in file
<i>&lt;Allegro directory&gt;/misc/prompts.cl</i>.</p>

<hr><hr><h2 id="39"><a name="commands-1">3.0 Commands and expressions </a></h2>

<p id="40">
The top-level understands two sorts of input: top-level commands and
Lisp expressions. A top-level command is syntactically identified to
Allegro CL by a single character prefix, initially the colon
character. This can be changed by assigning a different character to
the variable <a href="variables/tpl/s_command-char_s.htm"><code>*command-char*</code></a>. In this document we
illustrate commands prefixed with the colon although the <i>name</i>
of the command does not contain the colon. When referring to the
command (as an argument to <a href="tpl-commands/help.htm"><b>:help</b></a>,
for example) the top-level command character is not required.
</p>

<p id="41">
A newline typed to the top-level is a null command which is
ignored; extra spaces and tabs are ignored; and end-of-file has a
special meaning which is discussed below (see 
<a href="#break-levels-1">Section 4.0 Break levels</a>). 
</p>

<p id="42">
Most top-level commands have abbreviations. The <a href="tpl-commands/help.htm"><b>:help</b></a> command called without arguments
will print out the list of top-level commands and their abbreviations,
along with a brief description of their use. An abbreviation is always
an initial substring of the command name. Any portion of the command
name that at least contains the minimal abbreviation will invoke the
command. For example, the minimal abbreviation for the command <a href="tpl-commands/error.htm"><b>:error</b></a> is :err. Thus,
<strong>:err</strong>, <strong>:erro</strong>, and
<strong>:error</strong> all invoke that command.
</p>

<p id="43">
Top-level commands may only be entered interactively to the
top-level. They cannot appear in a Lisp source file processed by
<a href="../ansicl/dictentr/load.htm"><b>load</b></a>, including the various
initialization files Lisp loads at startup. <a href="operators/tpl/do-command.htm"><b>do-command</b></a> is the functional equivalent
of a top-level command, documented in
<a href="#adding-new-commands-1">Section 11.0 Adding new top-level commands</a>, that may be used
to execute top-level commands. However, since load does not print the
results of executing Lisp forms, the many top-level commands which
simply return a result to be printed are not useful in a source
file. The functional form of top-level commands is mainly used in
<em>aliases</em> (i.e. user-defined top-level commands, see
<a href="#adding-new-commands-1">Section 11.0 Adding new top-level commands</a> below).
</p>

<hr><h2 id="44"><a name="input-case-sensitivity-2">3.1 Case sensitivity of input</a></h2>

<p id="45">A top-level command has the form </p>

<pre id="46">
:name<i> argument ...</i>
</pre>

<p id="47">
The function that implements the command is passed the
arguments. The arguments are read in one of three ways: as if by
<a href="../ansicl/dictentr/readread.htm"><b>read</b></a> using the current case
mode (for example <code>:case-sensitive-lower</code> or
<code>:case-sensitive-upper</code>); as if by <a href="../ansicl/dictentr/readread.htm"><b>read</b></a> using case-sensitive mode; or as a single
string. No predefined top-level commands use case-sensitive mode. The
only predefined top-level commands that read their argument as a
string are those that take filenames as arguments: <a href="tpl-commands/ld.htm"><b>:ld</b></a>, <a href="tpl-commands/cf.htm"><b>:cf</b></a>, <a href="tpl-commands/cload.htm"><b>:cload</b></a>, <a href="tpl-commands/cd.htm"><b>:cd</b></a>, and <a href="tpl-commands/pushd.htm"><b>:pushd</b></a>. All other predefined top-level
commands read their arguments in the current case mode. When the user
defines a top-level command (using the macro tpl:alias described in
section <a href="#adding-new-commands-1">Section 11.0 Adding new top-level commands</a>) the case
sensitivity of input may be specified. Case sensitivity in general is
discussed in section <a href="case.htm">case.htm</a>.
</p>



<hr><h2 id="48"><a name="getting-help-for-tpl-commands-2">3.2 Getting help for top-level commands</a></h2>

<p id="49">
The <a href="tpl-commands/help.htm"><b>:help</b></a> top-level command
without an argument prints summary information on all top-level
commands. The summary information is fairly long. The number of lines
displayed before pausing is controlled by the variable <a href="variables/tpl/s_help-page-length_s.htm"><code>*help-page-length*</code></a>.
</p>

<p id="50">
With a command name argument, <a href="tpl-commands/help.htm"><b>:help</b></a> gives more detailed information for
that command. The command name argument should omit the leading
colon.
</p>



<hr><h2 id="51"><a name="command-history-2">3.3 Command and expression history</a></h2>

<p id="52">
As the user enters commands and expressions to the top-level, they
are recorded on a <i>history list</i>. The value of <a href="variables/tpl/s_history_s.htm"><code>*history*</code></a> is the maximum
number of inputs (commands or expressions) to which the history list
can grow. When the history list reaches its maximum size, the oldest
entry is discarded as each new one is added. Note that expressions and
commands typed to the top-level are added to the history list, but
input read from programs that are called from the top-level is not
remembered on the history list. (The Emacs-Lisp interface has an
additional entirely-separate mechanism that remembers all input.)
</p>
<p id="53">
Repeated entries (the same form or command entered more than once with
no intervening form or command) are collapsed into a single entry.
</p>

<p id="54">
The <a href="tpl-commands/history.htm"><b>:history</b></a> command prints the
history list. Commands in the following forms will retrieve items from
the history list:
</p>

<pre id="55">
:[+|-]number[?]
::pattern[? | +] 
</pre>

<p id="56">
These are redo commands. They allow re-execution of a previous input
without re-entering it. The expressions will be re-evaluated as if the
read-eval-print loop were entered at the eval stage. That is, the
input will not be re-read, so changes that affect the reader (such as
package inheritance, or the value of variables like <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> or <a href="../ansicl/dictentr/read-bas.htm"><code>*read-base*</code></a>) will have no
effect. This usually makes no difference but can occasionally be
confusing. See the example below for an explanation.
</p>
<p id="57">
The first format, :number, re-evaluates the <em>number</em>th input
expression on the history list.
</p>
<p id="58">
The second format searches the history list for input matching the
pattern and re-executes it. If the second form is entered without a
pattern, the last expression typed is re-evaluated.
</p>
<p id="59">
If + is given as an argument to the :: form, then the search will be
in reverse from the beginning of the history list forward, instead of
from the end backward. If ? is an argument to either format, the user
will be asked to confirm before re-execution of the command or
expression.
</p>

<p id="60">
Here is an example using these commands:
</p>

<pre id="61">
USER(1): (setq a 10)
10
USER(2): :his
 
1 (SETQ A 10)
2 :his
USER(3): (set 'b 'setq)
SETQ
USER(4): ::setq
(SET 'B 'SETQ)
SETQ
USER(5): ::a
(SETQ A 10)
10
USER(6): :his
 
1 (SETQ A 10)
2 :his
3 (SET 'B 'SETQ)
4 (SET 'B 'SETQ)
5 (SETQ A 10)
6 :his
USER(7): :5
(SETQ A 10)
10
USER(8):
</pre>



<hr><h2 id="62"><a name="history-anomalies-2">3.4 Anomalies with the :history list</a></h2>

<p id="63">
The history list mechanism remembers both the form read as input as
well as a string representation of that form. The string is the
<a href="../ansicl/dictentr/write-to.htm"><b>write-to-string</b></a> with the input
form.  The string is used to match the pattern given to the <strong>::
</strong>command, but the form that is evaluated is the original form
(that is, the string is not reread). In most cases, the behavior is
the same as if the original input had been reentered, but there are at
least two circumstances where this is not the case.
</p>

<ol>

<li id="64">
If the package environment has changed (by either the current package
changing or new packages being used), symbols will still be evaluated
in the same package as when the expression was originally read.
</li>
<li id="65">
If a symbol available in the current package is entered with a package
qualifier, the package qualifier is suppressed in the string which is
stored on the history list. The example below should make these
distinctions clear.
</li>
<li id="66">
If there have been changes to reader controls such as
<strong>*read-base*</strong> or <a href="../ansicl/dictentr/readtab0.htm"><b>readtable-case</b></a>.
</li>
</ol>

<p id="67">
In the example, we call a function in the
<code>foreign-functions</code> package,
<strong>convert-to-lang</strong>. This function takes a string (which
is usually a function name) and returns the address of the
function. The <code>foreign-functions</code> package has not
been made accessible (with <a href="../ansicl/dictentr/use-pack.htm"><b>use-package</b></a>) and we neglect to preface
<strong>convert-to-lang</strong> with the <strong>ff:</strong> package
qualifier. Not surprisingly, we get an `undefined function'
error.
</p>

<pre id="68">
USER(8): (convert-to-lang "foo")
Error: attempt to call `CONVERT-TO-LANG' which is an undefined function.
  [condition type: UNDEFINED-FUNCTION]
 
Restart actions (select using :continue):
  0: Try calling CONVERT-TO-LANG again
  1: Try calling FOREIGN-FUNCTIONS:CONVERT-TO-LANG instead
  2: Return a value
  3: Try calling a different function
  4: Setf the symbol function of CONVERT-TO-LANG and call it again
</pre>

<p id="69">
Now we call <a href="../ansicl/dictentr/use-pack.htm"><b>use-package</b></a> again
to make external symbols in the <code>foreign-functions</code>
package accessible. (Incidently, we get a symbol conflict error at
this point. This is a continuable error and the appropriate thing to
do is <a href="tpl-commands/continue.htm"><b>:continue</b></a>. See <a href="errors.htm#using-package-2">Using package 
results in name conflicts...</a> in
<a href="errors.htm">errors.htm</a> for more information.) We enter the
command <strong>::convert</strong> to re-evaluate our call to
<strong>convert-to-lang</strong> but another "undefined
function" error is signaled! This happens because Lisp has
remembered and re-evaluates the identical (in the sense of <a href="../ansicl/dictentr/eq.htm"><b>eq</b></a>) form. The
<strong>convert-to-lang</strong> symbol that is the car of that form
is still the same. The symbol used to be interned in the
<code>cl-user</code> package and is now uninterned by the
<a href="../ansicl/dictentr/use-pack.htm"><b>use-package</b></a> continuation, but
it still has no function binding. At the end we call
<strong>ff:convert-to-lang</strong> with the package qualifier and
display the history list. Note that the qualifier is not stored.  When
we enter <strong>::ff</strong>, it is the <a href="../ansicl/dictentr/use-pack.htm"><b>use-package</b></a> form called well before
<strong>ff:convert-to-lang</strong> that is repeated.
</p>

<pre id="70">
USER(9): :pop
USER(10): (use-package :ff)
Error: Using package `FOREIGN-FUNCTIONS' results in name conflicts for these
symbols: CONVERT-TO-LANG
  [condition type: PACKAGE-ERROR]
 
Restart actions (select using :continue):
  0: Unintern the conflicting symbols from the `COMMON-LISP-USER' package.
[1c] USER(11): :cont 0
T
USER(12): :hist
 
;; [unrelated items deleted]
8 (#:CONVERT-TO-LANG "foo")
9 :pop
10 (USE-PACKAGE :FF)
11 :cont 0
12 :hist
USER(13): ::convert
(#:CONVERT-TO-LANG "foo")
Error: attempt to call `#:CONVERT-TO-LANG' which is an undefined function.
  [condition type: UNDEFINED-FUNCTION]
  
Restart actions (select using :continue):
  0: Try calling #:CONVERT-TO-LANG again
  1: Try calling CONVERT-TO-LANG instead
  2: Return a value
  3: Try calling a different function
  4: Setf the symbol function of #:CONVERT-TO-LANG and call it again
[1] USER(14): :pop
USER(15): (convert-to-lang "foo")
"_foo"
USER(16): (ff:convert-to-lang "bar")
"_bar"
USER(17): :hist :count 4
;; Note the package qualifier is *not* saved if the
;; symbol is accessible in the current package:
15 (CONVERT-TO-LANG "foo")
16 (CONVERT-TO-LANG "bar")
USER(18): ::ff
(USE-PACKAGE :FF)
T
</pre>




<hr><hr><h2 id="71"><a name="break-levels-1">4.0 Break levels</a></h2>

<p id="72">The initial read-eval-print loop when a listener starts is called
the <i>top-level read-eval-print loop</i>. This can be thought of as
break level zero (but see below).  A higher <i>break level</i> and a
recursive read-eval-print loop can only be entered by a call to
<a href="../ansicl/dictentr/invoke-d.htm"><b>invoke-debugger</b></a>. Each new call
(assuming that earlier calls have not yet been exited) puts the
listener into a new, higher break level.  <a href="../ansicl/dictentr/invoke-d.htm"><b>invoke-debugger</b></a> is typically called, directly or
indirectly, in one of these ways: </p>

<ol>
  <li id="73">through the functions <a href="../ansicl/dictentr/error0.htm"><b>error</b></a>, <a href="../ansicl/dictentr/cerror.htm"><b>cerror</b></a>, <a href="../ansicl/dictentr/break.htm"><b>break</b></a>, <a href="../ansicl/dictentr/signal.htm"><b>signal</b></a> (if the signaled condition is of a type present on <code>cl:*break-on-signals*</code>),
    and <a href="../ansicl/dictentr/warn.htm"><b>warn</b></a> (via <a href="../ansicl/dictentr/signal.htm"><b>cl:signal</b></a>); </li>
  <li id="74">through the tracer, stepper, or inspector;</li>
  <li id="75">by an external signal, such as a keyboard interrupt.</li>
</ol>

<p id="76">Note that some things (most notably the result of an end-of-file on
the input stream) behave very differently depending on whether Lisp is
in the top-level read-eval-print loop or a break level. Thus, it is
inaccurate to think of the top-level read-eval-print loop merely as
break level 0. </p>

<p id="77">Entry to a new break level prints the condition passed to <a href="../ansicl/dictentr/invoke-d.htm"><b>invoke-debugger</b></a>; typically this serves
as an &quot;error message&quot; indicating why the break occurred.
When the listener returns from a higher break level to a lower break
level n&gt;0 , the original condition for entering break level
<code>n</code> is printed as a reminder. A break level is exited
by using one of the <a href="tpl-commands/pop.htm"><b>:pop</b></a>, <a href="tpl-commands/prt.htm"><b>:prt</b></a>, <a href="tpl-commands/continue.htm"><b>:continue</b></a>, <a href="tpl-commands/restart.htm"><b>:restart</b></a>, <a href="tpl-commands/return.htm"><b>:return</b></a>, or <a href="tpl-commands/reset.htm"><b>:reset</b></a> commands, or by execution of any
normal lisp form that performs a non-local return to some
dynamically-surrounding construct. The :pop command is also invoked by
typing an end-of-file (usually Control-D on Unix systems). </p>

<p id="78">Since Lisp allows type ahead, that is to enter forms ahead of the
top-level prompt, there is an issue about what happens to pending
input when an error occurs. The two choices in Allegro CL are </p>

<ol>
  <li id="79">forms after an error are flushed (that is forgotten), or </li>
  <li id="80">forms after an error are preserved and executed normally.</li>
</ol>

<p id="81">The choice is controlled by the variable <a href="variables/excl/s_clear-input-on-error_s.htm"><code>*clear-input-on-error*</code></a>. </p>

<p id="82">The following example illustrates the difference between the two
settings of <a href="variables/excl/s_clear-input-on-error_s.htm"><code>*clear-input-on-error*</code></a>. Suppose the variables
b1, b2, and b3 are all bound with values 1, 2, 3, while u1 and u2 are
unbound (note that the prompts and the returned values can get
interleaved): </p>

<pre id="83">
USER(19): (setq b1 1 b2 2 b3 3)
3
USER(20): b1 b2 b3
 
1
USER(21):
2
USER(22): 3
USER(23): (setq *clear-input-on-error* nil)
NIL
USER(24): u1 b1 u2
 
Error: Attempt to take the value of the unbound variable `U1'.
  [condition type: UNBOUND-VARIABLE]
[1] USER(25):
1
[1] USER(26): Error: Attempt to take the value of the unbound variable `U2'.
[condition type: UNBOUND-VARIABLE]
[2] USER(27): :reset
USER(28): (setq *clear-input-on-error* t)
T
USER(29): u1 b1 u2
 
Error: Attempt to take the value of the unbound variable `U1'.
  [condition type: UNBOUND-VARIABLE]
[1] USER(30):
</pre>


<p id="84">Reader errors (such as an unknown package) occurring on the
listener's input stream are a special case and unconditionally flush
the input stream.</p>

<hr><h2 id="85"><a name="break-level-commands-2">4.1 Commands to manipulate break levels:</a></h2>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="21%" VALIGN="TOP"><b>Command</b></td>
    <td WIDTH="39%" VALIGN="TOP"><b>Arguments (if any)</b></td>
    <td WIDTH="40%" VALIGN="TOP"><b>Brief Description</b></td>
  </tr>
  <tr>
    <td WIDTH="21%" VALIGN="TOP"><a href="tpl-commands/reset.htm"><b>:reset</b></a></td>
    <td WIDTH="39%" VALIGN="TOP"> </td>
    <td WIDTH="40%" VALIGN="TOP">Reset the state of the top-level and throw to the top-level
    read-eval-print loop.</td>
  </tr>
  <tr>
    <td WIDTH="21%" VALIGN="TOP"><a href="tpl-commands/continue.htm"><b>:continue</b></a></td>
    <td WIDTH="39%" VALIGN="TOP"><code>&optional (</code><code><em>restart-number</em></code><code> 0)</code></td>
    <td WIDTH="40%" VALIGN="TOP">Cause computation to continue with the effects for the
    restart action specified by the argument</td>
  </tr>
  <tr>
    <td WIDTH="21%" VALIGN="TOP"><a href="tpl-commands/pop.htm"><b>:pop</b></a></td>
    <td WIDTH="39%" VALIGN="TOP"><code>&optional (</code><code><em>n</em></code><code> 1)</code></td>
    <td WIDTH="40%" VALIGN="TOP">Pop up to the previous break level, or to the nth previous
    one, if <em>n</em> is given.</td>
  </tr>
  <tr>
    <td WIDTH="21%" VALIGN="TOP"><a href="tpl-commands/prt.htm"><b>:prt</b></a></td>
    <td WIDTH="39%" VALIGN="TOP"> </td>
    <td WIDTH="40%" VALIGN="TOP">Return to the previous level, and re-evaluate the expression
    that caused the entry into the break level.</td>
  </tr>
  <tr>
    <td WIDTH="21%" VALIGN="TOP"><a href="tpl-commands/error.htm"><b>:error</b></a></td>
    <td WIDTH="39%" VALIGN="TOP"> </td>
    <td WIDTH="40%" VALIGN="TOP">Print the condition associated with the current break level
    and all available restarts.</td>
  </tr>
</table>

<p id="86">Here is a transcript showing some of the commands just defined.</p>

<pre id="87">
USER(31): (setq foo bad)
Error: Attempt to take the value of the unbound variable `BAD'.
  [condition type: UNBOUND-VARIABLE]
[1] USER(32): (/ 1 0)
Error: Attempt to divide 1 by zero
  [condition type: DIVISION-BY-ZERO]
[2] USER(33): :pop
Previous error: Attempt to take the value of the unbound variable `BAD'.
[1] USER(34): (setq bad :not-so-bad)
:NOT-SO-BAD
[1] USER(35): :prt
USER(36): (SETQ FOO BAD) ;; :prt evaluation
:NOT-SO-BAD
USER(37): foo
:NOT-SO-BAD
USER(38): (cerror "just continue" "error!")
Error: error!
 
Restart actions (select using :continue):
  0: just continue
[1c] USER(39): :cont 0
NIL
USER(40):
</pre>



<hr><hr><h2 id="88"><a name="commands-for-compile-and-load-1">5.0 Commands for compiling and loading</a></h2> 

<p id="89">The top-level commands described in this section deal with
compiling and loading files.
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="22%" VALIGN="TOP"><b>Command</b></td>
    <td WIDTH="28%" VALIGN="TOP"><b>Arguments (if any)</b></td>
    <td WIDTH="50%" VALIGN="TOP"><b>Brief Description</b></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP"><a href="tpl-commands/cf.htm"><b>:cf</b></a></td>
    <td WIDTH="28%" VALIGN="TOP"><code>&rest files</code></td>
    <td WIDTH="50%" VALIGN="TOP">The files specified are compiled. With no arguments, the file
    names specified in the most-recent :cf command are used.  The compiled files are not
    loaded.</td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP"><a href="tpl-commands/ld.htm"><b>:ld</b></a></td>
    <td WIDTH="28%" VALIGN="TOP"><code>&rest files</code></td>
    <td WIDTH="50%" VALIGN="TOP">The files specified are loaded. With no arguments, the file
    names in the most-recent :ld command are used.</td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP"><a href="tpl-commands/cload.htm"><b>:cload</b></a></td>
    <td WIDTH="28%" VALIGN="TOP"><code>&rest files</code></td>
    <td WIDTH="50%" VALIGN="TOP">The files specified are compiled if necessary (that is,
    unless a compiled file already exists and is newer than its source file) and then the
    compiled file is loaded. With no arguments, the file names in the last :cload command are
    used. Note that only a change to the source file causes a source file to be considered
    newer than the compiled file. Changes in Lisp, such as changing global values of
    optimization qualities such as speed and safety, do not trigger a compile.</td>
  </tr>
</table>

<p id="90">Note that these commands (as well as the underlying functions
<a href="../ansicl/dictentr/compile-.htm"><b>compile-file</b></a> and <a href="../ansicl/dictentr/load.htm"><b>load</b></a>) infer omitted file types
(e.g. <strong>.cl</strong> or <strong>.fasl</strong>) automatically.
See <a href="variables/system/s_load-search-list_s.htm"><code>*load-search-list*</code></a>.</p>

<hr><h2 id="91"><a name="arguments-read-as-strings-2">5.1 File arguments are read as strings</a></h2>

<p id="92">The commands that take one or more filename arguments read the
argument as a single string. That string is subsequently parsed into
multiple filenames using space as a delimiter. (These commands
therefore cannot take a filename containing an embedded space.)
Filenames should not be quoted. To load <em>foo.cl</em>, do:</p>

<pre id="93">
USER(1): :ld foo.cl
</pre>

<p id="94">But if you use quotes, it will fail:</p>

<pre id="95">
USER(2): :ld "foo.cl"
Error: "\"foo.cl\"" does not exist, cannot load
  [condition type: FILE-ERROR]
</pre>





<hr><hr><h2 id="96"><a name="interaction-with-mp-1">6.0 Top-level interaction with multiprocessing </a></h2>

<p id="97">General information on multiprocessing can be found in
<a href="multiprocessing.htm">multiprocessing.htm</a>.</p>

<p id="98">When the Allegro CL multiprocessing facility is in use there may be
several Lisp processes running simultaneously in a single executing
Lisp image, sharing the same heap, streams, and other resources.  A
lisp listener running in one of these processes operates much the same
as if multiprocessing were not in use.  However, there are additional
capabilities whereby a listener running in one process may be used to
investigate and debug another process. Users not employing
multiprocessing may skip this section. </p>

<p id="99">For this section the term <em>listener</em> will refer specifically
to the process in which a lisp listener is running and which is
executing commands.  The Allegro CL listener maintains a concept of
the<em> focus</em> process.  The following debugger commands apply to
the focus process:</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p id="100"><a href="tpl-commands/zoom.htm"><b>:zoom</b></a><br>
      <a href="tpl-commands/up.htm"><b>:up</b></a><br>
      <a href="tpl-commands/dn.htm"><b>:dn</b></a><br>
      <a href="tpl-commands/find.htm"><b>:find</b></a><br>
      <a href="tpl-commands/return.htm"><b>:return</b></a><br>
      <a href="tpl-commands/restart.htm"><b>:restart</b></a><br>
      <a href="tpl-commands/error.htm"><b>:error</b></a><br>
      <a href="tpl-commands/current.htm"><b>:current</b></a><br>
      <a href="tpl-commands/local.htm"><b>:local</b></a><br>
      <a href="tpl-commands/prt.htm"><b>:prt</b></a><br>
      <a href="tpl-commands/pop.htm"><b>:pop</b></a><br>
      <a href="tpl-commands/reset.htm"><b>:reset</b></a><br>
      <a href="tpl-commands/continue.htm"><b>:continue</b></a><br>
      <a href="tpl-commands/set-local.htm"><b>:set-local</b></a><br>
      <a href="tpl-commands/top.htm"><b>:top</b></a><br>
      <a href="tpl-commands/bottom.htm"><b>:bottom</b></a></p>
    </blockquote>
  </blockquote>
</blockquote>

<p id="101">Initially a listener is focussed on itself and these commands
report and operate on the listener process' own execution state. The
<a href="tpl-commands/focus.htm"><b>:focus</b></a> command allows the
listener's focus to be changed to another process. For a process to be
focussed upon and debugged, it must first be arrested. The focus
command does this automatically if necessary, and when focus is
removed from the process it will be unarrested. Commands such as
:return and :pop that implicitly cause the process to resume execution
will automatically remove focus from the process and unarrest it.  The
<a href="tpl-commands/arrest.htm"><b>:arrest</b></a> and <a href="tpl-commands/unarrest.htm"><b>:unarrest</b></a> commands provide additional
explicit controls.</p>

<hr><h2 id="102"><a name="process-comms-args-2">6.1 Argument processing for  :processes, :focus, :arrest, :unarrest and :kill</a></h2>

<p id="103">
Here is how arguments are processed for the commands 
<a href="tpl-commands/processes.htm"><b>:processes</b></a>, 
<a href="tpl-commands/focus.htm"><b>:focus</b></a>, 
<a href="tpl-commands/arrest.htm"><b>:arrest</b></a>, 
<a href="tpl-commands/unarrest.htm"><b>:unarrest</b></a>,
and <a href="tpl-commands/kill.htm"><b>:kill</b></a>.
</p>
<p id="104">
Except for <a href="tpl-commands/focus.htm"><b>:focus</b></a>, the commands
take an arbitrary number of arguments, each designating a set of
processes. Some of the commands treat an empty argument list
specially; <a href="tpl-commands/unarrest.htm"><b>:unarrest</b></a> also treats
the single argument :all as a special case.
</p>
<p id="105">
Generally, a designator is a string or a symbol or an integer (that
returned by <a href="operators/mp/process-sequence.htm"><b>mp:process-sequence</b></a> applied to the process),
but if an argument is a symbol or a list, it is first evaluated to get
the designator. Otherwise the argument itself is used as the
designator.
</p>
<p id="106">
When a designator is a symbol, its <a href="../ansicl/dictentr/symbol-n.htm"><b>symbol-name</b></a> is used as the designator. (Note the
symbol here is a designator. An argument symbol or list is evaluated
and if the result is a symbol, then the symbol name is used.)
</p>
<p id="107">
A designator may match one process, no processes, or multiple
processes, and designates the set of matching processes.
Details of this matching are described below.
</p>
<p id="108">
The command operates on a set of processes designated by the arguments.
No process appears in the set more than once, even if multiple
designators designate the same process.
</p>
<p id="109">
An integer designator matches the process whose <a href="operators/mp/process-sequence.htm"><b>mp:process-sequence</b></a> value is <a href="../ansicl/dictentr/eql.htm"><b>eql</b></a> to that integer, if there is one.
</p>
<p id="110">
A string designator is compared to the process-names of all current
processes. If any matches are exact, then the designator matches
all processes with that name. If no matches are exact, the designator
matches all processes whose names contain the designator as a substring.
</p>
<p id="111">
Except for the <a href="tpl-commands/processes.htm"><b>:processes</b></a> command,
specifying any designator that matches no processes or matches more
than one process invalidates the entire list and aborts the command
with a diagnostic.
</p>



<a name="proc-command"></a>

<hr><h2 id="112"><a name="process-comm-2">6.2 More on the :processes command</a></h2>


<p id="113">The <a href="tpl-commands/processes.htm"><b>:processes</b></a> command prints
information about processes in the image. The minimal abbreviation
of <b>:processes</b> is <b>:pro</b>.</p>


<pre id="114">
cg-user(1): :pro
DP   Id Seq  Dis Sec   dSec Pri State    Process Name, Whostate, Arrest
 * 1504   3 2123   1    0.9   8 runnable IDE GUI
 *  738   2    3   0    0.1   0 io-gated Initial Lisp Listener, waiting-for-input
 * 21f8   4   54   0    0.0   0 runnable Listener 1
cg-user(2): 
</pre>
<p id="115">
The column headings are described by
the <a href="tpl-commands/help.htm"><b>:help</b></a> command applied
to <b>:proc</b>:
</p>
<pre id="116">
cg-user(4): :help proc

    Prints the state for the argument PROCESSES, or sys:*all-processes*
if none.  Each argument may be a process object, the name of a process,
or a form to evaluate yielding a process or name.
The columns printed for each process are:
 D         `*' if the process' thread is to be debugged (and thus conservatively gc'd).
 P         `*' if the process' thread status is set to be profiled.
 Id        The OS identifier of the associated thread
 Seq       The process sequence number
 Dis       The number of times this process has been resumed by the
           scheduler since the previous report.
 Sec       The total cpu time consumed by this process (approximate).
 dSec      The cpu time consumed by this process since the last report.
 Priority  The integer process priority.
 State     Inactive, runnable, or waiting.
These are followed by the process name, the process whostate (if any),
and a list of arrest reasons (if any).
The output is sorted on the dSec column, most cpu-intensive first.

cg-user(5): 
</pre>





<hr><h2 id="117"><a name="focus-etc-comms-2">6.3 More on the :focus, :arrest, and :unarrest commands</a></h2>




<p id="118">
The arguments to the process commands (:focus, :arrest, :unarrest,
and :processes) are evaluated.  A process may be identified by the
process object itself, by a variable bound to the process object, or
by the process' name. Process names are strings. Since process names
are often long, these top-level commands will accept an unambiguous
initial substring of a process name. If the abbreviation is ambiguous,
the command will be aborted. (Note that some commands, such as <a href="tpl-commands/arrest.htm"><b>:arrest</b></a>, process their arguments
sequentially. In these cases, all arguments preceding the one causing
the error will have been processed. Any arguments following the
ambiguous argument will not be processed.) Process names and
abbreviations are case-sensitive. Thus "Thinker" is
different from "thinker". </p>

<p id="119">When Allegro CL is run using the Emacs-Lisp interface, a background
process entering the debugger will automatically create a new Lisp
listener buffer in which to debug the broken process.  This eliminates
much of the need for the focus mechanism, although it is still an
appropriate tool to investigate the state of a background process that
is not in a break.</p>

<p id="120">If for any reason background processes do not create new listener
buffers when running under the Emacs-Lisp interface, evaluate the
following form:</p>

<pre id="121">
(excl:use-background-streams)
</pre>


<p id="122">See <a href="debugging.htm">debugging.htm</a> for more information.</p>





<hr><hr><h2 id="123"><a name="commands-for-kill-and-exit-1">7.0 Commands for killing processes and exiting Lisp</a></h2>

<p id="124">There are top-level equivalents to the <a href="operators/excl/exit.htm"><b>exit</b></a> and <a href="operators/mp/process-kill.htm"><b>process-kill</b></a> functions that are
used to exit Lisp and to kill processes. These top-level commands work
slightly differently from their associated functions, since the
top-level attempts to protect the user from unrecoverable typing
mistakes.  In the multiprocessing environment, users must understand
the difference between killing a process and exiting the entire
Lisp.</p>

<p id="125">There are three relevant commands, <a href="tpl-commands/kill.htm"><b>:kill</b></a>, <a href="tpl-commands/exit.htm"><b>:exit</b></a> and EOF. (EOF means the end-of-file
character or signal, control-D on many systems.) The <a href="tpl-commands/kill.htm"><b>:kill</b></a> command kills the processes, but if
there is only one process, it seeks confirmation. The <a href="tpl-commands/exit.htm"><b>:exit</b></a> command terminates the Lisp image,
but seeks confirmation if there is more than one process. EOF is
equivalent to the <a href="tpl-commands/pop.htm"><b>:pop</b></a> command
when typed at a break level but is equivalent to <a href="tpl-commands/exit.htm"><b>:exit</b></a> when typed at the top-level
(i.e. break level zero). Users who use EOF for <a href="tpl-commands/pop.htm"><b>:pop</b></a> may want to set the variable <a href="variables/tpl/s_exit-on-eof_s.htm"><code>*exit-on-eof*</code></a> to a large
number to protect Lisp from accidental exit. </p>

<hr><hr><h2 id="126"><a name="commands-misc-1">8.0 Miscellaneous top-level commands</a></h2>

<p id="127">The following commands are also available in a lisp listener. In
addition, debugging commands (such as <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>) described in
<a href="debugging.htm">debugging.htm</a> (and not listed here) are
available.</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Command</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments (if any)</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Brief Description</b></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/macroexpand.htm"><b>:macroexpand</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><code><em>expression</em></code></td>
    <td WIDTH="33%" VALIGN="TOP">Pretty print the macroexpansion of expression, which is not
    evaluated. The expression must fit on a single line.</td>
  </tr>
<tr>
<td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/optimize.htm"><b>:optimize</b></a></td>
<td WIDTH="33%" VALIGN="TOP"> </td>
<td WIDTH="33%" VALIGN="TOP">

Query user for values for the compiler optimizations safety,
space, speed, debug, and compilation-speed and other compiler
options. See <a href="compiling.htm">compiling.htm</a>.</td>
</tr>
<tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/package.htm"><b>:package</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><code>&optional<em> package-name</em></code></td>
    <td WIDTH="33%" VALIGN="TOP">Without an argument, print the name of the current package.
    With an argument, make that package the current package.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/printer-variables.htm"><b>:printer-variables</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"> </td>
    <td WIDTH="33%" VALIGN="TOP">Prompt the user for new values for various printer control
    variables.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/cd.htm"><b>:cd</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><code>&optional<em> dir</em></code></td>
    <td WIDTH="33%" VALIGN="TOP">Change the current directory to <em>dir</em>, defaulting to
    the user's home directory (C:\ on Windows). See <a href="operators/excl/current-directory.htm"><b>current-directory</b></a> and <a href="operators/excl/chdir.htm"><b>chdir</b></a>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/pushd.htm"><b>:pushd</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><code><em>dir</em></code></td>
    <td WIDTH="33%" VALIGN="TOP">Change to <em>dir</em> and push the previous current
    directory to the directory stack.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/popd.htm"><b>:popd</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"> </td>
    <td WIDTH="33%" VALIGN="TOP">Pop the directory stack and change to that directory.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/dirs.htm"><b>:dirs</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"> </td>
    <td WIDTH="33%" VALIGN="TOP">Print the directory stack.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/pwd.htm"><b>:pwd</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"> </td>
    <td WIDTH="33%" VALIGN="TOP">Print the current directory.</td>
  </tr>
</table>

<hr><hr><h2 id="128"><a name="tpl-timing-1">9.0 Automatic timing information</a></h2>

<p id="129">
The value of the variable <a href="variables/tpl/s_time-threshold_s.htm"><code>*time-threshold*</code></a> can be a positive
number. If it is, then evaluations which take longer than that number
of seconds will have a time report (such as printed by the <a href="../ansicl/dictentr/time.htm"><b>time</b></a> macro) printed along
with the value of the evaluation. If <a href="variables/tpl/s_time-threshold_s.htm"><code>*time-threshold*</code></a> is <code>nil</code> (which is its initial value), no time report is
printed automatically.
</p>
<pre id="130">
cl-user(1): (setq top-level:*time-threshold* 5.0)
5.0
cl-user(2): (sleep 4)
nil
cl-user(3): (sleep 5.5)
; cpu time (non-gc) 0 msec user, 0 msec system
; cpu time (gc)     0 msec user, 0 msec system
; cpu time (total)  0 msec user, 0 msec system
; real time  5,495 msec
; space allocation:
;  4 cons cells, 32 other bytes, 0 static bytes
nil
cl-user(4): 
</pre>

<hr><hr><h2 id="131"><a name="tpl-vars-1">10.0 Top-level variables</a></h2>

<p id="132">The following variables are maintained or used by the top-level. </p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="35%" VALIGN="TOP"><b>Variable</b></td>
    <td WIDTH="65%" VALIGN="TOP"><b>Description</b></td>
  </tr>
  <tr>
    <td WIDTH="35%" VALIGN="TOP"><a href="variables/tpl/s_command-char_s.htm"><code>*command-char*</code></a></td>
    <td WIDTH="65%" VALIGN="TOP">The character recognized as the prefix for top-level
    commands. Initially the colon character.</td>
  </tr>
<tr>
<td WIDTH="35%" VALIGN="TOP">
<a href="variables/tpl/s_prompt_s.htm"><code>*prompt*</code></a></td>
<td WIDTH="65%" VALIGN="TOP">
The value of this variable is used for the prompt.</td>
</tr>
<tr>
<td WIDTH="35%" VALIGN="TOP"><a href="variables/tpl/s_read_s.htm"><code>*read*</code></a></td>
<td WIDTH="65%" VALIGN="TOP">
If true, the function to be used to read top-level input.
If <code>nil</code>, 
<a href="../ansicl/dictentr/readread.htm"><b>read</b></a> is used. 
Setting this variable is not recommended.
</td>
</tr>
<tr>
<td WIDTH="35%" VALIGN="TOP"><a href="variables/tpl/s_eval_s.htm"><code>*eval*</code></a></td>
<td WIDTH="65%" VALIGN="TOP">If true, the function to be used to evaluate top-level
input. If <code>nil</code>, cl:eval is used. Setting this variable is not recommended.</td>
</tr>
<tr>
<td WIDTH="35%" VALIGN="TOP">
<a href="variables/tpl/s_print_s.htm"><code>*print*</code></a>
</td>
<td WIDTH="65%" VALIGN="TOP">

If true, the function to be used to print top-level output. If <code>nil</code>, <a href="../ansicl/dictentr/writepri.htm"><b>cl:prin1</b></a>
is used.  Care should be used if you setb this variable because an
inappropriate value may cause top-level problems. Symbols naming
Standard Common Lisp
print functions, such as <a href="../ansicl/dictentr/writepri.htm"><b>cl:princ</b></a>, are suitable values.


</td>
</tr>
  <tr>
    <td WIDTH="35%" VALIGN="TOP"><a href="variables/tpl/s_print-level_s.htm"><code>*print-level*</code></a></td>
    <td WIDTH="65%" VALIGN="TOP"><code>cl:*print-level*</code> is bound to this when top-level
    output is being printed.</td>
  </tr>
  <tr>
    <td WIDTH="35%" VALIGN="TOP"><a href="variables/tpl/s_print-length_s.htm"><code>*print-length*</code></a></td>
    <td WIDTH="65%" VALIGN="TOP"><code>cl:*print-length*</code> is bound to this when
    top-level output is being printed.</td>
  </tr>
  <tr>
    <td WIDTH="35%" VALIGN="TOP"><a href="variables/tpl/s_reset-hook_s.htm"><code>*reset-hook*</code></a></td>
    <td WIDTH="65%" VALIGN="TOP">If true and bound to a valid function (something
    acceptable to <a href="../ansicl/dictentr/funcall.htm"><b>funcall</b></a>), then this function is called (with no arguments) after
    executing the <a href="tpl-commands/reset.htm"><b>:reset</b></a> command.</td>
  </tr>
</table>

<p id="133">Sometimes a form executed for side effect will return a huge or
circular data object that is not itself of interest. The <a href="variables/tpl/s_print-level_s.htm"><code>*print-level*</code></a> and <a href="variables/tpl/s_print-length_s.htm"><code>*print-length*</code></a> variables
exist to limit printed output  from evaluated forms. If this
print truncation should ever truncate desired printed output from a
form, following that form with <strong>(pprint *)</strong> will
reprint the returned value without special top-level truncation.</p>

<hr><hr><h2 id="134"><a name="adding-new-commands-1">11.0 Adding new top-level commands</a></h2>

<p id="135">The top-level command set is extensible. A top-level <i>alias</i>
is a user-defined listener command. It is invoked the same way as
built-in commands. The difference between built-in commands and
aliases is that aliases can be removed, one at a time or all at
once. </p>

<p id="136">The macro <a href="operators/tpl/alias.htm"><b>alias</b></a>
defines a top-level alias. </p>

<p id="137">The function <a href="operators/tpl/remove-alias.htm"><b>remove-alias</b></a> removes user-defined
top-level aliases. It is not possible to remove system-defined
top-level commands.</p>

<p id="138">The function <a href="operators/tpl/do-command.htm"><b>do-command</b></a> will programmatically execute
a top-level command.</p>

<p id="139">In the following example, we define a new top-level command. </p>

<pre id="140">
USER(40): (top-level:alias &quot;ff&quot; (&amp;rest args)
             &quot;my alias
for the :find command&quot;
             (apply
#'top-level:do-command &quot;find&quot; args))
USER(41): (defun test (x) (break &quot;testing....&quot;))
TEST
USER(42): (test nil)
Break: testing....
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(43): :zoom
Evaluation stack:
 
  (BREAK &quot;testing....&quot;)
-&gt;(TEST NIL)
  (EVAL (TEST NIL))
  (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
  (TPL:START-INTERACTIVE-TOP-LEVEL
         #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM
@ #x190b4e&gt;
         #&lt;Function
TOP-LEVEL-READ-EVAL-PRINT-LOOP @ #x2ed8c6&gt; ...)
[1c] USER(44): :ff eval
Evaluation stack:
 
  (BREAK &quot;testing....&quot;)
  (TEST NIL)
-&gt;(EVAL (TEST NIL))
  (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
  (TPL:START-INTERACTIVE-TOP-LEVEL
         #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM
@ #x190b4e&gt;
         #&lt;Function
TOP-LEVEL-READ-EVAL-PRINT-LOOP @ #x2ed8c6&gt; ...)
[1c] USER(45):

</pre>


</body><hr><p id="2"><small>Copyright (c) 1998-2017, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page was not revised from the 10.0 page.</small><br><small>Created 2017.2.15.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/top-level.htm">10.0 version</a></td></tr></table></html>