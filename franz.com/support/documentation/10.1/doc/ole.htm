<html><head><meta name="viewport" content="width=device-width, initial-scale=1"> <meta http-equiv="content-type" content="text/html; charset=UTF-8"> <link rel="stylesheet" href="acldoc-styles.css" type="text/css"><title>OLE Interface</title></head><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/ole.htm">10.0 version</a></td></tr></table><h1 id="2">OLE Interface</h1><p id="3">This document contains the following sections:</p><a href="#intro-1">1.0 Introduction to OLE support</a><br><a href="#highlevel-intro-1">2.0 Introduction to high-level OLE/OCX interface</a><br>&nbsp;&nbsp;&nbsp;<a href="#ocx-and-acl-2">2.1 OCX objects and Allegro CL</a><br>&nbsp;&nbsp;&nbsp;<a href="#type-libraries-2">2.2 Type Libraries</a><br>&nbsp;&nbsp;&nbsp;<a href="#typelib-coclass-2">2.3 Typelib entity: CoClass</a><br>&nbsp;&nbsp;&nbsp;<a href="#typelib-enum-2">2.4 Typelib entity: Enum</a><br>&nbsp;&nbsp;&nbsp;<a href="#typelib-interface-2">2.5 Typelib entity: Interface</a><br>&nbsp;&nbsp;&nbsp;<a href="#internals-reference-2">2.6 OLE/OCX low-level internals discussion</a><br>&nbsp;&nbsp;&nbsp;<a href="#highlevel-reference-2">2.7 Reference guide to interface operators</a><br>&nbsp;&nbsp;&nbsp;<a href="#high-index-2">2.8 Index to high-level interface operators</a><br><a href="#lowlevel-intro-1">3.0 Introduction to the low-level OLE interface</a><br>&nbsp;&nbsp;&nbsp;<a href="#sample-programs-2">3.1 Sample Programs</a><br>&nbsp;&nbsp;&nbsp;<a href="#system-structure-2">3.2 System Structure</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#basic-3">3.2.1 Basic Concepts</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#clos-3">3.2.2 Important CLOS Issues for an Allegro CL OLE Application</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#special-data-3">3.2.3 Special OLE Data Types</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#language-and-locale-3">3.2.4 Language and Locale</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#interface-3">3.2.5 Interfaces and Objects</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#registry-3">3.2.6 The Registry</a><br>&nbsp;&nbsp;&nbsp;<a href="#writing-auto-client-2">3.3 Writing an Automation Client</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dynamic-naming-3">3.3.1 Dynamic naming</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#unique-ids-3">3.3.2 Unique ids</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#classes-3">3.3.3 Classes</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#remote-autotool-3">3.3.4 The Lisp remote-autotool Class</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#setup-3">3.3.5 Set-up</a><br>&nbsp;&nbsp;&nbsp;<a href="#writing-a-server-2">3.4 Writing a Server</a><br>&nbsp;&nbsp;&nbsp;<a href="#defining-interfaces-2">3.5 Defining Interfaces</a><br>&nbsp;&nbsp;&nbsp;<a href="#low-level-view-2">3.6 Low Level View</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#class-hierarchies-3">3.6.1 Class Hierarchies</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#control-flow-3">3.6.2 Control Flow</a><br><hr><hr><h2 id="4"><a name="intro-1">1.0 Introduction to OLE support</a></h2>



<p id="5">
The high-level OLE/OCX
interface, introduced in 2005, is described in
<a href="#highlevel-intro-1">Section 2.0 Introduction to high-level OLE/OCX interface</a>.
</p>
<p id="6">
For some time, Allegro CL has supported a low-level OLE
interface. This is still supported and described in
<a href="#lowlevel-intro-1">Section 3.0 Introduction to the low-level OLE interface</a>.
</p>


<hr><hr><h2 id="7"><a name="highlevel-intro-1">2.0 Introduction to high-level OLE/OCX interface</a></h2>



<p id="8">
This documentation for the OLE/OCX interface is preliminary. It will
be updated from time to time.
</p>


<p id="9">
The high-level OLE/OCX interface is implemented in a number of
modules. The primary module is the :ole-dev module. The remaining
modules are loaded automatically at the first call to the macro
<a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a>.
</p>
<p id="10">
This document describes the interface. The related
document, <a href="ole_reference.htm">ole_reference.htm</a>, lists all the
operators.
</p>
<p id="11">
To start using the interface, then, evaluate the following <a href="../ansicl/dictentr/provider.htm"><b>require</b></a> form:
</p>
<pre id="12">
(require :ole-dev)
</pre>

<p id="13">
And then make a call to <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a>.
</p>
<p id="14">
You might need <i>ole/client/autotool.fasl</i>. This form in a file
will load that file:
</p>
<pre id="15">
(eval-when (load eval)
  (require :ole-autotool #p"sys:;ole;client;autotool.fasl"))
</pre>

<p id="16">
Symbols naming OLE functionality are in the <code>:ole</code>
package.
</p>

<hr><h2 id="17"><a name="ocx-and-acl-2">2.1 OCX objects and Allegro CL</a></h2>

<p id="18">
OCX objects are entities that provide services through OLE interfaces.
They may be implemented in any language, and may be instantiated in
the address space of the client, via loaded DLL's, or in separate
address spaces as local or remote processes. A Lisp program can
request the services of any number of OCX objects. A Lisp program can
also implement OCX objects, but this document only addresses the use
of externally implemented OCX objects. A forthcoming separate document
discusses OCX controls used as widgets on an IDE form.
</p>
<p id="19">
To use an OCX object, the Lisp application must request its creation
and receive one or more interfaces to the object. The application can
then invoke the object's methods, inspect and change its properties,
and eventually release the object so that it can be destroyed. In
order to code the method calls and property references, the programmer
must know what methods and properties the object supports. To perform
the actual invocations, Allegro CL must know the interface and object
definitions. The programmer may be able to get the information he or
she needs by reading documentation; Allegro CL gets the definitions
from a type library supplied with the object.
</p>



<hr><h2 id="20"><a name="type-libraries-2">2.2 Type Libraries</a></h2>

<p id="21">
Type libraries, also called <i><b>typelibs</b></i>, are compiled
representations of IDL files. <b>IDL</b> stands for <b>Interface
Definition Language</b>; it is the C-like language Microsoft uses to
describe the collections of interfaces supported by an OCX object. A
typelib is sometimes provided directly in file format, often in a file
with a <b>.tlb</b> extension; type libraries may or may not be
recorded in the registry.
</p>
<p id="22">
To have Allegro CL learn the definitions in a type library, we need to
supply a pathname to the typelib file or else provide a registry key
leading to the typelib. The basic function to read a type library is
descibed below (see <a href="ole.htm#load-typelib-op-bookmarkxx"><b>ole:load-typelib</b></a>). The <a href="ole.htm#load-typelib-op-bookmarkxx"><b>ole:load-typelib</b></a> function
does not itself define the foreign function linkage needed to activate
and control the objects from Lisp. The <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> macro, also described
below, invokes <a href="ole.htm#load-typelib-op-bookmarkxx"><b>ole:load-typelib</b></a> and then processes the
resulting information to define Lisp classes, constants, and methods,
giving the programmer convenient access to the objects.
</p>
<p id="23">
The type library provides Allegro CL with definitions of structures
(structs), symbolic constants (enums), interfaces, and objects
(CoClasses).  The <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> macro expands into a
form that defines corresponding foreign structures, Lisp constants,
classes, functions, and methods.  These different components of the
lisp-to-object linkage are named by symbols, and this introduces a
problem. A name that appears as a constant or method in a type library
may duplicate the name of some other entity in a different library, or
the name of some existing common Lisp function.  <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> resolves
this by interning all names for typelib entities in a special package,
a package that is normally specific to that type library or to OLE
interfaces, and which normally uses no other packages.  As a result, a
method named <b>delete</b> would be associated with a
<code>delete</code> symbol that was different from the Common
Lisp symbol of the same name. Section
<a href="#typelib-coclass-2">Section 2.3 Typelib entity: CoClass</a> will describe the
various pieces of Lisp linkage machinery constructed to correspond to
each item in the typelib. The following examples are taken from
Microsoft's Internet Explorer, and assume the following form was used:
</p>
<pre id="24">
(ole:def-ole-linkage #:msx :application "InternetExplorer")
</pre>

<p id="25">
The meaning of each argument in this macro form is described below
(see <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a>).
</p>
<p id="26">
The <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> macro expands into a
form that defines the Lisp connection to the OCX object.  As a result,
the compile-time support for <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a>, which reads and
analyzes the type library, is only needed when the form is compiled or
interpreted.  Once a file containing <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> forms has been
compiled, the resulting fasl file can be loaded later into a Lisp
image that doesn't include the machinery for analyzing typelibs or
compiling interface definitions.
</p>



<hr><h2 id="27"><a name="typelib-coclass-2">2.3 Typelib entity: CoClass</a></h2>

<p id="28">
The objects an application will manipulate are named and defined by
the CoClass entries in the typelib; a typelib may define several
CoClasses or just one. For our example we'll look at this CoClass
definition:
</p>
<pre id="29">
    [
      uuid(0002DF01-0000-0000-C000-000000000046),
      helpstring("Internet Explorer Application."),
      helpcontext(0x00000000)
    ]
    coclass InternetExplorer {
        [default] interface IWebBrowser2;
        interface IWebBrowserApp;
        [default, source] dispinterface DWebBrowserEvents2;
        [source] dispinterface DWebBrowserEvents;
    };
</pre>

<p id="30">
This object supports two control interfaces and two source (or event)
interfaces.  The control interfaces are IWebBrowser2 and
IWebBrowserApp; the event interfaces are DWebBrowserEvents and
DWebBrowserEvents2.  The <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> form defines a class
<code>msx:InternetExplorer</code> which inherits from an
internal <code>ole::access-to-ole-control</code> class, and
whose instances will be the Lisp objects corresponding to the CoClass
objects. An instance can be created like this:
</p>
<pre id="31">
(setq browser (make-instance 'msx:InternetExplorer))
</pre>

<p id="32">
All Lisp classes corresponding to OLE coclasses support these
initialization arguments to <a href="../ansicl/dictentr/make-ins.htm"><b>make-instance</b></a>:
</p>
<ul>
<li id="33">
<code>:interface</code>: can be a symbol naming any control
interface the CoClass supports (default is the symbol naming the
default interface for the CoClass) This is the interface that will be
acquired when the OCX connection is established.
</li>
<li id="34">
<code>:event-interface</code>: can be a symbol naming any event
interface the CoClass supports (default is the symbol naming the
default source interface for the CoClass) This is the interface that
will be used when establishing the event channel.
</li>
<li id="35">
<code>:server-context</code>: can be one of
<code>:inproc</code> or <code>:local</code> (default is to
try <code>:inproc</code>, then <code>:local</code> if
<code>:inproc</code> fails) Specifies the type of service to
request from OLE.
</li>
</ul>

<p id="36">
Making an instance of a coclass class does not automatically get the
OCX object created. That's done by <a href="ole.htm#connect-to-server-op-bookmarkxx"><b>ole:connect-to-server</b></a>.
</p>
<p id="37">
The next form will make the connection, once the ocx object has been
created as above:
</p>
<pre id="38">
(ole:connect-to-server browser :inplace nil)
</pre>

<p id="39">
This will start a browser running, but it won't be visible because
this particular browser starts up in hidden mode. It can be made
visible by setting the appropriate property, as described below.
</p>
<p id="40">
The <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> macro creates Lisp
methods corresponding to the methods and property functions defined
for the CoClass's interfaces.  For each method <i>mmmm</i> or
property-getter <i>gggg</i> or property-setter <i>ssss</i> of
interface IIII, <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> defines a
corresponding method for <b>msx:mmmm</b>, <b>msx:gggg</b> or <b>(setf
msx:ssss)</b>. In our example, InternetExplorer objects support by
default the interface IWebBrowser2, which inherits from
IWebBrowserApp.  Whichever interface is used for a particular
InternetExplorer instance, all the IWebBrowserApp methods will be
available.  For example, consider these methods from the idl for
IWebBrowserApp:
</p>
<pre id="41">
   [id(0x00000192), propget,
    helpstring("Determines whether the application is visible or hidden."),
    helpcontext(0x00000000)]
   HRESULT Visible([out, retval] VARIANT_BOOL* pBool);

   [id(0x00000192), propput,
       helpstring("Determines whether the application is visible or hidden."),
       helpcontext(0x00000000)]
   HRESULT Visible([in] VARIANT_BOOL pBool);
</pre>
<p id="42">
<a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> generates methods that
look something like this:
</p>
<pre id="43">
(defmethod msx:Visible ((obj msx:InternetExplorer))
  ...)
</pre>
<p id="44">
and
</p>
<pre id="45">
(defmethod (setf msx:Visible) (val (obj msx:InternetExplorer))
  ...)
</pre>
<p id="46">
that invoke the appropriate OLE methods on obj's IWebBrowserApp
interface.
</p>
<p id="47">
The defined methods call internal functions
<b>ole.control::IWebBrowserApp.Visible</b>, and <b>(setf
ole.control::IWebBrowserApp.Visible)</b>, also defined by the <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> form. These
lower-level interface-specific functions use the
<b>ole.control:IWebBrowserApp</b> function to get the appropriate
client interface. Examples appear below in the section on interfaces.
</p>
<p id="48">
For each control interface IIII the CoClass supports, <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> defines a method
<b>ole.control:IIII</b> to return the IIII-client interface for that
object. If x is an instance of msx:InternetExplorer,
<code>(ole.control:IWebBrowserApp x)</code> will return an
IWebBrowserApp-client interface on which low-level method calls can be
made. Since IWebBrowser2 inherits from IWebBrowserApp, the interface
returned by <b>ole.control:IWebBrowserApp</b> might actually be a more
specific IWebBrowser2 interface, but either works for the
IWebBrowserApp methods.
</p>
<p id="49">
The application code doesn't normally need to use either the
<b>ole.control:IWebBrowserApp</b> function or the low-level method
calls because the higher-level functions in the msx package are more
convenient.
</p>
<p id="50">
In our example, after connecting the browser object to an external web
browser, nothing was seen because this particular control starts up
hidden. Evaluating <code>(msx:Visible browser)</code> returns
<code>nil</code>, and evaluating <code>(setf
(msx:Visible browser) t)</code> makes the browser window visible.
<code>(msx:Navigate2 browser "franz.com")</code> makes the
browser object display the Franz home page.
</p>
<p id="51">
When the typelib defines a method that returns a coclass's control
interface, the generated Lisp method returns an instance of the Lisp
object class whose control interface is the returned value and whose
interface-type is the corresponding type. This object does not have an
event channel opened automatically. If the application wishes to
receive events for any such object, it needs to explicitly call the
function <a href="ole.htm#connect-event-channel-op-bookmarkxx"><b>ole:connect-event-channel</b></a>, passing the new
object as the argument.
</p>
<p id="52">
A technical note important in multiprocessing applications: The
control methods defined in Lisp perform heap-dropping calls. There is
more overhead in a heap-dropping call, but since a method call to a
visible control object might result in messages being dispatched to
windows owned by other Lisp threads, we have to allow them a chance to
run or risk hanging our application.
</p>
<p id="53">
Besides the interface-specific methods defined for
msx:InternetExplorer objects, there are some methods applicable to all
instances of access-to-ole-control subclasses.  These include <a href="ole.htm#connect-to-server-op-bookmarkxx"><b>ole:connect-to-server</b></a>, <a href="ole.htm#disconnect-op-bookmarkxx"><b>ole:disconnect</b></a>, and the
setf-able <b>ole:event-tracing</b>.
</p>
<p id="54">
If x is an instance of msx:InternetExplorer,
<code>(ole:connect-to-server x :inplace nil)</code> will ask OLE
to create a new running instance of an InternetExplorer object.  If
the attempt is successful then the current dumplisp tick (a value that
records how many time an image has been <a href="operators/excl/dumplisp.htm"><b>dumplisp</b></a>'ed since first creation) is recorded
in the Lisp object along with connection information.  <a href="ole.htm#connect-to-server-op-bookmarkxx"><b>ole:connect-to-server</b></a> will not try to
establish a new connection if x looks like it is connected and its
dumplisp tick matches the current Lisp dumplisp tick. A live
connection doesn't survive a <a href="operators/excl/dumplisp.htm"><b>dumplisp</b></a> restore, so this allows application
initialization code to call <a href="ole.htm#connect-to-server-op-bookmarkxx"><b>ole:connect-to-server</b></a> on a set of
instantiated Lisp objects either before or after a dumplisp.
</p>
<p id="55">
Because the InternetExplorer CoClass defines an event channel, <a href="ole.htm#connect-to-server-op-bookmarkxx"><b>ole:connect-to-server</b></a> also tries to create
and initialize an event channel for the object.  To see unhandled
events being generated by an object x,
</p>
<pre id="56">
(setf (ole:event-tracing x) t)
</pre>

<p id="57">
This will make each event received on one of x's event channels
produce a message.
</p>
<pre id="58">
(setf (ole:event-tracing x) nil)
</pre>

<p id="59">
will muffle the event messages for x.
</p>
<p id="60">
Events can be handled by defining methods for them. Each event named
<code>xxxx</code> is associated with a generic function named
<b>-xxxx</b> (prefix a minus sign to the method name).  This generic
function takes as arguments the object, the channel, and the arguments
defined in the typelib.  For example, this definition in the typelib
for one of DWebBrowser2's events:
</p>
<pre id="61">
[id(0x00000066), helpstring("Statusbar text changed."), helpcontext(0x00000000)]
    void StatusTextChange([in] BSTR Text);
</pre>

<p id="62">
says we can define a method like this:
</p>
<pre id="63">
(defmethod msx:-StatusTextChange ((obj msx:InternetExplorer) channel text)
   (declare (ignore channel))
   (format *trace-output* "Statustextchange: ~s~%" text))
</pre>

<p id="64">
to get our own printout when the event is received.
</p>



<hr><h2 id="65"><a name="typelib-enum-2">2.4 Typelib entity: Enum</a></h2>

<p id="66">
For each value in an enum, <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> generates a corresponding
defconstant form.  <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> also generates a function to
convert the numeric values into the corresponding symbolic names. The
Internet Explorer type library contains this enum:
</p>
<pre id="67">
    typedef [uuid(34A226E0-DF30-11CF-89A9-00A0C9054129),
     helpstring("Constants for WebBrowser CommandStateChange"),
     helpcontext(0x00000000)]
    enum {
        CSC_UPDATECOMMANDS = -1,
        CSC_NAVIGATEFORWARD = 1,
        CSC_NAVIGATEBACK = 2
    } CommandStateChangeConstants;
</pre>

<p id="68">
The <b>def-ole-interface</b> form produces the corresponding
definitions:
</p>
<pre id="69">
       (defun msx:decode-CommandStateChangeConstants (ole::v)
         (case ole::v
           (2 'msx:CSC_NAVIGATEBACK)
           (1 'msx:CSC_NAVIGATEFORWARD)
           (-1 'msx:CSC_UPDATECOMMANDS)
           (t ole::v)))
       (defconstant msx:CSC_NAVIGATEBACK 2)
       (defconstant msx:CSC_NAVIGATEFORWARD 1)
       (defconstant msx:CSC_UPDATECOMMANDS -1)
</pre>



<hr><h2 id="70"><a name="typelib-interface-2">2.5 Typelib entity: Interface</a></h2>

<p id="71">
For each interface defined in a typelib, <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a>
generates a corresponding OLE <b>def-ole-interface</b> form and some
additional method definitions at a higher level. The generated
definitions depend on whether the interface is used by the client to
call methods in the object or by the object to call methods in Lisp.
The former we refer to as a control interface, the latter as an event
interface. The exact definitions are not normally of interest to the
application programmer, who uses the higher-level functions acting on
the CoClass object.
</p>



<hr><h2 id="72"><a name="internals-reference-2">2.6 OLE/OCX low-level internals discussion</a></h2>

<h3 id="73">
Interfaces
</h3>

<p id="74">
The IWebBrowser2 control interface in the InternetExplorer typelib
looks like this (many methods omitted to condense the example):
</p>
<pre id="75">    [
      odl,
      uuid(D30C1661-CDAF-11D0-8A3E-00C04FC9E26E),
      helpstring("Web Browser Interface for IE4."),
      helpcontext(0x00000000),
      hidden,
      dual,
      oleautomation
    ]
    interface IWebBrowser2 : IWebBrowserApp {
        [id(0x000001f4), helpstring("Navigates to a URL or file or pidl."),
         helpcontext(0x00000000)]
        HRESULT Navigate2(
                        [in] VARIANT* URL, 
                        [in, optional] VARIANT* Flags, 
                        [in, optional] VARIANT* TargetFrameName, 
                        [in, optional] VARIANT* PostData, 
                        [in, optional] VARIANT* Headers);
	... ommitted methods ...
    };
</pre>
<p id="76">
These are the corresponding forms generated by <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a>:
</p>
<pre id="77">
   ;;----- An ole interface definition

   (ole:def-ole-interface ole.control:IWebBrowserApp
     (:base ole.control:IWebBrowser)
     (:iid "{0002df05-0000-0000-c000-000000000046}"))

   ;;----- The client-side machinery for that interface

   (ole:def-client-interface ole.control:IWebBrowserApp)

   ;;----- A class to mix in to ocx objects that support the interface

   (defclass ole.control::object-with-IWebBrowserApp-client
	     (ole.control::object-with-IWebBrowser-client)
	     ((ole.control::i.IWebBrowserApp :initform nil)))

   ;;----- A method definition to get the appropriate interface when needed,
   ;;      caching the interface for efficiency

   (defmethod ole.control:IWebBrowserApp ((ole::object
					   ole.control::object-with-IWebBrowserApp-client))
     (or (slot-value ole::object 'ole.control::i.IWebBrowserApp)
	 (setf (slot-value ole::object
			   'ole.control::i.IWebBrowserApp)
	       (ole:query-interface (ole::client-interface
				     ole::object)
				    ole.control::IID_IWebBrowserApp))))

   ;;----- A method to return this interface when the less-specific interface
   ;;      is requested

   (defmethod ole.control:IWebBrowser ((ole::object
					ole.control::object-with-IWebBrowserApp-client))
     (or (slot-value ole::object 'ole.control::i.IWebBrowserApp)
	 (setf (slot-value ole::object
			   'ole.control::i.IWebBrowserApp)
	       (ole:query-interface (ole::client-interface
				     ole::object)
				    ole.control::IID_IWebBrowserApp))))

   ;;----- A low-level Lisp method corresponding to the CoClass method

   (defmethod ole.control::IWebBrowser2.Navigate2
	      ((ole::this.object ole.control::object-with-IWebBrowser2-client)
	       ole.control::URL
	       &key
	       (ole.control::Flags :missing)
	       (ole.control::TargetFrameName :missing)
	       (ole.control::PostData :missing)
	       (ole.control::Headers :missing))
     (ole::control.invoke.5-
       (ole.control:IWebBrowser2 ole::this.object) 500
       (logior ole:DISPATCH_METHOD ole:DISPATCH_PROPERTYGET)
       ole.control::URL ole.control::Flags
       ole.control::TargetFrameName ole.control::PostData
       ole.control::Headers))
</pre>
<p id="78">
One of the event interfaces in the typelib is this (again edited for a
concise example):
</p>
<pre id="79">
 [
   uuid(20DD1B9D-87C4-11D1-8BE3-0000F8754DA1),
   helpcontext(0x00000000),
   hidden
 ]
 dispinterface DDTPickerEvents {
     properties:
     methods:
	 [id(0x00000001), helpstring("Occurs when the user presses a key ..."),
	   helpcontext(0x00035c66)]

	 void CallbackKeyDown(
			 [in] short KeyCode, 
			 [in] short Shift, 
			 [in] BSTR CallbackField, 
			 [in, out] DATE* CallbackDate);

	 [id(0x00000002), helpstring("Occurs when the user selects ..."),
	   helpcontext(0x00035c67)]

	 void Change();

     ... several more methods omitted here	

 };
</pre>
<p id="80">
The corresponding definitions from <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>ole:def-ole-linkage</b></a> are:
</p>
<pre id="81">
 ;;----- An ole interface definition

 (ole:def-ole-interface ole.control:DDTPickerEvents
   (:base ole:IDispatch)
   (:iid "{20dd1b9d-87c4-11d1-8be3-0000f8754da1}"))

 ;;----- The serverd-side machinery for that interface

 (ole:def-server-interface ole.control:DDTPickerEvents)

 ;;----- A class of objects that manage the event interface connection

 (ole:def-ocx-class ole.control::channel-DDTPickerEvents
     (ole::control-event-channel
	  :interfaces ole.control:DDTPickerEvents)
     ((ole::uuid :allocation :class
		 :initform (ole:unique-guid "{20dd1b9d-87c4-11d1-8be3-0000f8754da1}"))))

 ;;----- A function invoked when a CallbackKeyDown event occurs.
 ;;      It does the method tracing output if that's enabled, then
 ;;      invokes a generic function on which the user can define
 ;;      specialized methods.

 (defun ole.control::event.DDTPickerEvents.CallbackKeyDown
	    (ole::this.control ole::this.channel
	     ole.control::KeyCode ole.control::Shift
	     ole.control::CallbackField
	     ole.control::CallbackDate)
     (when (slot-value ole::this.channel 'ole::tracing)
	(format *trace-output*
		";; event event.DDTPickerEvents.CallbackKeyDown on ~s~%"
		ole::this.control))
     (xctl:-CallbackKeyDown ole::this.control
	   ole::this.channel ole.control::KeyCode
	   ole.control::Shift ole.control::CallbackField
	   ole.control::CallbackDate))

 ;;----- A default primary method that does nothing, in case the
 ;;      application doesn't define anything

 (defmethod xctl:-CallbackKeyDown ((ole::this.control t)
					  (ole::this.channel
					   ole.control::channel-DDTPickerEvents)
					  ole.control::KeyCode
					  ole.control::Shift
					  ole.control::CallbackField
					  ole.control::CallbackDate)
	  (declare
	   (ignore ole.control::KeyCode ole.control::Shift
	    ole.control::CallbackField
	    ole.control::CallbackDate))
	  nil)

 ;;----- A function invoked when a Change event occurs.
 ;;      It does the method tracing output if that's enabled, then
 ;;      invokes a generic function on which the user can define
 ;;      specialized methods.

 (defun ole.control::event.DDTPickerEvents.Change
	    (ole::this.control ole::this.channel)
	  (when (slot-value ole::this.channel 'ole::tracing)
	    (format *trace-output*
		    ";; event event.DDTPickerEvents.Change on ~s~%"
		    ole::this.control))
	  (xctl:-Change ole::this.control ole::this.channel))

 ;;----- A default primary method that does nothing, in case the
 ;;      application doesn't define anything

 (defmethod xctl:-Change ((ole::this.control t)
				 (ole::this.channel
				  ole.control::channel-DDTPickerEvents))
	  (declare (ignore)) nil)

 ;;----- dispatch-invocation is the top-level dispatcher for Invoke
 ;;      calls (to Lisp) on the event interface.
 ;;      A method specialized on the channel argument interprets the
 ;;      memid and decodes the arguments to call the right
 ;;      
 (defmethod ole::dispatch-invocation ((ole::this.channel
				       ole.control::channel-DDTPickerEvents)
				      ole::memid
				      ole::mode
				      ole::parms)
   (declare (ignore-if-unused ole::mode ole::parms))
   (let ((ole::this.control
	  (slot-value ole::this.channel 'ole::host)))
     (case ole::memid
       (1
	(let ((ole.control::CallbackDate
	       (ole::get-nth-arg ole::parms 3))
	      (ole.control::CallbackField
	       (ole::get-nth-arg ole::parms 2))
	      (ole.control::Shift
	       (ole::get-nth-arg ole::parms 1))
	      (ole.control::KeyCode
	       (ole::get-nth-arg ole::parms 0)))
	  (ole.control::event.DDTPickerEvents.CallbackKeyDown
	   ole::this.control ole::this.channel
	   ole.control::KeyCode ole.control::Shift
	   ole.control::CallbackField
	   ole.control::CallbackDate)))
       (2
	(let ()
	  (ole.control::event.DDTPickerEvents.Change
	   ole::this.control ole::this.channel)))

       ;; more cases corresponding to methods omitted for conciseness

       (t (signal 'ole::member-not-found)))))
</pre>



<hr><h2 id="82"><a name="highlevel-reference-2">2.7 Reference guide to interface operators</a></h2>

<hr><h3 id="83"><a name="def-ole-linkage-op-bookmarkxx"></a>def-ole-linkage</h3><h3 id="84">Macro</h3><h4 id="85">Package: ole</h4>

<p id="86"><b>Arguments: </b><i>
package-name </i>&amp;key <i>guid major-version minor-version pathname application</i><i>
</i></p>

<p id="87">
The package-name, a string or symbol, provides the name of the package
in which library-specific symbols will be interned. The package will
be created when the macro is expanded if it does not already exist,
and the expansion will include a defpackage form for it.  The keyword
arguments specify a type library, and have exactly the same meaning as
for the ole:load-typelib function, which is called at macro expansion
time but not by the form the macro expands into.
</p>

<hr>

<hr><h3 id="88"><a name="connect-to-server-op-bookmarkxx"></a>connect-to-server</h3><h3 id="89">Generic Function</h3><h4 id="90">Package: ole</h4>

<p id="91"><b>Arguments: </b><i>
control-object </i>&amp;key <i>inplace</i> (<i>default</i> t)<i>
</i></p>

<p id="92">
The first argument must be an instance of one of the coclass classes
defined by a def-ole-linkage form.  This function attempts to form a
connection between the control-object argument and a live OLE
object. If the control-object appears to be serving a live OLE object,
nothing else is done. Otherwise OLE is asked to provide a new
connection.  If the object class is defined to have an event channel,
connect-to-server tries to open it.  The inplace argument defaults to
t, and must be specified nil for objects not being activated in place.
</p>

<hr>

<hr><h3 id="93"><a name="connect-event-channel-op-bookmarkxx"></a>connect-event-channel</h3><h3 id="94">Function</h3><h4 id="95">Package: ole</h4>

<p id="96"><b>Arguments: </b><i>
control-object </i>&amp;key <i>event-interface-class</i><i>
</i></p>

<p id="97">
The first argument must be an instance of a coclass class defined by
def-ole-linkage.  The event-interface-argument, if present, must be a
symbol naming one of the legitimate event classes for the coclass, and
overrides the default class defined by the type library.  The function
attempts to establish the OLE linkage for the events, so that Lisp
code can process the events.
</p>

<hr>

<hr><h3 id="98"><a name="disconnect-op-bookmarkxx"></a>disconnect</h3><h3 id="99">Function</h3><h4 id="100">Package: ole</h4>

<p id="101"><b>Arguments: </b><i>
ocx-object
</i></p>

<p id="102">
The argument must be an instance of a coclass class defined by
def-ole-linkage.  disconnect releases all the interfaces, including
event-channel interfaces so that the OLE object and its resources can
be freed.
</p>

<hr>

<hr><h3 id="103"><a name="load-typelib-op-bookmarkxx"></a>load-typelib</h3><h3 id="104">Function</h3><h4 id="105">Package: ole</h4>

<p id="106"><b>Arguments: </b><i>
</i>&amp;key <i>guid major-version minor-version pathname application</i><i>
</i></p>

<p id="107">
This function attempts to loacte a type library and read its
definitions.  The type library can be specified in one of several
ways:
</p>
<ol>
<li id="108">
The pathname of a typelibrary file can be given as a string or
pathname.
</li>
<li id="109">
A guid can be specified as a string or lisp-guid, along with major and
minor version numbers, if necessary, to locate a type library known to
the registry
</li>
<li id="110">
A string that uniquely specifies an application can be given as the
application keyword. In this case, if there is just one entry under
RKEY-CLASSES-ROOT that contains the given string, ignoring case, and
that entry has an associated typelib, then that's the typelib that is
loaded.
</li>
</ol>

<p id="111">
Type libraries loaded are cached in the Lisp, and not reloaded if
already present.  The value returned by the function is the
internalized Lisp structure holding the typelib information.
</p>

<hr>

<hr><h3 id="112"><a name="event-tracing-op-bookmarkxx"></a>event-tracing</h3><h3 id="113">Function</h3><h4 id="114">Package: ole</h4>

<p id="115"><b>Arguments: </b><i>
object
</i></p>

<p id="116">
This function returns non-<code>nil</code> if
event-tracing is enabled for <i>object</i>, which must
be an instance of a lisp coclass class defined by <a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>def-ole-linkage</b></a>.
</p>
<p id="117">
Event tracing defaults to <code>nil</code> at object
creation. A non-<code>nil</code> value may be set with
<a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a> and this function. The
default event-handling method for all objects will print a message on
<a href="../ansicl/dictentr/debug-io.htm"><code>*trace-output*</code></a> if
event-tracing is non-<code>nil</code>. Any user-defined
specialized methods will shadow the default method, so this can be
used to see what events are arriving and not being handled.
</p>

<hr>

<hr><h3 id="118"><a name="format-idl-op-bookmarkxx"></a>format-idl</h3><h3 id="119">Function</h3><h4 id="120">Package: ole</h4>

<p id="121"><b>Arguments: </b><i>
pathname</i> &amp;optional <i>lisp-typelib</i><i>
</i></p>

<p id="122">
You must load the
<i>[Allegro-directory]/ole/client/client/idlout.fasl</i>
file before using this function. If the current directory is the
Allegro directory, this can be done with the form <code>(load
"ole/client/idlout")</code>.
</p>
<p id="123">
This function writes out an approximation of the idl that generated
the typelib. The pathname argument, a string or pathname, specifies
the file to be written. The optional second argument is the
internalized Lisp form of a typelib. If omitted, the last typelib
loaded provides the data to be written.
</p>

<hr>



<hr><h2 id="124"><a name="high-index-2">2.8 Index to high-level interface operators</a></h2>

<ul>
<li id="125">
<a href="ole.htm#connect-event-channel-op-bookmarkxx"><b>connect-event-channel</b></a> (function)
</li>
<li id="126">
<a href="ole.htm#connect-to-server-op-bookmarkxx"><b>connect-to-server</b></a> (generic function)
</li>
<li id="127">
<a href="ole.htm#def-ole-linkage-op-bookmarkxx"><b>def-ole-linkage</b></a> (macro)
</li>
<li id="128">
<a href="ole.htm#disconnect-op-bookmarkxx"><b>disconnect</b></a>
(function)
</li>
<li id="129">
<a href="ole.htm#event-tracing-op-bookmarkxx"><b>event-tracing</b></a>
(function)
</li>
<li id="130">
<a href="ole.htm#format-idl-op-bookmarkxx"><b>format-idl</b></a>
(function)
</li>
<li id="131">
<a href="ole.htm#load-typelib-op-bookmarkxx"><b>load-typelib</b></a> (function)
</li>
</ul>



<hr><hr><h2 id="132"><a name="lowlevel-intro-1">3.0 Introduction to the low-level OLE interface</a></h2>


<p id="133">
The facility described in this document simplifies OLE programming
without imposing any limit on the programmer's access to OLE
functionality. To a CLOS program, Microsoft's COM/OLE/ActiveX
facilities look like a foreign library consisting of data types, named
API entries, and interfaces, the latter being C++-like objects with
associated virtual tables.  Allegro's OLE support provides tools for
dealing with these foreign entities. Every API point is reachable,
every interface can be used. The support also includes a library of
CLOS classes and functions that make it easier to manage an
application's OLE component in a CLOS development environment. This
CLOS-OLE layer is not yet complete as we are continuing to extend
it. All the most useful OLE capabilities will be as readily
available in CLOS as in any other environment, and will benefit from
the unique dynamic power inherent in CLOS. 
</p>

<p id="134">
This file contains an overview of Allegro CL OLE 's treatment of OLE
concepts. It lays out the overall organization of the Allegro CL OLE tools
and an Allegro CL OLE application. Detailed documentation of each element in
the Allegro CL OLE system appears in the reference document,
<a href="ole_reference.htm">ole_reference.htm</a>. Look there for information about
individual CLOS functions, macros, classes and data types.
</p>


<hr><h2 id="135"><a name="sample-programs-2">3.1 Sample Programs</a></h2>

<p id="136">
You will find a set of sample Allegro CL OLE programs to illustrate writing
client and server applications using Allegro CL OLE. Each sample appears in a
directory ole/samples/sample<i>nn</i>, and includes a readme.txt file
explaining how to compile and run the example.
</p>

<ul>
<li id="137">
sample01. This is a simple automation client.
</li>
<li id="138">
sample02. This is a slightly more complex automation client.
</li>
<li id="139">
sample03. This is an automation server and its client.
</li>
<li id="140">
sample04. This is a self-registering automation server and a Visual
Basic client.
</li>
<li id="141">
sample05. This is an inproc Lisp automation server being used by a
Visual C++ client.</li>
<li id="142">
sample06. This is an inproc Lisp automation server being used by a
Visual Basic client.
</li>
<li id="143">
sample07. This shows Lisp using the Microsoft Agent control.
</li>
<li id="144">
sample08. This shows a CLOS interface to Excel.
</li>
</ul>



<hr><h2 id="145"><a name="system-structure-2">3.2 System Structure</a></h2>

<hr><h2 id="146"><a name="basic-3">3.2.1 Basic Concepts</a></h2>


<div align="left">

<table border="0" cellpadding="6" cellspacing="1" width="90%">
  <tr>
    <td width="134" valign="top" align="left"><strong>Basic Unit <br>
    of OLE</strong></td>
    <td width="565"><strong>Treatment in Allegro CL OLE</strong></td>
  </tr>
  <tr>
    <td width="134" valign="top" align="left"><b>Data Types</b></td>
    <td width="565">Most of OLE's primitive data structures are defined and 
    manipulated using
    the Allegro foreign data interface. A few receive special treatment. 
    See the entries for <a href="#unicode">Unicode</a>, 
    <a href="#guid">GUID's</a>, <a href="#bstring">BSTR's</a>,
    and <a href="#interface1">Interface Pointers</a>.</td>
  </tr>
  <tr>
    <td width="134" valign="top" align="left"><b>Interface
    Definition</b></td>
    <td width="565">An OLE Interface definition specifies the methods 
    of an interface, giving
    their order in the VTBL and the arguments and return-value 
    type for each. An interface is
    seen from two sides, client and server. On the client side, 
    an interface allows the
    program to invoke its methods without knowing how 
    they are implemented. The method
    implementations exist on the server side. Allegro CL OLE 
    provides separate macros to <ul>
      <li id="147">define an interface: <code>def-ole-interface</code></li>
      <li id="148">generate client-side linkage to an interface: 
      <code>def-client-interface</code></li>
      <li id="149">generate server-side linkage to an interface: 
      <code>def-server-interface</code></li>
    </ul>
    </td>
  </tr>
  <tr>
    <td width="134" valign="top" align="left"><b>Reference Counting</b></td>
    <td width="565">OLE uses a reference counting scheme to allow it to 
    do garbage collection
    on OLE resources. Every OLE interface inherits from the 
    IUnknown interface, which provides
    <code>AddRef</code> and <code>Release</code> methods to 
    record object usage. Allegro CL OLE
    reflects these OLE methods as the CLOS generic functions 
    <code>add-ref</code> and <code>release</code>.
    <p id="150">Functions in the Allegro CL OLE subsystem make 
    <font face="Courier New">add-ref</font> and <font face="Courier New">release</font> calls at the appropriate times. 
    Allegro garbage
    collection finalizations perform a release call on each 
    client-interface object that
    dies without already having been released. </p></td>
  </tr>
  <tr>
    <td width="134" valign="top" align="left"><b>Starting an OLE
    Session</b></td>
    <td width="565">Before using any OLE facilities, an application 
    has to call certain OLE
    API functions to initialize state. Allegro CL OLE provides 
    <code>start-ole</code> and <code>stop-ole</code>,
    functions that perform all necessary initialization calls 
    and disconnect from OLE,
    respectively.</td>
  </tr>
</table>
</div>




<hr><h2 id="151"><a name="clos-3">3.2.2 Important CLOS Issues for an Allegro CL OLE Application</a></h2>


<ul>
  <li id="152"><b>Classes</b>: Some confusion can arise between CLOS classes 
    and COM/OLE classes.
     CLOS classes define objects in the Lisp world. 
    Their semantics are specified by the
    ANSI standard and the application code. COM/OLE 
    classes define objects that are
    supported by a server application and made available to 
    client applications that may
    reside in a different address space or on a different machine. 
    Instances of CLOS
    classes are created by invoking the CLOS <code>make-instance</code> 
    function. Instances
    of COM/OLE classes are created by asking OLE to locate the 
    server and ask it to make an
    instance. The point of Allegro CL OLE is to provide CLOS 
    classes and functions that let
    Allegro applications be clients and servers of COM/OLE 
    objects. There will be CLOS
    objects representing OLE/COM objects and vice versa. 
    It should be clear from context
    which meaning of "class" is appropriate each time the 
    word appears.</li>
</ul>

<ul>
  <li id="153"><b>Package Structure</b>: The Allegro CL OLE symbols 
    reside in the <code>ole</code> package;
    exported symbols name the documented CLOS functions, 
    macros, constants, classes and
    foreign data types that Allegro CL OLE supports.<p id="154">Users should 
    not place <code>(in-package :ole)</code> forms 
    in their source files. 
    They should either include a <code>(use-package
    :ole)</code> form or use explicit qualification on Allegro CL 
    OLE symbols, as in <code>(ole:query-interface
    foo ole:IID_IUnknown)</code>.</p>
  </li>
</ul>

<ul>
  <li id="155"><b>Case Conventions</b>: ANSI Common Lisp specifies that 
    when reading symbols, the
    default action is to convert unescaped lower case letters 
    to upper case; all standard
    Common Lisp symbols (e.g., <code>FORMAT</code> 
    and <code>DEFUN</code>) appear in upper
    case. Allegro CL can operate in this mode (and does so with
    the executables/images named <i>alisp</i> and
    <i>alisp8</i>); but Allegro CL also
    operates in the modern mode, 
    consistent with UNIX and C usage. In the modern mode,
    used by executables/images named <i>mlisp</i>
    and <i>mlisp8</i>, 
    symbol names are read without case conversion and all 
    Common Lisp symbols (e.g., <code>format</code>
    and <code>defun</code>) appear in lower case.
    <p id="156">When operating in ANSI mode,
    symbols in the OLE package, including function, macro and 
    CLOS class names, are all upper
    case. The case in which they are written in a source file 
    is not significant. Two symbols
    that differ only in case cannot be used to name separate 
    entities without escaping the
    lowercase letters. These last two points mean that errors 
    due to inconsistent case usage
    disappear, but at the same time, the common C convention 
    of using a capitalized symbol for
    a structure or class name and lower case for an object, 
    as in <code>Party</code> and <code>party</code>,
    introduces a naming conflict.</p>
    <p id="157">When operating in modern mode, 
    Allegro CL allows source files to
    contain distinct symbols that differ only in the 
    case of individual letters. In this mode,
    all symbols that represent interfaces, OLE functions 
    and OLE constants appear in Lisp with
    the same case configuration they have in C, e.g., 
    <code>IUnknown</code>, <code>GetClassObject</code>,
    <code>DISP_E_UNKNOWNINTERFACE</code>. OLE types appear 
    in the same case they have in C
    unless the C type is all upper case, in which case the 
    Allegro CL OLE type name is all lower
    case, e.g. <code>pInterface</code>, <code>bstr</code>.</p>
    <p id="158"><b>Important</b>: An Allegro CL OLE application 
    running in ANSI mode must direct the
    fasl loader to convert mixed-case symbol names to upper case, 
    something the fasl loader
    does not do by default. The way to specify this directive is 
    by evaluating </p>
    <code>(convert-mixed-case-symbols t)</code>
    <p id="159">Loading the Allegro CL OLE system into Allegro by evaluating 
    <code>(require :ole)</code> or 
    <code>(require :ole-dev)</code>
    automatically sets the correct convert-case-mode.</p>
    <p id="160">An Allegro CL OLE file that has been compiled in modern, case-sensitive-lower 
    mode can be
    successfully loaded into a Lisp running in ANSI mode, 
    as long as the shift to all
    upper case doesn't introduce any name clashes. The reverse is 
    not true. An Allegro CL OLE
    application file compiled in ANSI mode will not 
    successfully load into a
    modern Lisp, because there is no way to 
    recover the mixture of upper and
    lower case in symbols such as <code>IUnknown</code>. 
    For this reason, it is a good plan to
    compile Allegro CL OLE applications in modern mode, 
    so the compiled application
    can be loaded and run by a Lisp running in either mode.</p>
    <p id="161">Once Allegro CL OLE has been loaded into Lisp, it is likely that 
    subsequently changing the
    system's case mode will render Allegro CL OLE inoperable.
    Attempting to call set-case-mode
    in this environment will raise a continuable error warning 
    the user of the problem. 
    Continuing from this error allows the system to change 
    its case convention despite the
    danger to OLE.</p>
  </li>
</ul>

<ul>
  <li id="162"><b>Modules</b> The Allegro CL OLE subsystem is partitioned 
    into two major modules and a number
    of separate minor modules. The major modules are <ul>
      <li id="163"><b>ole-dev</b>: Compile-time support. 
        Definitions needed to compile an Allegro CL OLE
        application file. </li>
      <li id="164"><b>ole</b>: Run-time support. Definitions 
        needed to run an Allegro CL OLE application. </li>
    </ul>
    <p id="165">An Allegro CL OLE application file should include the 
    following two forms to take advantage of
    this separation: </p>
<pre id="166">
(eval-when (compile eval) (require :ole-dev))

(eval-when (compile load eval) (require :ole))
</pre>
    <p id="167">The minor modules include special CLOS classes and 
    functions used to support automation
    clients and servers, a few other special OLE areas that 
    are not needed in every
    application, and separate files for each client and server 
    interface. Allegro CL OLE provides
    three macros to include these modules: </p>
    <ul>
      <li id="168"><b>require-client-interfaces</b>: to note client 
      interfaces used. </li>
      <li id="169"><b>require-server-interfaces</b>: to note server 
      interfaces supported. </li>
      <li id="170"><b>require-modules</b>: to note non-interface 
      modules used. </li>
    </ul>
    <p id="171">These macros generate code to load the associated modules 
    when they are needed. 
    The macros <code>require-server-interfaces</code> and 
    <code>require-client-interfaces</code> are
    generated as necessary by Allegro CL OLE macros that refer 
    to interfaces by name, such as <code>def-ocx-class</code>,
    and so are rarely coded explicitly. (The macro 
    <code>def-ocx-class</code> defines a
    CLOS server class that supports a named set of interfaces. 
    It generates the appropriate <code>require-server-interfaces</code>
    forms, so no explicit requires are needed for those server 
    interface modules.) The
    most common situation in which these macros must be coded 
    is when a program refers to
    symbols or classes belonging to an interface that it neither 
    defines itself nor names in
    some other Allegro CL OLE macro.</p>
    <p id="172">Programs that define part of an OLE server generally need to 
    use <code>require-modules</code>
    to ensure the presence of the server-support functions. 
    A typical automation server
    would include the form</p>
    <pre id="173">(eval-when (compile load eval)
       (ole:require-modules :automation-server :factory-server))</pre>
    <p id="174">A server that did not provide an IDispatch interface would 
    not need the <code>:automation-server</code>
    support, and could get by with just the <code>:factory-server</code>.</p>
    <p id="175">Currently there are no client-side modules that need to be 
    loaded this way.</p>
    <p id="176">Allegro CL OLE includes a library of interface definition modules 
    grouped into three
    directories</p>
    <ul>
      <li id="177">defifc/... has the interface definitions themselves</li>
      <li id="178">client/... has client-side support modules</li>
      <li id="179">server/... has server-side support modules</li>
    </ul>
    <p id="180">The IUnknown interface, for example, has a base definition as
    .../defifc/iunknown.{cl,fasl}, while the associated client-side 
    definitions appear in
    .../client/iunknown.{cl,fasl} and the server-side definitions are in
    .../server/iunknown.{cl,fasl}. The defifc/* files are only 
    needed during compilation of
    the associated server/* and client/* files. The machinery for 
    defining interfaces
    generates code to ensure the loading of all interface files on 
    which a given interface or
    module depends. When an interface module is to be loaded, Allegro CL 
    OLE checks the current
    directory and the value of 
    <a href="variables/system/s_require-search-list_s.htm"><code>*require-search-list*</code></a>.</p>
  </li>
</ul>




<hr><h2 id="181"><a name="special-data-3">3.2.3 Special OLE Data Types</a></h2>


<p id="182">Allegro CL OLE gives these OLE data types special treatment. 
</p>

<ul>
  <li id="183"><b>Unicode</b>: <a name="unicode"></a> Many string arguments to 
    OLE functions and
    interfaces are Unicode strings. Unicode is a 
    2-byte-per-character encoding for
    all the world's character sets (used, for example, by Microsoft). 
    When operating in standard
    Allegro CL (which uses 16 bits per character), Lisp character strings
    are represented as Unicode strings, so there is no problem in
    passing Unicode data between Lisp and COM/OLE interfaces.
    <p id="184">When operating in an 8-bit Allegro CL, Lisp strings are ASCII. 
    They are translated to UNICODE when passed as COM/OLE arguments or 
    return values, by widening the 8-bit unsigned ASCII codes to 
    16-bit unsigned UNICODE characters. When converting a UNICODE string 
    for Lisp's use, encountering any non-ASCII character signals an error.
    </p>
    </li>
  <li id="185"><b>GUIDs</b>: <a name="guid"></a> OLE uses 128-bit keys 
    called GUID's whenever it wants a
    universal name for something. For example, there is a 
    unique key for each interface type
    and for each OLE object in the system. OLE defines a 
    standard readable representation for
    a GUID, based on hexadecimal encoding: 
    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}. In Allegro CL OLE
    we represent a GUID by a lisp-guid structure, whose slots 
    record the standard form of the
    GUID as well as an instance of the GUID's binary encoding. 
    Incoming guid's are usually
    translated at the interface so that Lisp functions 
    implementing server code see the
    lisp-guid structure. This allows eql comparison on guid values, 
    as in case statements and
    (eql ...) discrimination for generic functions. 
    </li>
  <li id="186"><b>Bstrings</b>: <a name="bstring"></a> Many OLE functions use 
    BSTR's when passing string
    arguments. These are Basic-style string data. Allegro CL OLE has a 
    small set of functions that
    give reasonable access to the OLE-supplied bstring 
    manipulation functions. 
    </li>
  <li id="187"><b>Interface Pointers</b>: <a name="interface1"></a> In 
     Allegro CL OLE each interface instance
    (pInterface) appears as a CLOS object. There are two 
    different CLOS interface classes for
    each OLE interface type, a client-interface class and 
    a server-interface class. See <a href="#interface-3">Interfaces and Objects</a> for more details. </li>
</ul>



<hr><h2 id="188"><a name="language-and-locale-3">3.2.4 Language and Locale</a></h2>

<p id="189">
Many OLE API functions use codes to allow localization of labels and
user-readable data. The Allegro CL OLE interface uses two parameters to
provide default values for these codes: <code>ole:*ole-language*</code>
and <code>ole:*ole-locale*</code>. Currently, these are set to the
machine-dependent-default values that are OLE's
lowest-common-denominator. </p>




<hr><h2 id="190"><a name="interface-3">3.2.5 Interfaces and Objects</a></h2>


<p id="191">
Allegro CL OLE distinguishes between those interfaces that Lisp implements as
a server and those that Lisp uses as a client. CLOS objects represent
interfaces, and different CLOS classes exist for the client and server
views of the same interface. This is important because we often have
to deal with an interface from both sides in the same program. While
developer-defined interface classes can be given any names, the Allegro CL
OLE classes are named using the following convention: Allegro CL OLE supports
OLE interface <i>IAbcde</i> with client-side interfaces of class
<i>IAbcde</i>-client and server-side interfaces of class
<i>IAbcde</i>-server.
</p>

<p id="192">
Example: When an Allegro CL OLE application obtains an IUnknown interface
from some external object, it will be of type
<code>IUnknown-client</code>. An Allegro CL OLE server application will
generate <code>IUnknown-server</code> objects in response to requests
for the IUnknown interface. 
</p>

<p id="193">
An OLE object may reveal any number of interfaces to the outside
world. The interfaces and the object are distinct entities, and in an
Allegro CL OLE application these will be represented by instances of
different CLOS classes. 
</p>

<p id="194">
The Allegro CL OLE object on the server side 
will be an instance of a class that
inherits from the <code>lisp-ole-object</code> class and from several
mixin classes, one for each OLE Interface the object supports. These
mixin classes are named by the OLE interface name, e.g.,
<code>IClassFactory</code> or <code>IOleObject</code>. The object
itself is completely under the server's control; only the interfaces
are exported to the rest of the world. As a server, the CLOS
application must implement the methods of these interfaces. 
</p>

<p id="195">
A developer will often do this by using <code>def-ocx-class</code> to
define the object class, specifying the interface mixins. Here, for
example, is the definition for Allegro CL OLE's <code>class-factory</code>
class . 
</p>

<pre id="196">
(ole:def-ocx-class class-factory (:interfaces IClassFactory)
   ((registration-code :initform nil)
    (locked :initform nil)
    (children :initform nil)
    (product-class :initarg :product-class)
    (allow-aggregation :initform nil :initarg :allow-aggregation)
    ))
</pre>

<p id="197">
Here we are saying that a class-factory has the usual semantics for an
OLE object implemented in Lisp, and that it exports two interfaces:
IUnknown (supported by default) and IClassFactory. These interfaces
have been defined previously with def-ole-interface and are
implemented by <code>IUnknown-server</code> and
<code>IClassFactory-server</code> instances, respectively. This class
definition form arranges that <code>class-factory</code> objects will
respond to QueryInterface requests for the IUnknown and IClassFactory
interfaces, constructing and caching each interface the first time it
is needed. 
</p>



<hr><h2 id="198"><a name="registry-3">3.2.6 The Registry</a></h2>

<p id="199">
The registry is where most system information is kept in Windows. An
ole server must store information about itself in the registry if
it wants to be invoked automatically or allow certain automation
clients (such as Visual Basic) to create its objects. This section
will describe the registry and how it is manipulated from Lisp.
</p>

<p id="200">
The registry is stored as a tree. Each node in the tree is called a
key. Each key has a name, a collection of zero or more values, and a
set of zero or more child keys. Each value stored in a key is also
named (except for one value, which has no name, and is called the
default value). The name of a registry key must consist of printable
characters and no spaces.
</p>

<p id="201">
Manipulating the registry from Lisp consists of first getting a
pointer to the particular key you want to modify. This is done by
starting with an existing open registry key and traversing down the
tree by using the names of successive keys that should be
followed. Since you have to start somewhere in this process you
can use one of the pre-opened registry keys to begin the registry
scan. These pre-opened keys are
</p>

<ul>
  <li id="202"><code>rkey-classes-root</code> - opened to HKEY_CLASSES_ROOT, for OLE class information</li>
  <li id="203"><code>rkey-current-user</code> - opened to HKEY_CURRENT_USER, for user profile information</li>
  <li id="204"><code>rkey-local-machine</code> - opened to HKEY_LOCAL_MACHINE, for machine configuration
    information</li>
  <li id="205"><code>rkey-users</code> - opened to HKEY_USERS, for information about all users</li>
</ul>

<p id="206">
The following functions and macros are provided to open keys and to
read and modify the registry. See the reference document for
their definitions.
</p>

<ul>
  <li id="207"><code>open-registry-key</code></li>
  <li id="208"><code>with-open-registry-key</code></li>
  <li id="209"><code>do-registry-subkey-names</code></li>
  <li id="210"><code>do-registry-value-names</code></li>
  <li id="211"><code>registry-value-present-p</code></li>
  <li id="212"><code>registry-value</code></li>
  <li id="213"><code>(setf registry-value)</code></li>
</ul>





<hr><h2 id="214"><a name="writing-auto-client-2">3.3 Writing an Automation Client</a></h2>

<p id="215">
Automation allows one application to communicate with and control
another. The server application offers a set of objects to
control. The client application controls the objects offered by the
server. The server can be a standalone application (often called an
'exe' or local server) or it can be a so-called in-proc server, i.e.,
one that is implemented in a dll that is loaded into the client
application. The client need not know which method is being
used, but it can set limits, refusing to use a local server, for
example.
</p>
<p id="216">
An automation object has a set of properties and a set of
methods. Properties can be read or set (although the object server can
ignore an attempt to set a property the server considers
read-only). Methods can be called on an object and a value returned
from the method. Properties and methods are named. The name is a
case-insensitive string; Allegro CL OLE functions to access them can use
strings or symbols.
</p>
<p id="217">
A property and a method can have the same name because when that name
is used it is clear from the use whether the property or method is
intended.
</p>

<hr><h2 id="218"><a name="dynamic-naming-3">3.3.1 Dynamic naming</a></h2>

<p id="219">
Automation is similar to Lisp itself in that the binding of name to
property or method is done at runtime. Some automation objects support
early-binding of names to properties and methods using a type
library. The lisp-ole interface does not support this yet.
</p>



<hr><h2 id="220"><a name="unique-ids-3">3.3.2 Unique ids</a></h2>

<p id="221">
In order for applications to talk about classes and interfaces and to
be sure that they are talking about the same ones, they use
GUIDs. You'll often see a guid written this way
</p>
<pre id="222">
{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
</pre>
<p id="223">
where the x's are hex digits. In Lisp we represent guids as lisp-guid
structures and provide functions for converting between any of the
common guid representations.
</p>
<p id="224">
There is a Microsoft program to generate unique ids that are
guaranteed to be (almost-but-not-quite certainly) distinct from any
other on Earth for all time. You'll want to use this program if you
plan on distributing your automation server. For just experimenting
you can choose any random sequence of digits and chances are it will
be different than anything else on your machine.
</p>



<hr><h2 id="225"><a name="classes-3">3.3.3 Classes</a></h2>

<p id="226">
An OLE class describes a collection of objects. Each COM/OLE class has
a unique guid. The class is the key to getting communication started
between the client and the server. The client initiates the
communication by asking for a pointer to a class object's class
factory. Once the class factory is returned, the client can ask the
factory to create one or more automation objects.</p>



<hr><h2 id="227"><a name="remote-autotool-3">3.3.4 The Lisp remote-autotool Class</a></h2>


<p id="228">
Allegro CL OLE defines the <code>ole:remote-autotool</code> class to
facilitate control of automation objects. An instance of 
<code>ole:remote-autotool</code> holds the Ole machinery
that communicates with the server application.
</p>



<hr><h2 id="229"><a name="setup-3">3.3.5 Set-up</a></h2>


<p id="230">
To establish a connection to an automation object you can use the
function <code>ask-for-autotool</code>.
</p>

<pre id="231">
(setq autoinstance
  (ole:ask-for-autotool
    (ole:unique-guid "{dbce6200-e0a3-21cf-b565-00aa0064595a}")
    ole:CLSCTX_INPROC_SERVER))
</pre>

<p id="232">
is the form to use if you know the OLE class id. If the
application that supports the class is registered, you can bypass the
class id and use the registered application name:
</p>

<pre id="233">
(setq autoinstance 
      (ole:ask-for-autotool "MSCAL.Calendar" ole:CLSCTX_INPROC_SERVER))
</pre>

<p id="234">
If you expect to create more than one instance of the same object type
then it's more efficient to ask for the class factory and then ask the
factory for the specific objects you want to create.
</p>

<pre id="235">
(setq factory
      (ole:get-class-object
         "{dbce6200-e0a3-11cf-b565-00aa0064595a}"
         ole:CLSCTX_LOCAL_SERVER
         ole:IID_IClassFactory))
(setq autoinstance (ole:ask-for-autotool factory nil))
</pre>

<p id="236">
If <code>xdi</code> is an <code>IDispatch-client</code>
interface for an object that supports automation, you can build an
autotool object for it like this:
</p>

<pre id="237">
(setq autoinstance 
      (make-instance 'ole:remote-autotool :dispatch xdi))
</pre>

<p id="238">
Whichever route you take to acquire the
<code>remote-autotool</code> instance, you can then use the
functions <code>auto-getf</code>, <code>(setf
auto-getf)</code>, and <code>auto-method</code> to read
properties, set properties, and call functions on the automation
object.
</p>
<p id="239">
For example,
</p>

<pre id="240">
(ole:auto-getf autoinstance :x)
</pre>

<p id="241">
will ask for the value of the x property of the automation object.
</p>

<pre id="242">
(setf (ole:auto-getf autoinstance :x) 555)
</pre>

<p id="243">
will set the x property value to 555.
</p>

<pre id="244">
(ole:auto-method autoinstance :foob 3 4)
</pre>

<p id="245">
will call the <code>foob</code> method on the
automation object, passing in two extra arguments, 3 and 4.
</p>
<p id="246">
When you've completed using the remote object do (ole:release
autoinstance) to free it on the server side. After the call to
ole:release, don't use the autoinstance object again since it no
longer refers to an object on the server.
</p>





<hr><h2 id="247"><a name="writing-a-server-2">3.4 Writing a Server</a></h2>

<p id="248">
Writing an automation server is simplified by using the Allegro CL OLE
automation and factory interfaces. See ole/samples/sample04/server.cl
for an example. 
</p>

<p id="249">
Suppose you, a Lisp programmer, have some functionality you want to
offer to clients via OLE/COM. 
</p>

<p id="250">
First figure out which interfaces you want to support in this
object. You don't have to declare them all immediately, you can add
more later on. You must support IUnknown at least. Each interface must
be defined in your application. Many interfaces are already
defined. Check the ole/defifc directory to see which. If there is
already a definition, you probably want to use it. If the interface
doesn't appear in ole/defifc, then you will need to provide a
definition using <code>def-ole-interface</code> and
<code>def-server-interface</code>. You can put the definitions in
your application source code if the interface is unique to that
application. Alternatively, you can add it to the Allegro CL OLE library if
you expect to use it in more than one application.
</p>

<p id="251">
Next you define a CLOS class whose instances will represent objects
allocated on behalf of the client. This CLOS class should be defined
with <code>def-ocx-class</code> or be a subclass of such a class. The
<code>def-ocx-class</code> form will name each interface that this
object will export to clients, except possibly IUnknown, which gets
put in automatically if you don't name it. The interface names are
symbols like <code>IStorage</code>, <code>IOleObject</code>,
etc. Example:
</p>

<pre id="252">
(ole:def-ocx-class my-class (:interfaces IFoo) ....)
</pre>

<p id="253">
Put in all the interfaces you want to support after the :interfaces
keyword. If you want to support two different interfaces with the same
interface object, where one is based on the other, include a list of
the related interfaces as one of the entries after the :interfaces
keyword, as in 
</p>

<pre id="254">
(ole:def-ocx-class my-class (base1 :interfaces
                                   (IViewObject IViewObject2)
                                   IOleObject)
  ((local-slot ..)
     ...))
</pre>

<p id="255">
Here, a request for either IViewObject or IViewObject2 will be
satisfied with the same object, which will be of type
IViewObject2-server. The last named interface in a set is the one that
is used for any of them. 
</p>

<p id="256">
With the CLOS class <code>my-class</code> defined you must now make
sure that the methods for each exported interface are defined over
this type of data object. Suppose your class supports the IFoo
interface, an interface that has four methods: the three from
IUnknown, plus the method 'addem' that adds its two integer arguments
together and returns an integer result. The interface definition might
look like this:
</p>

<pre id="257">
(def-ole-interface IFoo
   (:iid "{12345678-1234-5678-1234-123456781234}")
   (addem (in.arg1 integer) (in.arg2 integer)))

(def-server-interface IFoo)
</pre>

<p id="258">
When a client allocates an object of your class and gets a pointer
to the IFoo interface and then calls addem, control will eventually
reach your server. When that happens, the generic function
<code>addem</code> will be called with three arguments: the first
argument is the CLOS object of your class that the client has remotely
allocated, and the other two arguments are the integers to add. You
could thus write your server method in this way:
</p>

<pre id="259">
(defmethod addem ((obj my-class) x y) (+ x y))
</pre>

<p id="260">
In this particular case, as in most cases, the function of the addem
method in the IFoo interface doesn't depend on the object itself, so
we might just want to write that method for all classes that export
that interface: 
</p>

<pre id="261">
(defmethod addem ((obj IFoo) x y) (+ x y))
</pre>

<p id="262">
this works because all classes that export the IFoo interface are a
subclass of IFoo.  Or we could write it for the interface object
itself and not bother to look for an object-specific function. 
</p>

<pre id="263">
(defmethod addem ((ifc IFoo-server) x y) (+ x y))
</pre>

<p id="264">
Allegro CL OLE uses this ability to write methods over an interface to
define the three methods inherited from IUnknown: add-ref, release,
and query-interface. Thus the server class writer generally doesn't
have to worry about writing these methods. (And in fact, should not
replace the primary methods, ever. :before, :after, and :around
methods are OK.)
</p>



<hr><h2 id="265"><a name="defining-interfaces-2">3.5 Defining Interfaces</a></h2>

<p id="266">
The <code>def-ole-interface</code> macro defines each interface. With
it you name the interface (without the "-server" or
"-client" as that is added by
<code>def-server-interface</code> and
<code>def-client-interface</code>). The <code>def-ole-interface</code>
macro allows you to specify the IID and the methods for the interface,
possibly specifying a base interface to inherit methods from. You list
the methods by name and give an argument map (name and type) for each
argument of each method. The macro expands into code that creates a
structure containing all this information. The argument-type
encoding is the one used by ff:def-foreign-type. An older form,
approximating what appears in the C header files, is also accepted,
but is deprecated.
</p>

<p id="267">
With <code>def-server-interface</code> you specify the interface
you're generating linkage code for, as in 
</p>

<pre id="268">
(def-server-interface IFoo)
</pre>

<p id="269">
The result is to define two classes: <code>IFoo-server</code> is the
server interface class. <code>IFoo</code> is the mixin class for all
objects that support the IFoo interface. 
</p>

<p id="270">
It may be confusing to have two classes representing an interface on
the server side: <code>IFoo-server</code> and
<code>IFoo</code>. The difference between the classes is this:
Instances of <code>IFoo-server</code> are interface objects,
which have relatively simple and unchanging functionality. These
methods are called first when a client call comes in so you might want
to write methods that do argument transformation before passing the
call to the object-specific code.
</p>

<p id="271">
An object could reasonably be both <code>IViewObject</code> and
<code>IOleObject</code>.  That would mean that it made both
types of interfaces available to clients and responded appropriately
to methods on either interface. However, an
<code>IOleObject-server</code> object is definitely <b>not</b>
an <code>IViewObject-server</code> object. They have completely
different virtual function tables attached to their proxies. (A
<i>virtual function table</i>, or <i>vtable</i> or <i>Vtbl</i>, is a
C++ object (C++ is typically used to implement OLE) which is a table
which associates functions with objects, allowing for method-like
functionality.)
</p>

<p id="272">
Thus if you want to write methods over your server objects that depend
on them having an IFoo interface, then you write those methods over
IFoo. As an example, the IUnknown reference counting methods would be
best written over <code>IUnknown</code>, since all objects that
support an IUnknown interface will inherit from
<code>IUnknown</code>. 
</p>



<hr><h2 id="273"><a name="low-level-view-2">3.6 Low Level View</a></h2>

<hr><h2 id="274"><a name="class-hierarchies-3">3.6.1 Class Hierarchies</a></h2>

<p id="275">The mixin class hierarchy for the <code>IUnknown</code> interface:
</p>

<pre id="276">
ole:IUnknown ole::interface-mixin
</pre>

<p id="277">
The mixin class hierarchy for a random <code>IFoo</code> interface:
</p>
<pre id="278">
IFoo ole:IUnknown ole::interface-mixin
</pre>

<p id="279">
The server class hierarchy for a random interface
<code>IFoo</code> is
</p>

<pre id="280">
IFoo-server ole:IUnknown-server ole::lisp-ole-interface
</pre>

<p id="281">
The application class hierarchy for a random class
<code>my-class</code> supporting the <code>IUnknown</code>
and <code>IFoo</code> interfaces is
</p>

<pre id="282">
my-class ole::lisp-ole-object IFoo ole:IUnknown
</pre>



<hr><h2 id="283"><a name="control-flow-3">3.6.2 Control Flow</a></h2>

<p id="284">Now we'll look at what happens when you define a class like </p>

<pre id="285">
(ole:def-ocx-class my-class (:interfaces IFoo) ....)
</pre>

<p id="286">
In this case <code>my-class</code> inherits from <code>IFoo</code>
explicitly and from <code>lisp-ole-object</code> and
<code>IUnknown</code> implicitly. The <code>lisp-ole-object</code>
class contributes two instance slots: 
</p>

<pre id="287">
ref-count
interfaces
</pre>

<p id="288">
The <code>ref-count</code> is used to count the number of users of
this object; we don't track uses by each interface separately. The
<code>interfaces</code> slot holds data that controls the allocation
and caching of the interface objects for this instance of
<code>my-class</code>. The data is built and stored in this slot
automatically through some :around method magic; newly allocated
interface objects are cached for later reuse. 
</p>

<p id="289">
When an instance of <code>my-class</code> is polled with
QueryInterface, an interface object is either found or is built and
cached. Each interface object has two slots
</p>

<ul>
  <li id="290"><code>owner</code></li>
  <li id="291"><code>handle</code></li>
</ul>

<p id="292">
The <code>owner</code> slot points to the instance of
<code>my-class</code> that has this interface object on its
interfaces list. The <code>handle</code> slot points to a proxy
object. A proxy object is a :c foreign array made to look like a C++
(COM/OLE) object whose first slot points to a vtbl of functions for
this interface. This proxy object is created when first needed. The
second slot of the proxy contains information that helps us quickly
find the associated Lisp interface object when a method call comes in
from the outside world.
</p>

<p id="293">
Here is how it all works: When a client makes a call on an interface
method, and control reaches the Lisp server, Lisp is passed the
address of the proxy object as the first argument (this is the C++
'this' pointer). Lisp then can use some internal machinery to locate
the interface object, and calls the generic function associated with
that method, usually a function with the same name as the OLE
interface method. The generic function's arguments are the instance of
the interface object associated with the proxy object, and the rest of
the method arguments. If the interface was created in the usual way
(with <code>def-server-interface</code>), then a method was automatically
written that specializes on the first argument being an instance of
this interface, and that method calls the same generic function, this
time with the first argument being the instance of <code>my-class</code>
found in the interface object's <code>owner</code> slot.
</p>

<p id="294">
Here's an example using our IFoo interface with its addem(int x, int
y) function. When the client calls lpFoo-&gt;DoSomething (3, 4)
control reaches our (automatically generated) defun-c-callable
function
</p>

<pre id="295">
vtbl.addem(proxy_address, 3, 4)
</pre>

<p id="296">
this function finds the interface object, an IFoo-server, from the
proxy_address and calls the addem generic function:
</p>

<pre id="297">
(addem interface-obj 3 4)
</pre>

<p id="298">This in turn invokes the specialized method</p>

<pre id="299">
(addem (obj IFoo-server) x y)
</pre>

<p id="300">
which is automatically defined to do (slot-value obj 'owner) to find
the instance with this interface and call the generic function
</p>


<pre id="301">
(addem owner-obj 3 4)
</pre>

<p id="302">
This selects the specialized method
</p>

<pre id="303">
(addem (obj my-class) x y)
</pre>

<p id="304">
That method, defined explicitly in the application code, computes and
returns a value, which is then returned to the client.
</p>






</body><hr><p id="2"><small>Copyright (c) 1998-2017, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page was not revised from the 10.0 page.</small><br><small>Created 2017.2.15.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/ole.htm">10.0 version</a></td></tr></table></html>