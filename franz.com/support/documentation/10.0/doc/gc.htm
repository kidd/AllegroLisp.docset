<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"> <title>Garbage Collection</title></head><link rel="stylesheet" href="acldoc-styles.css" type="text/css"><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.0</b><br><small><a href="introduction.htm#updates-s">Significantly revised from 9.0.</a></small><br><a href="http://www.franz.com/support/documentation/9.0/doc/gc.htm">9.0 version</a></td></tr></table><h1 id="2">Garbage Collection</h1><p id="3">This document contains the following sections:</p><a href="#gc-intro-1">1.0 Garbage collection introduction</a><br>&nbsp;&nbsp;&nbsp;<a href="#gc-scheme-2">1.1 The garbage collection scheme </a><br>&nbsp;&nbsp;&nbsp;<a href="#multi-threading-2">1.2 Using multiple threads in global gc's</a><br>&nbsp;&nbsp;&nbsp;<a href="#precise-2">1.3 Precise gc's of the stack</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#stack-lifo-3">1.3.1 The LIFO section of the stack and dynamic-extent declarations</a><br>&nbsp;&nbsp;&nbsp;<a href="#reward-assessment-2">1.4 Assessing whether the adjustment and compactification phases are justified</a><br>&nbsp;&nbsp;&nbsp;<a href="#newspace-management-2">1.5 How newspace is managed with scavenges</a><br>&nbsp;&nbsp;&nbsp;<a href="#when-scavenges-2">1.6 When scavenges occur</a><br>&nbsp;&nbsp;&nbsp;<a href="#age-of-objects-2">1.7 The system knows the age of objects in newspace</a><br>&nbsp;&nbsp;&nbsp;<a href="#objects-tenured-2">1.8 Objects that survive long enough are tenured to oldspace</a><br>&nbsp;&nbsp;&nbsp;<a href="#new-and-oldspace-placement-2">1.9 Placement of newspace and oldspace: the simple model</a><br>&nbsp;&nbsp;&nbsp;<a href="#spaces-growing-2">1.10 Oldspace, newspace, and Lisp will grow when necessary</a><br>&nbsp;&nbsp;&nbsp;<a href="#gaps-2">1.11 The almost former gap problem</a><br><a href="#gc-user-control-1">2.0 User control over the garbage collector</a><br>&nbsp;&nbsp;&nbsp;<a href="#switches-and-parameters-2">2.1 Switches and parameters</a><br>&nbsp;&nbsp;&nbsp;<a href="#triggering-scavenge-2">2.2 Triggering a scavenge</a><br>&nbsp;&nbsp;&nbsp;<a href="#triggering-global-2">2.3 Triggering a global gc</a><br>&nbsp;&nbsp;&nbsp;<a href="#getting-gc-info-2">2.4 Getting information on memory management using cl:room</a><br><a href="#gc-tuning-1">3.0 Tuning the garbage collector</a><br>&nbsp;&nbsp;&nbsp;<a href="#finding-out-when-scavenge-happens-2">3.1 How do I find out when scavenges happen?</a><br>&nbsp;&nbsp;&nbsp;<a href="#bytes-tenured-2">3.2 How many bytes are being tenured?</a><br>&nbsp;&nbsp;&nbsp;<a href="#global-bytes-freed-2">3.3 When there is a global gc, how many bytes are freed up?</a><br>&nbsp;&nbsp;&nbsp;<a href="#how-many-old-areas-2">3.4 How many old areas are there after your application is loaded?</a><br>&nbsp;&nbsp;&nbsp;<a href="#changing-while-running-2">3.5 Can other things be changed while running?</a><br><a href="#gc-initial-sizes-1">4.0 Initial sizes of old and new spaces</a><br><a href="#gc-params-and-switches-1">5.0 System parameters and switches</a><br>&nbsp;&nbsp;&nbsp;<a href="#generation-and-tenuring-parameters-2">5.1 Parameters that control generations and tenuring</a><br>&nbsp;&nbsp;&nbsp;<a href="#minimum-size-parameters-2">5.2 Parameters that control minimum size</a><br>&nbsp;&nbsp;&nbsp;<a href="#newspace-size-parameters-2">5.3 Parameters that control how big newly allocated spaces are</a><br>&nbsp;&nbsp;&nbsp;<a href="#full-gllobal-param-2">5.4 :minimum-recovery-bytes parameter for less than full global gc</a><br>&nbsp;&nbsp;&nbsp;<a href="#smp-parameters-2">5.5 Parameters that use of multiple threads by the GC</a><br>&nbsp;&nbsp;&nbsp;<a href="#gsgc-switches-2">5.6 Gc switches</a><br>&nbsp;&nbsp;&nbsp;<a href="#gsgc-functions-variables-2">5.7 Gsgc functions and variables</a><br><a href="#global-gc-1">6.0 Global garbage collection</a><br>&nbsp;&nbsp;&nbsp;<a href="#tenuring-macro-2">6.1 The tenuring macro</a><br><a href="#gc-cursors-1">7.0 Gc cursors</a><br><a href="#other-gc-info-1">8.0 Other gc information </a><br><a href="#gc-errors-1">9.0 gc errors</a><br>&nbsp;&nbsp;&nbsp;<a href="#storage-condition-2">9.1 Storage-condition errors</a><br>&nbsp;&nbsp;&nbsp;<a href="#gsgc-failure-2">9.2 Gsgc failure including System Error</a><br><a href="#weak-vecs-etc-1">10.0 Weak vectors, finalizations, static arrays, etc.</a><br>&nbsp;&nbsp;&nbsp;<a href="#weak-arrays-2">10.1 Weak arrays and hashtables</a><br>&nbsp;&nbsp;&nbsp;<a href="#finalizations-2">10.2 Finalizations</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#finalization-weak-objects-3">10.2.1 A finalized object may still be pointed to by a weak vector or hash-table</a><br>&nbsp;&nbsp;&nbsp;<a href="#weak-array-finalization-example-2">10.3 Example of weak vectors and finalizations</a><br>&nbsp;&nbsp;&nbsp;<a href="#static-arrays-2">10.4 Static arrays</a><br><hr><hr><h2 id="4"><a name="gc-intro-1">1.0 Garbage collection introduction</a></h2>

<p id="5">
Lisp does its own memory management. The <i>garbage collector</i>
is part of the memory management system. It disposes of objects that
are no longer needed, freeing up the space that they occupied. While
the garbage collector is working, no other work can be done.
Therefore, we have made the garbage collector as fast and unobtrusive
as possible. Allegro CL uses a version of the generation-scavenging
method of garbage collection. Because optimal performance of
generation-scavenging garbage collection depends on the application,
you have a great deal of control over how the garbage collector
works. In this section, we will describe the user interface to the
garbage collector, and suggest how to tune its performance for an
application. In what follows, the generation-scavenging garbage
collection system will be abbreviated <i>gsgc</i>, and the act of
garbage collecting will be abbreviated <i>gc</i>.
</p>
<p id="6">
Symbols naming gc-related functionality are generally in
the <code>:excl</code> package or the <code>:system</code>
package.
</p>

<hr><h2 id="7"><a name="gc-scheme-2">1.1 The garbage collection scheme </a></h2>

<p id="8">
The Allegro CL garbage collector is a two-space, generation-scavenging
system. The two spaces are called newspace and oldspace. Note that, as
we describe below, newspace is divided into two pieces, called areas,
and oldspace may be divided into a number of pieces, also called
areas. Generally, when we say newspace, we mean both newspace areas
and when we say oldspace, we mean all oldspace areas. We try to use
the word <i>area</i> when we want to refer to a single area, but
please note that this naming convention is new and you may run into
text that uses `oldspace' to refer to an oldspace area. Usually, the
context should make this clear.
</p>
<p id="9">
Newspace is gc'ed with operations called <i>scavenges</i>. Scavenges
eliminate all garbage in newspace and may retain live objects in
newspace or move them to oldspace. Scavenges are typically very fast
and reasonably frequent. They are not under user control, but rather
triggered automatically when necessary. The
section <a href="#newspace-management-2">Section 1.5 How newspace is managed with scavenges</a> below
describes scavenges.
</p>
<p id="10">
Oldspace is gc'ed with operations called <i>global gc's</i>. Global
gc's are under user control, though triggering them can be automated.
Global gc's usually take much longer than scavenges. Oldspaces and
global gc's are described throughout this document, but the
section <a href="#objects-tenured-2">Section 1.8 Objects that survive long enough are tenured to oldspace</a> provide an
introduction. Global gc's can use multiple (concurrent in SMP
Lisps) threads, as we describe in the
section <a href="#multi-threading-2">Section 1.2 Using multiple threads in global gc's</a> below.
</p>





<hr><h2 id="11"><a name="multi-threading-2">1.2 Using multiple threads in global gc's</a></h2>


<p id="12">
The features described in this section were added in release
10.0. Note this feature is not implemented in Sparc Solaris
Lisps.
</p>


<p id="13">
The garbage collector can use multiple threads for global gc's. This
is true even in non-SMP Lisps (except, as noted, on Solaris
platforms). When extra cores are available, this can have a
significant effect on global gc time, since the gc worker threads can
run concurrently. 
</p>
<p id="14">
The function <a href="operators/system/gc-parameters.htm"><b>sys:gc-parameters</b></a> returns (or prints)
information about aspects of the gc setup. The
related <a href="operators/system/gc-parameter.htm"><b>sys:gc-parameter</b></a>
returns information about specific parameters and <a href="operators/system/gc-switch.htm"><b>sys:gc-switch</b></a> returns information about
gc switches. Where appropriate, they can be used with
<a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a> to reset
values. 
</p>
<p id="15">
The two paraments relevant to multithread global gc's are:
</p>
<ul>
  <li id="16">
    <code>:thread-count</code>: the number of worker threads
    available.
  </li>
  <li id="17">
    <code>:thread-limit</code>: the number of worker threads
    desired. This value is <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>'able.
  </li>
</ul>
<p id="18">
The initial value for <code>:thread-limit</code> is 4. Users
who have a lot of cores and no reason to keep any free for other tasks
(like display or background tasks) might increase the number to get
shorter pause times. Users who have few cores or important background
tasks might want to decrease it. Setting it to 1 means that gc's will always use 1 thread only. Users might vary the value to see
what effect it has on pause times.
</p>


<hr><h2 id="19"><a name="precise-2">1.3 Precise gc's of the stack</a></h2>


<p id="20">
The features described in this section were
added in release 10.0.
</p>


<p id="21">
  Some Lisp values exist on the stack. The garbage collector must scan
  these values to determine whether they are pointing to values in the
  heap which are, therefore, live and should not be gc'ed.
  </p>
<p id="22">
  However, some values on the stack may not be real. When a variable is
  placed on the stack or when the stack pointer is moved so the stack
  is larger, values are not initialized (since doing so would slow
  down executaion time noticeably). During a gc (scavenge or global),
  the stack is scanned and pointers are evaluated. Some do not point
  to Lisp values. Those are leftovers and can be ignored. But some
  point to valid Lisp objects. These might be valid live objects but
  they may also be dead Lisp objects suitable for gc'ing, the pointer
  on the stack coming from an uninitialized value just added or
  uncovered.
</p>
<p id="23">
A <i>conservative</i> approach treats any valid object pointed to from
the stack as live. A <i>precise</i> approach determines (by other
means) which pointers should be considered and follows only those to
objects, which it marks as live. Other pointers are ignored and so do
not themselves keep objects alive. Allegro CL uses a hybrid approach:
precise where possible and conservative where precision is not
possible.
</p>
<p id="24">
The conservative approach is used when the system considers it likely
the function is being debugged (because it has stopped at an
unexpected place), or when information on the frame is insufficient to
tell whether pointers in it should be considered, or when determining
whether the frame should be considered will itself take too much
time. The precise approach is used whenever possible and is the
typical approach used.
</p>
<p id="25">
  The benefit of the conservative approach is that it is easy to
  implement, which is why it is what was implemented for many
  releases. The disadvantages are that objects which are in fact
  garbage are not gc'ed. A more serious consequence is weak vectors
  are prevented from being cleared and finalizations are delayed
  (see <a href="#weak-vecs-etc-1">Section 10.0 Weak vectors, finalizations, static arrays, etc.</a> for information
  on weak vectors and finalizations). These consequenecs are mitigated by precise gc'ing of the stack.
</p>

<hr><h2 id="26"><a name="stack-lifo-3">1.3.1 The LIFO section of the stack and dynamic-extent declarations</a></h2>

<p id="27">
Consider the following code snippet:
</p>

<pre id="28">
 (let ((base (let ((sarray (make-array 10)))
               (declare (dynamic-extent sarray))
               (if (&lt;= length 10)
                   sarray
                 (make-array length)))))
   (declare (dynamic-extent base))
   &lt;body&gt;)
</pre>

<p id="29">
This code snippet happens to work in 9.0 and earlier, but one of the
declarations is lying to the compiler -- the inner dynamic-extent
declaration (it appears first but is within the outer <b>let</b> form)
-- it is declaring <code>sarray</code> to have dynamic extent,
meaning that the promise is that the value
that <code>sarray</code> will not be used beyond the let form
which created it.  But the value is in fact returned from that let
form, thus making a lie out of that dynamic-extent declaration.  If
any other dynamic-extent allocations are performed in the body, or if
a tail-call is performed, the array (which is now dead) will be
overwritten.
</p>
<p id="30">
The reason why this technique works in 9.0 and earlier Lisps is
because stack-allocated objects are always allocated in their own
separate spaces in the stack, and two stack-allocated objects never
overlap.  It's as if the dynamic-extent declaration really meant "good
for the life of this function".  This allows the fudging of
dynamic-extent declarations shown above, but it also creates
potentially huge wastes of space in the stack, forcing the
conservative-gc to scan and validate more slots which increases the
risk of dead slots being unnecessarily forwarded. 
</p>
<p id="31">
Now dynamic extent objects on the stack are put in a single, Last In,
First Out (lifo) area and objects can be freed when logically they are
outside the scope of the dynamic extent declarations. That means in
our example, <code>sarray</code> may be overwritten before it is
in fact truly garbage. Care must be excercise to ensure dynamic extent
declarations are proper.
</p>
<p id="32">
The more compact representation of stack-allocated objects in 10.0
allows even the conservative-gc, when it is used, to scan much fewer
slots, and guarantees that only objects that are or were once alive
will be scanned (and, of course, the precise-gc only scans what is
live).
</p>





<hr><h2 id="33"><a name="reward-assessment-2">1.4 Assessing whether the adjustment and compactification phases are justified</a></h2>


<p id="34">
The features described in this section and its subsections were
added in release 10.0.
</p>


<p id="35">
The process known as <i>reward assessment</i> during a global gc
estimates how much space will be saved by the adjustment and
compactification phases of a global gc. If the estimate is less than
the value of the <b><code>:minimum-recovery-bytes</code></b>
parameter, those phases are skipped. This can result in a significant
time saving. Adjustment and compatification moves objects in
oldspace. When an object is moved, all pointers to that object must be
found and updated. Skipping adjustment and compactification means that
pointers to live objects in oldspace are automatically valid and do
not have to be found or updated. Note dead objects in oldspace are
discarded regardless of whether adjustment and compactification is
performed or not.
</p>
<p id="36">
See the <a href="operators/system/gc-parameter.htm"><b>sys:gc-parameter</b></a> function. When called
with <code>:minimum-recovery-bytes</code> as its required argument,
it returns the value of the parameter:
</p>

<pre id="37">
(sys:gc-parameter :minimum-recovery-bytes) RETURNS number of bytes to be 
                                   recovered if the adjustment and 
                                   compactification phases of a global gc 
                                   are to be performed.
</pre>

<p id="38">
  That value is <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>'able. <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>'ing the value to 0:
  </p>

<pre id="39">
  (setf (sys:gc-parameter :minimum-recovery-bytes) 0)
</pre>

<p id="40">
ensures that those phases are never skipped. That is not recommended
in general.
</p>




<hr><h2 id="41"><a name="newspace-management-2">1.5 How newspace is managed with scavenges</a></h2>

<p id="42">
The two pieces of newspace are managed as a stop-and-copy garbage
collector system. The two areas are the same size. At any one time,
one area is active and the other is not. A newspace area is filled
from one end to the other. Imagine, for example, a book shelf.
Existing books are packed together on the right side. Each new book is
placed just to the left of the leftmost book. It may happen that books
already placed are removed, leaving gaps, but these gaps are ignored,
with each new book still being placed to the left of the location of
the last new book. When the shelf fills up, the other shelf (newspace
area) is used. First, all books remaining are moved to the other
shelf, packed tight to one side, and new books are placed in the next
free location.
</p>

<p id="43">
So with Lisp objects in newspace areas. All existing objects are
packed together on one side of the area and new objects are placed in
the free space next to the existing objects, with gaps left by objects
which are no longer alive being ignored. When the area fills up, Lisp
stops and copies all live objects to the other area, packing them
tight.  Then the process is repeated.
</p>

<p id="44">
The process of copying objects from one newspace area to the other
is called a <em>scavenge</em>.  We will discuss the speed of scavenges
below, but scavenges are supposed to be so fast that humans usually
barely notice them.
</p>




<hr><h2 id="45"><a name="when-scavenges-2">1.6 When scavenges occur</a></h2>

<p id="46">
A scavenge happens in one of the following cases:
</p>
<ol>
<li id="47">
<b>Because gc is called</b>. <a href="operators/excl/gc.htm"><b>gc</b></a> with no argument triggers a
scavenge. <a href="operators/excl/gc.htm"><b>gc</b></a> with arguments
may trigger a global garbage collection and there are scavenges
associated with global
gc's. (See <a href="#triggering-scavenge-2">Section 2.2 Triggering a scavenge</a>.
</li>
<li id="48">
<b>When newspace fills up</b>. There must be a scavenge at this point
because new objects can no longer be allocated.
</li>
<li id="49">
<b>When aclmalloc space is insufficient</b>. If that occurs during a
call to <a href="operators/excl/aclmalloc.htm"><b>aclmalloc</b></a> or
<a href="operators/excl/aclmalloc-aligned.htm"><b>aclmalloc-aligned</b></a>, then a
scavenge may be triggered in the hopes that lispstatic-reclaimable
objects (arrays with <code>:allocation
:lispstatic-reclaimable</code>, for example,
see <a href="implementation.htm#cl-make-array-2">cl:make-array</a>
in <a href="implementation.htm">implementation.htm</a>), or a weak-vector or
finalization will cause aclmalloc space to be freed
(see <a href="#weak-vecs-etc-1">Section 10.0 Weak vectors, finalizations, static arrays, etc.</a>).
</li>
</ol>

<p id="50">
The first listed cause is under user-control. The second and third
causes are under system control and the resulting scavenge cannot be
prevented if the system determines it must occur.
</p>




<hr><h2 id="51"><a name="age-of-objects-2">1.7 The system knows the age of objects in newspace</a></h2>

<p id="52">
The system keeps track of the age of objects in newspace by
counting the number of scavenges that the object has survived. The
number of scavenges survived is called the generation of an
object. When objects are created, they have generation 1, and the
generation is increased by 1 at each scavenge.
</p>

<p id="53">Of course, many objects become garbage as time passes. (An object
is garbage when there are no pointers to it from any other live
object. If there are no pointers to an object, nothing can reference
or access it and so it is guaranteed never to be looked at again.
Thus, it is garbage.) The theory of a generation scavenging garbage
collector is that most objects that will ever become garbage will do
so relatively quickly and so will not survive many scavenges.</p>



<hr><h2 id="54"><a name="objects-tenured-2">1.8 Objects that survive long enough are tenured to oldspace</a></h2>

<p id="55">
The problem with a stop-and-copy system is that objects that
survive have to be moved and moving objects takes time. If an object
is going to be around for a while (or for the entire Lisp session), it
should be moved out of newspace to some place where it does not have
to be moved (or is moved much less often). This is where the other
half of the generation scavenging algorithm comes into play. Once an
object has survived enough scavenges, it is assumed to be long-lived
and is moved to oldspace. Oldspace is not touched during scavenges and
so objects in oldspace are not moved during scavenges, thus saving
considerable time over a pure stop-and-copy system.
</p>

<p id="56">
Part of a scavenge is checking the age (generation) of surviving
objects and moving those that are old enough to oldspace. The
remaining objects are moved to the other newspace area. The age at
which objects are tenured is user-settable. Its initial value is 4 and
that seems to work for many applications. We will discuss below how
changing that (and many other) settings can affect gc performance.
</p>

<p id="57">
The process of moving an object to oldspace is called
<em>tenuring</em> and the object moved is said to be tenured. At one
point, oldspace was also called tenured space and you may see that
term occasionally in Allegro CL documents.
</p>

<p id="58">
Note the assumption: objects that survive a while are likely to
survive a long while.
</p>

<p id="59">
If one could know exactly how long an object is going to survive,
one could provide the best possible garbage collection scheme. But
that knowledge is not available. Objects are created all the time by
different actions and users and even application writers typically do
not know what actions create objects or how long those objects will
live. Indeed, that information often depends on future events that are
hard to control -- such as the behavior of the person running the
application.
</p>

<p id="60">
So the algorithm makes that assumption: if an object survives for a
while, it is likely to survive for a long while, perhaps forever
(forever means the length of the Lisp session). Of course, for many
objects this assumption is wrong: the object may become garbage
soon after it is tenured. However, as we said above, scavenges (which
are automatic and cannot be prevented by a user although they can be
triggered by a user) do not touch oldspace. In order to clear garbage
from oldspace, a global garbage collection (global gc) must be
done. An interface for automating global gc's is provided in Allegro
CL and different interfaces are easy to implement (see below for more
information), but the two important points about global gc's are:
</p>

<ol>
  <li id="61">in most cases, they should be done from time to time; and</li>
  <li id="62">when and if they happen can be wholly under your control.</li>
</ol>



<hr><h2 id="63"><a name="new-and-oldspace-placement-2">1.9 Placement of newspace and oldspace: the simple model</a></h2>

<p id="64">
The Lisp heap grows upwards (to higher addresses). Oldspaces are at
low addresses and newspace occupies addresses higher than any oldspace
area. This means that newspace can grow without affecting oldspace and
oldspace can grow (usually by creating a new oldspace area) by having
newspace move up as far as necessary.
</p>

<p id="65">
Why might newspace grow? Suppose, for example, a newspace area is
600 Kbytes and you want to allocate a 1 Mbyte array. Newspace has to
grow to accommodate this.
</p>

<p id="66">
Why might oldspace grow? As objects are tenured to oldspace, it slowly
fills up. Even with regular global gc's, it can fill up. When it does,
newspace moves up and a new old area is created. (New areas are
created rather than a single area being expanded for various technical
reasons. We discuss below how to reduce sizes dynamically. See
<a href="#changing-while-running-2">Section 3.5 Can other things be changed while running?</a>.)
</p>

<p id="67">
We will not describe the internal algorithms of the garbage
collector because they cannot be changed or modified by users in any
way. But let us consider how newspace might be moved, as this might
make the process clearer. Suppose the current scavenge is about to
move live objects to the high address area. Before anything is moved,
Lisp can compute how much space the live objects need, how much space
objects waiting to be allocated need, and how much space a new old
area needs. From that information, it can compute the highest address
of the high address newspace area. It requests from the Operating
System that the area be allocated (using <strong>malloc</strong> or
<strong>sbrk</strong>), and once the Operating System confirms the
allocation, starts copying the live objects to that high address,
filling toward lower addresses. When all live objects have been moved
and new objects are allocated in the high address newspace area, the
new oldspace area (if one is required) can be created and the location
of the low address newspace area can be determined. Recall that high
address newspace area is active so the low address newspace area does
not contain anything of importance.
</p>



<hr><h2 id="68"><a name="spaces-growing-2">1.10 Oldspace, newspace, and Lisp will grow when necessary</a></h2>

<p id="69">
A consequence of what we just said about newspace moving when it
has to grow or when a new oldspace area is needed is that the size of
the Lisp image can grow while it is running. This is usually normal,
indeed what you want. It allows images to start small and grow as much
(but no more) than they need. It also allows the same image to run
effectively on machines with different configurations.
</p>

<p id="70">But, sometimes growth can be unexpected and the image can want to
grow to a size larger than the Operating System can handle (usually
because there is not enough swap space). </p>

<p id="71">The growth is often necessary, because of the type of application
being run. What is important is that the growth be managed and be no
more than is really needed.</p>



<hr><h2 id="72"><a name="gaps-2">1.11 The almost former gap problem</a></h2>

<p id="73">
In earlier releases, space for foreign code loaded into the image,
space for foreign objects, and direct calls to <strong>malloc</strong>
all could cause a gap to be placed above newspace. If a new oldspace
or a larger newspace was needed, it had to be placed above the gap,
causing in some cases a small need for additional space to result in a
multimegabyte increase in image size. Now, malloc space is placed away
from the new and old spaces and so the Lisp heap (new and old spaces
together) are unaffected and can grow incrementally as needed. There
is a Lisp heap size specified by the <em>lisp-heap-size</em> argument
to <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> (see
<a href="building-images.htm">building-images.htm</a>). The OS will try to reserve
this space when Lisp starts up. If more space is needed, Lisp will
request it from the OS but it is possible more space will not be
available. If this happens, you might increase the original request.
</p>
<p id="74">
The space reserved in a running Lisp is reported as 'resrve' on the
'Lisp heap' line of the output of <code>(room t)</code>.  If the
heap grows larger than that size, gaps may appear. If you see gaps in
your application, you should consider starting with an image with a
larger heap size.
</p>



<hr><hr><h2 id="75"><a name="gc-user-control-1">2.0 User control over the garbage collector</a></h2>

<p id="76">Application writers and users can control the behavior of the
garbage collector in order to make their programs run more
efficiently. This is not always easy, since getting optimal behavior
depends on knowing how your application behaves and that information
may be difficult to determine. Also, there are various paths to
improvement, some of which work better than others (but different
paths work better for different applications).</p>

<p id="77">One thing to remember is that (unless the image needs to grow
larger than available swap space), things will work whether or not
they work optimally. You cannot expect optimal gc behavior at the
beginning of the development process. Instead, as you gather
information about your application and gc behavior, you determine ways
to make it work better.</p>

<hr><h2 id="78"><a name="switches-and-parameters-2">2.1 Switches and parameters</a></h2>

<p id="79">
The automated gc system is controlled by switches and parameters (they
are listed in <a href="#gc-params-and-switches-1">Section 5.0 System parameters and switches</a>
below). There is not much difference between a switch and a parameter
(a switch is usually true or false, a parameter usually has a value)
and there probably should not be a distinction, but these things are
hard to change after they are implemented. The functions <a href="operators/system/gsgc-switch.htm"><b>gsgc-switch</b></a> and <a href="operators/system/gsgc-parameter.htm"><b>gsgc-parameter</b></a> can be used to poll the
current value and (with <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>)
to set the value of switches and parameters.</p>

<p id="80">The function <a href="operators/system/gsgc-parameters.htm"><b>gsgc-parameters</b></a>
prints out the values of all switches and parameters:</p>

<pre id="81">
cl-user(14): (sys:gsgc-parameters)
:generation-spread 4 :current-generation 4 :tenure-limit 0

:free-bytes-new-other 131072 :free-percent-new 25
:free-bytes-new-pages 131072 :expansion-free-percent-new 35
:expansion-free-percent-old 35
:quantum 32

(switch :auto-step) t (switch :use-remap) t
(switch :hook-after-gc) t (switch :clip-new) nil
(switch :gc-old-before-expand) nil (switch :next-gc-is-global) nil
(switch :print) t (switch :stats) t
(switch :verbose) nil (switch :dump-on-error) nil
cl-user(15):
</pre>

<p id="82"><a href="operators/system/gsgc-switch.htm"><b>gsgc-switch</b></a> can poll
and set switches while <a href="operators/system/gsgc-parameter.htm"><b>gsgc-parameter</b></a> can poll and set parameters:
Here we poll and set the <code>:print</code> switch.</p>

<pre id="83">
cl-user(15): (setf (sys:gsgc-switch :print) nil)
nil
cl-user(16): (sys:gsgc-switch :print)
nil
cl-user(17): (setf (sys:gsgc-switch :print) t)
t
cl-user(18): (sys:gsgc-switch :print)
t
cl-user(19):
</pre>

<p id="84">The <a href="operators/excl/gc.htm"><b>gc</b></a> function can be
used to toggle some of the switches. </p>



<hr><h2 id="85"><a name="triggering-scavenge-2">2.2 Triggering a scavenge</a></h2>

<p id="86">
The system will cause a scavenge whenever it determines that one is
necessary. There is no way to stop scavenges from occurring at all or
even to stop them from occurring for a specified period of time.
</p>

<p id="87">
However, you can cause a scavenge by calling the <a href="operators/excl/gc.htm"><b>gc</b></a> function with no arguments:
</p>

<pre id="88">
(excl:gc) ;; triggers a scavenge
</pre>

<p id="89">You can also cause a scavenge and have all live objects tenured by
calling the <a href="operators/excl/gc.htm"><b>gc</b></a> function with
the argument <code>:tenure</code>, like this</p>

<pre id="90">
(excl:gc :tenure) 
</pre>



<hr><h2 id="91"><a name="triggering-global-2">2.3 Triggering a global gc</a></h2>

<p id="92">Global gc's (a gc of old and new space) are not triggered
automatically (but triggering can be automated). You can trigger a
global gc by calling <a href="operators/excl/gc.htm"><b>gc</b></a> with
the argument t:</p>

<pre id="93">
(excl:gc t) ;; triggers a global gc
</pre>

<p id="94">
See section <a href="#global-gc-1">Section 6.0 Global garbage collection</a> for information
on other ways to trigger a global gc and ways to automate global gc's.
</p>



<hr><h2 id="95"><a name="getting-gc-info-2">2.4 Getting information on memory management using cl:room</a></h2>

<p id="96">
The function <a href="../ansicl/dictentr/room.htm"><b>room</b></a> provides
information on current usage (it identifies oldspaces and newspace and
free and used space in each). Setting the <code>:print</code>
switch and perhaps the <code>:stats</code> and
<code>:verbose</code> switches causes the system to print
information while gc's are occurring. See
<a href="#gsgc-switches-2">Section 5.6 Gc switches</a> and
<a href="#finding-out-when-scavenge-happens-2">Section 3.1 How do I find out when scavenges happen?</a>.
</p>

<p id="97">Evaluating <code>(room t)</code> provides the most
information about the current state of memory management. Here is a
<code>(room t)</code> output from a Allegro CL image that has
been doing a fair amount of work. This is from a UNIX machine and was
done immediately after a global gc, so some of the oldspaces have
significant free space.
</p>

<pre id="98">
CL-USER(1): (room t)
area area  address(bytes)        cons         other bytes
  #  type                   8 bytes each
                             (free:used)      (free:used)
     Top #x106a0000
     New #x10598000(1081344)   134:13113     340128:582984
     New #x10490000(1081344)    -----            -----
   1 Old #x10290000(2097152)     0:0        2095952:0
   0*Old #x10000e80(2683264)     0:68273          0:2124792
     Tot (Old Areas)             0:68273    2095952:2124792
* = closed old area



Root pages: 61
  Lisp heap:    #x10000000  pos: #x106a0000 resrve: #x10fa0000
Aclmalloc heap: #x64000000  pos: #x64011000 resrve: #x640fa000
  Pure space:   #x2d1aa000  end: #x2d747ff8


code   type                                 items     bytes 
112: (SIMPLE-ARRAY T)                         6586    930920 28.3%
  1: CONS                                    80502    644016 19.6%
  8: FUNCTION                                 8432    520192 15.8%
  7: SYMBOL                                  17272    414528 12.6%
117: (SIMPLE-ARRAY CHARACTER)                 2259    259984  7.9%
 96: (SHORT-SIMPLE-ARRAY T)                  17498    151736  4.6%
 18: BIGNUM                                   2966    139928  4.3%
125: (SIMPLE-ARRAY (UNSIGNED-BYTE 8))           31     87816  2.7%
 12: STANDARD-INSTANCE                        3291     52656  1.6%
  9: CLOSURE                                  2301     39688  1.2%
 15: STRUCTURE                                 666     24944  0.8%
127: (SIMPLE-ARRAY (UNSIGNED-BYTE 32))           9      9920  0.3%
108: (SHORT-SIMPLE-ARRAY CODE)                  16      7368  0.2%
 10: HASH-TABLE                                108      3456  0.1%
 17: DOUBLE-FLOAT                              120      1920  0.1%
111: (SHORT-SIMPLE-ARRAY FOREIGN)               51      1216  0.0%
 16: SINGLE-FLOAT                              141      1128  0.0%
118: (SIMPLE-ARRAY BIT)                         11       296  0.0%
 20: COMPLEX                                    11       176  0.0%
 80: (ARRAY T)                                   7       168  0.0%
 11: READTABLE                                   8       128  0.0%
123: (SIMPLE-ARRAY (SIGNED-BYTE 32))             1        88  0.0%
 13: SYSVECTOR                                   3        48  0.0%
 85: (ARRAY CHARACTER)                           1        24  0.0%

 total bytes = 3292344
aclmalloc arena:
   max size  free bytes  used bytes     total
       112       3472        112         3584
       496       3472        496         3968
      1008       2016       2016         4032
      2032          0      12192        12192
      4080          0       8160         8160
      9200      18400      18400        36800
 total bytes:   27360      41376        68736
CL-USER(2): 
</pre>

<h4 id="99">Newspace and oldspaces</h4>

<p id="100">
Newspace is divided into two equal size parts (only one of which is
used at any time). There can be numerous oldspaces: two are shown in
the example, but many more are common after Lisp has run for a
while. Oldpsaces are numbered.  The gsgc-parameter
<code>:open-old-area-fence</code> takes such a number as an
argument (see
<a href="#generation-and-tenuring-parameters-2">Section 5.1 Parameters that control generations and tenuring</a>
for information on gsgc-parameters).
</p>
<p id="101">
The 0th old area in the output is closed, as indicated by the
asterisk. If there are no closed old areas
(i.e. <b><code>(sys:gsgc-parameter
:open-old-area-fence)</code></b> returns 0) then no asterisks show
up and the "* = closed old area" note isn't given. When asterisks are
shown, they denote any old areas that are closed. See the discussion
of <b>:open-old-area-fence</b> in
<a href="#generation-and-tenuring-parameters-2">Section 5.1 Parameters that control generations and tenuring</a>
and also the note on closed old areas after the table for information
on closed and open old areas.
</p>

<h4 id="102">Root pages</h4>

<pre id="103">
Root pages: 61
</pre>

<p id="104">
Root pages contain information about pointers from oldspace to newspace.
</p>



<h3 id="105">Lisp heap, Aclmalloc heap, and Pure space</h3>



<pre id="106">
  Lisp heap:    #x10000000  pos: #x106a0000 resrve: #x10fa0000
Aclmalloc heap: #x64000000  pos: #x64011000 resrve: #x640fa000
 Pure space:    #x2d1aa000  end: #x2d747ff8 
</pre>



<p id="107">
The first value is the starting address of the
specified heap in memory. The `Pure space' line only appears in Lisps
which use a pll file (see <a href="operators/excl/pll-file.htm"><b>pll-file</b></a>), showing where the pll files is
mapped.
</p>
<p id="108">
In the first two lines, <strong>pos</strong> (position) is the
highest-use location; this is one byte larger than the highest memory
used by the lisp. Some operating systems will only commit (assign
physical pages) to memory between base (inclusive) and position
(exclusive). This is a hexadecimal address value.
<strong>resrve</strong> (reserved) is the number of bytes lisp thinks
is reserved to it in virtual memory space. On some operating systems
which support it, addresses greater than position, but less than
starting location+reserved, will not be overwritten by
shared-libraries, other memory mapping operations, etc.
</p>

<p id="109">
The Lisp heap reserved size is a true limit only for certain free
products. With paid license images (and some free products), this
value is important only because if the heap grows larger than this
limit, gaps in the heap may appear. See 
<a href="#gaps-2">Section 1.11 The almost former gap problem</a> for more
information. This value is not a limit in any sense on how big the
image can grow.
</p>


<p id="110">
The Aclmalloc heap was called the "C heap" in earlier releases but its
name was changed to reflect its real nature. It is the aclmalloc area
used for space allocated by the <a href="operators/excl/aclmalloc.htm"><b>aclmalloc</b></a> function. That function differs from
<b>malloc()</b> in that it ensures that Lisp will remember the
location of aclmalloc'ed allocations and preserve it through <a href="operators/excl/dumplisp.htm"><b>dumplisp</b></a> and restarts, thus
guaranteeing that aclmalloc addresses remain valid. 
</p>

<p id="111">
<b>More information on aclmalloc and regular malloc():</b>
</p>
<ul>
<li id="112">
<a href="operators/excl/aclmalloc.htm"><b>aclmalloc</b></a> space
must be located at the same spot as it starts out in a
<a href="operators/excl/generate-application.htm"><b>generate-application</b></a>
or <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> (where
it is specified by
the <i>aclmalloc-heap-start</i>
argument).  If the aclmalloc-heap
cannot be located at the same place as before, the Lisp startup will
fail.  This is actually comforting, because it means that addresses
used for <a href="operators/excl/aclmalloc.htm"><b>aclmalloc</b></a> locations
are guaranteed to always be valid and unchanged.
</li>
<li id="113">
<code>malloc()</code> space is always started fresh when a Lisp
starts up, so addresses used by malloc calls must never be used
across dumplisps.
</li>
<li id="114">
The lisp interface to <code>aclmalloc()</code> is <a href="operators/excl/aclmalloc.htm"><b>aclmalloc</b></a>.  There is no Lisp
interface to <code>malloc()</code> (there is an internal
function called <b>excl::malloc</b>, but it calls
<code>aclmalloc()</code>, and not <code>malloc()</code>,
which is why it is not exported).  Foreign definitions for
<code>malloc()</code> and <code>free()</code> can be made
in order to gain access to these functions.  However, calling
<code>malloc()</code> in a Lisp environment is dangerous, and
should only be done after careful consideration of the above.
</li>
</ul>

<h4 id="115">Type counts</h4>
<p id="116">
The type counts are as if printed by 
<a href="operators/excl/print-type-counts.htm"><b>print-type-counts</b></a>:
</p>

<pre id="117">
code   type                                 items     bytes 
112: (SIMPLE-ARRAY T)                         6586    930920 28.3%
  1: CONS                                    80502    644016 19.6%
  8: FUNCTION                                 8432    520192 15.8%
  7: SYMBOL                                  17272    414528 12.6%
117: (SIMPLE-ARRAY CHARACTER)                 2259    259984  7.9%
 96: (SHORT-SIMPLE-ARRAY T)                  17498    151736  4.6%
 18: BIGNUM                                   2966    139928  4.3%
125: (SIMPLE-ARRAY (UNSIGNED-BYTE 8))           31     87816  2.7%
 12: STANDARD-INSTANCE                        3291     52656  1.6%
  9: CLOSURE                                  2301     39688  1.2%
 15: STRUCTURE                                 666     24944  0.8%
127: (SIMPLE-ARRAY (UNSIGNED-BYTE 32))           9      9920  0.3%
108: (SHORT-SIMPLE-ARRAY CODE)                  16      7368  0.2%
 10: HASH-TABLE                                108      3456  0.1%
 17: DOUBLE-FLOAT                              120      1920  0.1%
111: (SHORT-SIMPLE-ARRAY FOREIGN)               51      1216  0.0%
 16: SINGLE-FLOAT                              141      1128  0.0%
118: (SIMPLE-ARRAY BIT)                         11       296  0.0%
 20: COMPLEX                                    11       176  0.0%
 80: (ARRAY T)                                   7       168  0.0%
 11: READTABLE                                   8       128  0.0%
123: (SIMPLE-ARRAY (SIGNED-BYTE 32))             1        88  0.0%
 13: SYSVECTOR                                   3        48  0.0%
 85: (ARRAY CHARACTER)                           1        24  0.0%

 total bytes = 3292344
</pre>

<h4 id="118">Aclmalloc arena</h4>

<p id="119">
The aclmalloc arena describes allocation of space for <a href="operators/excl/aclmalloc.htm"><b>aclmalloc</b></a>s and foreign data. It is
divided into chunks of various sizes to allow allocation of requests
of various sizes without fragmentation. (Space allocated by <a href="operators/excl/aclmalloc.htm"><b>aclmalloc</b></a> is freed by <a href="operators/excl/aclfree.htm"><b>aclfree</b></a>.)
</p>

<pre id="120">
aclmalloc arena:
   max size  free bytes  used bytes     total
       112       3472        112         3584
       496       3472        496         3968
      1008       2016       2016         4032
      2032          0      12192        12192
      4080          0       8160         8160
      9200      18400      18400        36800
 total bytes:   27360      41376        68736
</pre>



<hr><hr><h2 id="121"><a name="gc-tuning-1">3.0 Tuning the garbage collector</a></h2>

<p id="122">
As a user, or as an application writer, how can you get the garbage
collector to work best for you? At first, you do not have to do
anything. The system is set up to work as delivered. You will not run
out of space, global gc's will happen from time to time (as described
below, see <a href="#global-gc-1">Section 6.0 Global garbage collection</a>), the image will
grow as necessary, and assuming you do not run out of swap space,
everything will work.
</p>

<p id="123">
Of course, it will not necessarily work as well as it could. As
delivered, the garbage collector is set to work best with what we
assume is a typical application: objects, none of which are too big,
are created as needed. Most objects that survive a while are likely to
survive a long while or perhaps forever, and so on. If your
application's use of Lisp has different behavior, performance may be
suboptimal. 
</p>

<p id="124">So what to do? One problem is that optimizing gc behavior is a
multidimensional problem. Factors that affect it include </p>

<ol>
  <li id="125">things internal to Lisp (the initial sizes of oldspace and newspace, 
    the various
    products included in the image, whether shared libraries or static 
    text is used for
    certain constants or whether the constants are part of the Lisp heap); </li>
  <li id="126">environmental factors (amount of physical memory, amount of swap space, 
    usual running
    environment -- i.e. runs with lots of other programs or runs on a 
    dedicated machine,
    whether paging is done over the network); and </li>
  <li id="127">details of what your code or application does. </li>
</ol>

<p id="128">Optimization in a multidimensional environment is always
complicated. </p>

<p id="129">The first step is always to gather the information necessary to do
the tuning.  Information like:</p>

<blockquote>
  <p id="130">
  <a href="#finding-out-when-scavenge-happens-2">Section 3.1 How do I find out when scavenges happen?</a>
  <br>
  <a href="#bytes-tenured-2">Section 3.2 How many bytes are being tenured?</a>
  <br>
  <a href="#global-bytes-freed-2">Section 3.3 When there is a global gc, how many bytes are freed up?</a>
  <br>
  <a href="#how-many-old-areas-2">Section 3.4 How many old areas are there after your application is loaded?</a>
  <br>
  <a href="#changing-while-running-2">Section 3.5 Can other things be changed while running?</a>
  </p>
</blockquote>

<hr><h2 id="131"><a name="finding-out-when-scavenge-happens-2">3.1 How do I find out when scavenges happen?</a></h2>

<p id="132">
There are three gsgc switches (these control the behavior of the
garbage collector) that affect printing information about the garbage
collector: <code>:print</code>, <code>:stats</code>, and
<code>:verbose</code>. Doing
</p>

<pre id="133">
(setf (sys:gsgc-switch :print) t)
</pre>

<p id="134">
will cause a short message to be printed whenever a scavenge
happens. Unless the <code>:print</code> switch is <code>t</code>, no message will be printed.
</p>

<p id="135">
The <code>:stats</code> and <code>:verbose</code>
switches control the amount of information printed. If the
<code>:stats</code> switch is true, the message contains more
information but the information is compact. If the
<code>:verbose</code> switch is also true, a longer, more easily
understood message is printed.</p>

<pre id="136">
;; In this example, we cause a scavenge with all flags off, 
;; then with :print true, then :print and :stats true, 
;; and finally :print, :stats, and :verbose all true.
cl-user(5): (gc)
cl-user(6): (setf (sys:gsgc-switch :print) t)
t
cl-user(7): (gc)
gc: done
cl-user(8): (setf (sys:gsgc-switch :stats) t)
t
cl-user(9): (gc)

gc: E=0% N=866432 T+=3088 A-=0 pfu=0+3
cl-user(10): (setf (sys:gsgc-switch :verbose) t)
t
cl-user(11): (gc)

scavenging...done eff: 0%, new copy: 9472 + tenure: 480 +  aclmalloc free: 0 = 9952
  Page faults: non-gc = 0 major + 1 minor
Page faults: gc = 0 major + 2 minor
cl-user(12):
</pre>



<p id="137">
With just <code>:print</code> true, a very short message is
printed. With <code>:stats</code> true, the message contains
much more information, but it is coded -- E means Efficiency; N means
bytes copied in newspace; T means bytes copied to oldspace (i.e. bytes
tenured); A- means aclmalloc data freed; pfu means non-gc page faults
and pgu (not shown) means page faults during garbage collection. The
pfu and pfg values may be left out if there were no page faults. With
<code>:verbose</code> also true, the same information is
displayed in expanded form and additional information (about page
faults) is provided.
</p>


<p id="138"><em>Efficiency</em> is defined as the ratio of cpu time not
associated with gc to total cpu time. Efficiency should typically be
75% or higher, but the efficiencies in the example are low because we
triggered gc's without doing anything else of significance.</p>

<p id="139">It is usually desirable to have <code>:print</code> and
<code>:stats</code> true while developing software. This allows you to
monitor gc behavior and see if there seems to be a problem.</p>



<hr><h2 id="140"><a name="bytes-tenured-2">3.2 How many bytes are being tenured?</a></h2>

<p id="141">That information is shown when the <code>:print</code> and
<code>:stats</code> switches are true, but perhaps the real
question is whether things are being tenured that would be better left
in newspace (because they will soon become garbage). This often
happens when a complex operation (like a compile of a large file) is
being carried out. This question, in combination with the next can
tell you if that is the case.</p>



<p id="142">In the following, copied from above, 0 bytes are tenured in the
first gc (T+=0) and 16064 in the second (tenure: 16064):</p>


<pre id="143">
cl-user(9): (gc)
gc: E=17% N=17536 T+=0 A-=0
cl-user(10): (setf (sys:gsgc-switch :verbose) t)
t
cl-user(11): (gc)
scavenging...done eff: 15%, copy new: 1664 + tenure: 16064 +  aclmalloc free: 0 = 17728
Page faults: gc = 0 major + 2 minor
cl-user(12):
</pre>



<hr><h2 id="144"><a name="global-bytes-freed-2">3.3 When there is a global gc, how many bytes are freed up?</a></h2>

<p id="145">If the <code>:print</code> and <code>:stats</code>
switches are true, the amount of space freed by a global gc is printed
at the end of the report. Here is an example. The form <code>(gc
t)</code> triggers a global gc.</p>

<pre id="146">
cl-user(13): (gc t)
gc: Mark Pass...done(1,583+66), marked 128817 objects, max depth = 17, cut 0 xfers.
Weak-vector Pass...done(0+0).
Cons-cell swap...done(0+67), 346 cons cells moved
Symbol-cell swap...done(17+0), 1 symbol cells moved
Oldarea break chain...done(83+0), 40 holes totaling 6816 bytes
Page-compaction data...done(0+0).
Address adjustment...done(1,400+67).
Compacting other objects...done(150+0).
Page compaction...done(0+0), 0 pages moved
New rootset...done(667+0), 20 rootset entries
Building new pagemap...done(83+0).
Merging empty oldspaces...done, 0 oldspaces merged.
global gc recovered 9672 bytes of old space.

gc: E=0% N=1504 T+=0 A-=0 pfg=54+187
cl-user(14):
</pre>

<p id="147">The next to last line reports on what was recovered from oldspace
(9672 bytes). The value is often much higher. It is low in this
example because we have not in fact done anything significant other
than test gc operations.</p>

<p id="148">There is plenty of other information but we will not describe its
meaning in detail. It is typically useful in helping us help you work
out complicated gc problems.</p>

<p id="149">The amount of space freed is a rough measure of how many objects
are being tenured that perhaps should be left for a while longer in
newspace. If the number is high, perhaps things are being tenured too
quickly (increasing the value of the <code>:generation-spread</code>
switch will keep objects in newspace longer, as will a larger
newspace).</p>



<hr><h2 id="150"><a name="how-many-old-areas-2">3.4 How many old areas are there after your application is loaded?</a></h2>

<p id="151">
The output printed by <a href="../ansicl/dictentr/room.htm"><b>room</b></a>
shows the two newspace areas and the various oldspace areas. Here is
an example of <a href="../ansicl/dictentr/room.htm"><b>room</b></a>
output. (<a href="../ansicl/dictentr/room.htm"><b>room</b></a> takes an
argument to indicate how much information should be displayed). The
following is the output of <code>(cl:room t)</code>, which
causes the most information to be displayed.
</p>

<pre id="152">
cl-user(3): (room t)
area area  address(bytes)        cons         other bytes
  #  type                   8 bytes each
                             (free:used)      (free:used)
     Top #x569a000
     New #x5134000(5660672)      5:95781     597040:4239616
     New #x4bce000(5660672)     -----            -----
   7 Old #x498e000(2359296)    458:18903      31904:2170416
   6 Old #x494e000(262144)       0:1019           0:253648
   5 Old #x478e000(1835008)      0:41779          0:1498064
   4 Old #x474e000(262144)       0:23437          0:73424
   3 Old #x45ce000(1572864)      0:27513          0:1350736
   2 Old #x454e000(524288)       0:7133           0:466512
   1 Old #x448e000(786432)       0:4076           0:753104
   0 Old #x4000d00(4772608)      0:97824          0:3983672
     Tot (Old Areas)           458:221684     31904:10549576
Root pages: 158


  Lisp heap:    #x4000000  pos: #x569a000 resrve: 23699456
Aclmalloc heap: #x54000000  pos: #x54027000 resrve: 1024000


code   type                                 items     bytes 
 96: (simple-array t)                        76658   3864816 22.8%
108: (simple-array code)                      8699   3608136 21.3%
  1: cons                                   314901   2519208 14.9%
 99: (simple-array (unsigned-byte 16))       10938   2242320 13.2%
101: (simple-array character)                38383   1632920  9.6%
  8: function                                21721   1284216  7.6%
  7: symbol                                  36524    876576  5.2%
107: (simple-array (signed-byte 32))           264    264336  1.6%
 12: standard-instance                       14244    227904  1.3%
  9: closure                                  8854    145448  0.9%
 98: (simple-array (unsigned-byte 8))           44    105184  0.6%
 97: (simple-array bit)                         49    103952  0.6%
 15: structure                                 830     33144  0.2%
100: (simple-array (unsigned-byte 32))          12     10264  0.1%
 10: hash-table                                225      7200  0.0%
 18: bignum                                    410      4480  0.0%
 16: single-float                              505      4040  0.0%
111: (simple-array foreign)                    103      2464  0.0%
 17: double-float                              124      1984  0.0%
 64: (array t)                                  22       528  0.0%
 65: (array bit)                                13       312  0.0%
 13: sysvector                                  14       224  0.0%
 20: complex                                    12       192  0.0%
 11: readtable                                   7       112  0.0%
 69: (array character)                           1        24  0.0%

 total bytes = 16939984
aclmalloc arena:
   max size  free bytes  used bytes     total
        48       3024         48         3072
       496       3968          0         3968
      1008       4032          0         4032
      2032       2032       2032         4064
      4080       8160      36720        44880
      5104      10208      10208        20416
      9200      27600       9200        36800
     20464      20464      20464        40928
 total bytes:   79488      78672       158160
cl-user(4): 
</pre>

<p id="153">
The output shows the two equal size newspace areas, only one of which
is being used. It also shows eight oldspaces and provides information
about what is in the oldspaces.  Then information is printed about
other objects such as the number of root pages (a root page keeps
information on pointers from oldspace to newspace -- these pointers
must be updated after a scavenge), and the locations of the Lisp and C
heaps. Then, there is a table showing the types and numbers of
objects. Finally, used and available malloc space is displayed.
</p>



<hr><h2 id="154"><a name="changing-while-running-2">3.5 Can other things be changed while running?</a></h2>

<p id="155">Yes. The function <a href="operators/system/resize-areas.htm"><b>resize-areas</b></a> can be used to rearrange things
while running. It is typically useful to call this function, for
example, after loading a large application. If you know desirable old-
and newspace sizes for your application, it is preferable to build an
image with those sizes (using the :oldspace and :newspace arguments to
<a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a>, see
<a href="building-images.htm">building-images.htm</a> for more information). However,
you may not know until runtime what the best sizes are, in which case
you can call <a href="operators/system/resize-areas.htm"><b>resize-areas</b></a>
on application startup. Be warned that it may take some time.</p>

<p id="156">Another use of <a href="operators/system/resize-areas.htm"><b>resize-areas</b></a> is when you wish to dump an
image (with <a href="operators/excl/dumplisp.htm"><b>dumplisp</b></a>) into
which your application has been loaded. You call <a href="operators/system/resize-areas.htm"><b>resize-areas</b></a> just before dumplisp in that
case.</p>



<hr><hr><h2 id="157"><a name="gc-initial-sizes-1">4.0 Initial sizes of old and new spaces</a></h2>

<p id="158">The initial sizes of newspace and oldspace are determined when the
image is built with <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a>. See
<a href="building-images.htm">building-images.htm</a> (where <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> is fully documented --
the page on it is brief to avoid two sources for the same complex
discussion) The :newspace argument to <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> controls the initial size of
newspace and the :oldspace argument the initial size of oldspace.</p>

<p id="159">An image dumped with <a href="operators/excl/dumplisp.htm"><b>dumplisp</b></a> inherits new and oldspace sizes from
the dumping image. See <a href="dumplisp.htm">dumplisp.htm</a>.</p>

<p id="160"><a href="operators/system/resize-areas.htm"><b>resize-areas</b></a> will
restructure old and newspace sizes in a running image.</p>

<p id="161">The garbage collector will automatically resize old and newspace
when it needs to. The amount of resizing depends on space required to
allocate or move to oldspace live objects, and also on the parameters
that relate to sizes.</p>



<hr><hr><h2 id="162"><a name="gc-params-and-switches-1">5.0 System parameters and switches</a></h2>


<p id="163">
The interface to the garbage collector changed in release 10.0.  Gc
parameter and switch settings are displayed by the function
<a href="operators/system/gc-parameters.htm"><b>sys:gc-parameters</b></a>.
(Older functions like <b>sys:gsgc-parameters</b> are obsolete).
All parameters and switches (some new, others old
but still in use) are described in the subsections of this section.
</p>
<p id="164">
The parameters and switches described under the next set of
headings control the action of the garbage collector. You may change
them during run time to optimize the performance of the Lisp
process. Many parameters and switches values may be set with
<b>setf</b>. However, some values should not be changed by you and
others cannot be. The descriptions of the parameters say whether you
should change their values. By default, the system does automatically
increase the generation number. You may find that it is useful to step
it yourself at appropriate times with a call to <a href="operators/system/gsgc-step-generation.htm"><b>gsgc-step-generation</b></a>.
</p>

<p id="165">
There is really no difference between a parameter and a switch
other than the value of switches is typically <code>t</code> or <code>nil</code> while parameters
often have numeric values. 
</p>

<p id="166">
The function <a href="operators/system/gc-parameters.htm"><b>gc-parameters</b></a> prints the values of all
parameters and switches. <a href="operators/system/gc-switch.htm"><b>gc-switch</b></a> and <a href="operators/system/gc-parameter.htm"><b>gc-parameter</b></a> retrieve the value of,
respectively, a single switch or a single parameter, and with
<a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a> can set the value (when
appropriate) as follows.
</p>

<pre id="167">
      (setf (sys:gc-parameter <i>parameter</i>) <em>value</em>) 
      (setf (sys:gc-switch <i>switch</i>) <i>value</i>)
</pre>


<p id="168">Switches and parameters are named by keywords. Here are the
switches and parameters as printed by <a href="operators/system/gc-parameters.htm"><b>sys:gc-parameters</b></a>: 
</p>
<pre id="169">
cg-user(23): (sys:gc-parameters)
gc-monitor [version 100] (multithreaded global gc)
:helper-threads-requested 4 (limit is 8)
:packets-in-use-limit 16,777,215    :minimum-recovery-bytes 8,192
:generation-spread 4     :current-generation 5    :tenure-limit 1

:free-bytes-new-other 131,072       :free-percent-new 25
:free-bytes-new-pages 131,072       :expansion-free-percent-new 35
                                    :expansion-free-percent-old 35
:quantum 32                         :open-old-area-fence 0

(switch :auto-step) t
(switch :hook-after-gc) t           (switch :clip-new) nil
(switch :gc-old-before-expand) nil  (switch :next-gc-is-global) nil
(switch :print) t                   (switch :stats) t
(switch :verbose) nil               (switch :dump-on-error) nil
cg-user(24): 
</pre>

<hr><h2 id="170"><a name="generation-and-tenuring-parameters-2">5.1 Parameters that control generations and tenuring</a></h2>

<p id="171">The first three parameters relate to the generation number and when
objects are tenured. Please note that of the three parameters, you
should only set the value of <code>:generation-spread</code>.
The fourth parameter, which is setf'able, allows closing off some old
areas, meaning that no objects will be tenured to them. Old areas are
now numbered, allowing for some to be closed off.
</p>

<table BORDER="1" cellpadding="3" width="90%"> <tr> <td WIDTH="25%" VALIGN="TOP"><code>:current-generation</code></td> <td WIDTH="75%" VALIGN="TOP">The value of this parameter is a 16 bit
  unsigned integer. New objects are created with this generation
  tag. Its initial value is 1, and it is incremented when the
  generation is stepped. The system may change this value after a
  scavenge. Users should not set this value. Note: Both the current
  generation number and the generation of an individual object are
  managed in a non-intuitive way. While it is conceptually correct
  that the generation number increases, the actual implementation
  works quite differently, often resetting the generation number
  toward 0.</td> </tr> <tr> <td WIDTH="25%" VALIGN="TOP"><code>:tenure-limit</code></td> <td WIDTH="75%" VALIGN="TOP">The value of this parameter is a 16 bit integer. During
  a scavenge, objects whose generation exceeds this value are not
  tenured and all the rest are tenured. Users should not set this
  value. Its initial value is 0, and it is constantly being reset
  appropriately by the system.</td> </tr> <tr> <td WIDTH="25%" VALIGN="TOP"><code>:generation-spread</code></td> <td WIDTH="75%" VALIGN="TOP">The value of this parameter is the number
  of distinct generations that will remain in newspace after garbage
  collection.  Note: objects that are marked for tenuring and objects
  that are to stay in newspace permanently do not belong to a specific
  generation. Setting the value of this parameter to 0 will cause all
  data to be tenured immediately. This is one of the most important
  parameters for users to set. Its initial value is 4 and its maximum
  effective value is 25. </td> </tr> <tr> <td WIDTH="25%" VALIGN="TOP"><code>:open-old-area-fence</code></td> <td WIDTH="75%" VALIGN="TOP">The value of this parameter is always a
  non-negative integer which is the number of the oldest old area that
  is open (not closed). Old areas are numbered with 0 as the oldest
  old area.  <p id="172">This parameter is setfable, either with the number of
  the old-area that is desired to be the first open-old-area, or with
  a negative number, for which the old-areas are counted backward to
  set the fence. For example, <code>(setf (sys:gc-parameter
  :open-old-area-fence) -1)</code> will close all old areas except
  for the newest one, no matter how many old areas
  exist. <b>Restrictions</b>: At least one old area will be open at
  any time.  Attempts to set the fence to a higher or lower number
  than can be set will result in silent saturation (setting the fence
  to the nearest possibility), however the return value from such a
  <b>setf</b> will always indicate the actual open-old-area-fence.
  Obviously from these restrictions, one must have at least two
  old-areas in order to close one.
</p> 
<p id="173">
See the <a href="#closed-old-are-note">note on closed old areas</a> just after
this table for more information.</p>
</td>
</tr>
</table>

<h3 id="174"><a name="closed-old-are-note">Further information on closed old
areas</a></h3>

<p id="175">
Old areas can be marked as closed. No objects are newly
tenured into a closed old-area; it is as if the area is full. Also,
no dead object in a closed old area is collected while the area is
closed, and data pointed to by that object is also not collected.
</p>
<p id="176">
See the description of the <code>:open-old-area-fence</code> in
the table just above for details on how to specify old areas as
closed.
</p>
<p id="177">
The intended usage model for closing old areas is this: a programmer
with an application, such as a VAR, will load up their application,
perform a global-gc and possibly a <a href="operators/system/resize-areas.htm"><b>resize-areas</b></a>, and then close most
of the old-areas, leaving room for their users' data models to be
loaded into the open-areas. When the user is done with the data
model, it can be thrown away and a fast global-gc performed, making
way for the next data model.
</p>




<hr><h2 id="178"><a name="minimum-size-parameters-2">5.2 Parameters that control minimum size</a></h2>

<p id="179">
The following parameters control the minimum size of newspace and when
the system will allocate a new newspace. At the end of a scavenge, at
least <code>:free-bytes-new-pages</code> plus
<code>:free-bytes-new-other</code> bytes must be free, and at
least <code>:free-percent-new</code> percent of newspace must be
free. If these conditions are not met, the system will allocate a new
newspace, large enough for these conditions to be true after
allocating the object that caused the scavenge, if there is
one. (Unless explicitly called by the user, a scavenge occurs when the
system is unable to allocate a new object.) Note that there is no
system reason why there are two parameters,
<code>:free-bytes-new-pages</code> and
<code>:free-bytes-new-other</code> -- differences were
anticipated in the original specification but none was never
implemented. The two parameter values are added to get total free
space required.
</p>

<table border="1" cellpadding="3" width="90%">
<tr>
<td WIDTH="25%" VALIGN="TOP"><code>:quantum</code></td>
<td WIDTH="75%" VALIGN="TOP">
The value of this parameter is a 32-bit integer which represents the
minimum amount of space (in 8 Kbyte pages) that will be requested for
a new new or old space and the granularity of space requested (that is
space will be requested in multiples of :quantum pages). Its initial
value is 32. This parameter value is overshadowed by the other
size-related parameters described immediately below, and for that
reason, we do not recommend that you change this value.
</td>
</tr>
<tr>
<td WIDTH="25%" VALIGN="TOP"><code>:free-bytes-new-other</code></td>
<td WIDTH="75%" VALIGN="TOP">
This is one of the parameters which determine the minimum free space
which must be available after a scavenge. Its initial value is
131072.
</td>
</tr>
<tr>
<td WIDTH="25%" VALIGN="TOP"><code>:free-bytes-new-pages</code></td>
<td WIDTH="75%" VALIGN="TOP">This is one of the parameters which determine the minimum
    free space which must be available after a scavenge. Its initial value is 131072.</td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:free-percent-new</code></td>
    <td WIDTH="75%" VALIGN="TOP">This parameter specifies the minimum fraction of newspace
    which must be available after a scavenge, or else new newspace will be allocated. Its
    initial value is 25.</td>
  </tr>
</table>



<hr><h2 id="180"><a name="newspace-size-parameters-2">5.3 Parameters that control how big newly allocated spaces are</a></h2>

<p id="181">The next two parameters control how large a new newspace (and a new
oldspace) will be. If newspace is expanded or a new oldspace is
allocated, then at least the percentage specified by the appropriate
parameter shall be free, after, in the case of newspace, the object
that caused the scavenge has been allocated, and after, in the case of
oldspace, all objects due for tenuring have been allocated. There are
different concerns for the newspace parameter and the oldspace
parameter.
</p>

<p id="182">
Let us consider the oldspace parameter first. In the case where no
foreign code is loaded, then oldspaces are carved out of newspace, and
newspace grows up into memory as needed. If each new oldspace is just
large enough, the next time an object is tenured, another oldspace,
again just large enough, will be created, and the result will be a
bunch of small oldspaces, rather than a few larger ones. This problem
will not occur if there is foreign code, since some oldspaces will be
as large as previous newspaces. If the function room shows a bunch of
little oldspaces, you might try increasing the
<code>:expansion-free-percent-old</code> parameter to cure the
problem. However, <a href="operators/system/resize-areas.htm"><b>resize-areas</b></a> can be used instead to coalesce
the oldspaces into one.
</p>

<p id="183">
The newspace parameter is more complicated, since newspace can grow
incrementally (assuming growth is not blocked by foreign code). Since
growing newspace takes time, you want to ensure that when newspace
grows, it grows enough. Therefore, it is essential that
<code>:expansion-free-percent-new</code> be larger than
<code>:free-percent-new</code>. Otherwise, you might find
newspace growing just enough to satisfy
<code>:free-percent-new</code>, and then having to grow again at
the next scavenge, since allocating a new object again reduced the
free space below the <code>:free-percent-new</code>
threshold. </p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="727">
<tr>
  <td WIDTH="270" VALIGN="TOP"><code>:expansion-free-percent-new</code></td>
  <td WIDTH="421" VALIGN="TOP">At least this percentage of newspace must 
  be free after allocating new newspace. The system will allocate sufficient 
  extra space to guarantee that this condition is met. Its initial 
  value is 35.</td>
</tr>
<tr>
  <td WIDTH="270" VALIGN="TOP"><code>:expansion-free-percent-old</code></td>
  <td WIDTH="421" VALIGN="TOP">At least this percentage of space must 
  be free in newly
    allocated oldspace (note: not the total oldspace). Its initial value is 35.</td>
  </tr>
</table>



<hr><h2 id="184"><a name="full-gllobal-param-2">5.4 :minimum-recovery-bytes parameter for less than full global gc</a></h2>

<p id="185">
A global garbage collection can take an appreciable amount of
time. The grbage collector can estimate how many bytes will be
recovered in oldspace. If that number is less than the value of the
<code>:minimum-recovery-bytes</code> parameter, then some phases
of the global gc (the adjustment and compaction phases) will be
skipped. This will leave garbage in oldspace that would otherwise be
cleared but can also save significant time. The initial value of the
<code>:minimum-recovery-bytes</code> parameter parameter is
8192. <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a> can be used
with <a href="operators/system/gc-parameter.htm"><b>sys:gc-parameter</b></a> to
change the value. Setting it to 0 means every global gc will be full.
</p>
<pre id="186">
cg-user(27): (sys:gc-parameter :minimum-recovery-bytes)
8192
cg-user(28): (setf (sys:gc-parameter :minimum-recovery-bytes) 0)
0  ;; All global gc's will be full
cg-user(29): (sys:gc-parameter :minimum-recovery-bytes)
0
cg-user(30): (setf (sys:gc-parameter :minimum-recovery-bytes) 16384)
16384 ;; global gc's will be less likely to be full
      ;; compared to default value
cg-user(31): (sys:gc-parameter :minimum-recovery-bytes)
16384
cg-user(32): 
</pre>


<hr><h2 id="187"><a name="smp-parameters-2">5.5 Parameters that use of multiple threads by the GC</a></h2>

<p id="188">
The <b><code>:helper-thread-requested</code></b> parameter
tells the system how many threads it should use, if possible, for
garbage collection. Broadly speaking the more the
faster, but in SMP Lisps, you may not want more threads than
processors and if some processors are dedicated to other tasks (like
running the video), you may want fewer requested than processors on
your machine. <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>
can be used with <a href="operators/system/gc-parameter.htm"><b>sys:gc-parameter</b></a> to set this parameter:
</p>

<pre id="189">
cg-user(35): (sys:gc-parameter :helper-threads-requested)
4
cg-user(36): (setf (sys:gc-parameter :helper-threads-requested) 6)
6
cg-user(37): (sys:gc-parameter :helper-threads-requested)
6
cg-user(38): 
</pre>

<p id="190">
The <b><code>:helper-thread-limit</code></b> parameter is not
<a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>'able. It is the
maximum number of helper threads that can be
used. <code>:helper-threads-requested</code> should be less than
or equal to this value. This value is reported in the
<a href="operators/system/gc-parameters.htm"><b>sys:gc-parameters</b></a> output as
part of the <code>:helper-threads-requested</code> output
(":helper-threads-requested 4 (limit is 8)"). Pass
<code>:helper-thread-limit</code> to <a href="operators/system/gc-parameter.htm"><b>sys:gc-parameter</b></a> to get the value
programmatically.
</p>
<p id="191">
The <b><code>:packets-in-use-limit</code></b> parameter is a
system value which should not be set except as part of debugging a
problem report.
</p>
<p id="192">
The <b><code>:packets-required</code></b> value is
not <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>'able and is
a reported value which may be useful for debugging purposes but can
otherwise be ignored.
</p>



<hr><h2 id="193"><a name="gsgc-switches-2">5.6 Gc switches</a></h2>

<p id="194">There are several switches which control the action of gsgc. The
value of a switch must be <code>t</code> or <code>nil</code>. The function <a href="operators/system/gc-switch.htm"><b>gc-switch</b></a> takes a switch name as an
argument and returns its value or with <b>setf</b>, sets its
value. <a href="operators/system/gc-parameters.htm"><b>gc-parameters</b></a>
also prints out their values. The switches can be set by evaluating
the form </p>

<pre id="195">
(setf (sys:gc-switch switch-name) nil-or-non-nil) 
</pre>

<table BORDER="1" cellpadding="3" width="90%">
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:gc-old-before-expand</code></td>
    <td WIDTH="75%" VALIGN="TOP">If this switch is set true, then before
    expanding oldspace, the system will do a global garbage collection (that is, it will
    gc oldspace) to see if the imminent expansion is necessary. If enough space is free after
    the garbage collection of oldspace the expansion will not occur. Initially <code>nil</code>.</td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:print</code></td>
    <td WIDTH="75%" VALIGN="TOP">If true, print a message when a gc occurs. Can be set by
    <a href="operators/excl/gc.htm"><b>excl:gc</b></a>. The
    length of the message is determined by the next two switches. If
    both are <code>nil</code>, a minimal message is
    printed. See just below the table for examples. Note that the
    messages are printed to the Console window on Windows and are not
    seen in the Integrated Development Environment Debug window.</td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:stats</code></td>
    <td WIDTH="75%" VALIGN="TOP">If true and <code>:print</code> is true, print statistics
    (such as how many bytes tenured) about the gc. See just below the table for examples.</td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:verbose</code></td>
    <td WIDTH="75%" VALIGN="TOP">If true, make the message printed (when :print is true) more
    English-like. <code>:clip-new</code> messages are only printed when this and <code>:print</code>
    are true. See just below the table for examples.</td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:auto-step</code></td>
    <td WIDTH="75%" VALIGN="TOP">This is the most important of the switches. If true,
    which is its initial value, <a href="operators/system/gsgc-step-generation.htm"><b>gsgc-step-generation</b></a> is effectively called after every
    scavenge. Thus (with the default :generation-spread) an object is tenured after surviving
    four scavenges.</td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:hook-after-gc</code></td>
    <td WIDTH="75%" VALIGN="TOP">If this switch is true, the function object
    bound to the variable <a href="variables/excl/s_gc-after-hook_s.htm"><code>*gc-after-hook*</code></a>
    will be funcalled after every scavenge or global gc.</td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:next-gc-is-global</code></td>
    <td WIDTH="75%" VALIGN="TOP"><p id="196">If this switch is set true, the next gc will
    be a global gc (that is both newspace and oldspace will be gc'ed). After the global gc,
    the system will reset this switch to <code>nil</code>. This will happen even if you cause
    the global gc by evaluating the form (excl:gc t). </p>
    <p id="197">The difference between setting this
    switch and causing a global gc explicitly with the function excl:gc is that setting this
    switch causes the system to wait until a scavenge is necessary before doing the global gc
    while calling the function causes the global gc to occur at once. The system uses this
    switch under certain circumstances.</p></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:clip-new</code></td>
    <td WIDTH="75%" VALIGN="TOP"><p id="198">The scavenger maintains a new logical pool of memory in
    newspace called `reserved'. When the <code>:clip-new</code> switch is true, memory will be
    transferred between `free' and `reserved' to try to maintain the freespace in use at the
    levels specified by the gc size parameters. If newspace grows to 5 meg because of a
    flurry of allocation, for example, a subsequent scavenge that finds only 200K of live data
    would put lots of space into the `reserved' bucket. The next scavenge would then happen
    much sooner. This is supposed to improve locality. Note that if there is sufficient RAM to
    hold the image, the performance improvement caused by improved locality of reference will
    most likely be offset by the need for more frequent scavenges.</p>
    <p id="199">If :print and :verbose
    are both true, information about the action triggered by this switch is printed. The
    information refers to `hiding' (moving space to the reserved bucket) and `revealing'
    (moving space to the free bucket).</p></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:use-remap</code></td>
    <td WIDTH="75%" VALIGN="TOP"><p id="200">If this switch is set true and the operating
    system on which Allegro CL is running supports it, then physical memory pages that are no
    longer used after a garbage collection are given back to the operating system in such a
    fashion that paging is improved.</p>
    <p id="201">Specifically, when this switch is true and the
    currently used half of newspace is copied to the unused half, the following things are
    done with the previously-used memory area: (1) the operating system is advised to ignore
    the page reference behavior of those addresses, and (2) the memory is unmapped and then is
    remapped, after being filled with zeros. The zero filling is necessary for security
    reasons, since the memory given back to the operating system will potentially be given to
    another process that requests virtual memory, without first being cleared. If it were not
    for (2), then remapping would always be advantageous and there would be no switch to
    control this behavior. As it is, there may be certain situations where zero filling will
    be too expensive, especially on machines which have a very large amount of physical memory
    and the decrease in locality does not effect the runtime performance of the Allegro CL
    application, or where the <strong>mmap()</strong> implementation is flawed.</p></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:dump-on-error</code></td>
    <td WIDTH="75%" VALIGN="TOP"><p id="202">If this switch is set true, then a core dump
    is automatically taken when an internal garbage collection error occurs. The core dump
    will fail, however, if (1) there is a system imposed limit on the size of a core dump and
    dumping the image would exceed this limit or (2) there is some other system impediment to
    dumping core, such as the existence of a directory named core. We assume that you can
    prevent the second limitation. Here are a few more words on the first limitation. In the C
    shell, the limit command and its associates can be used to set a higher limit or no limit
    for the maximum size of a core dump. </p>
    <p id="203">If the value of this switch is <code>nil</code>,
    you will be asked if you want a core dump when there is a gsgc error. Note that whatever
    the value, you have the opportunity to get a core dump. Set the switch to true when, for
    example, you intend to leave a program running all night in order to trigger a failure.</p></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><code>:mark-trace</code></td>
    <td WIDTH="75%" VALIGN="TOP">This switch should only be set if
    instructed as part of a problem report.</td>
  </tr>
</table>

<p id="204">These examples show the effect on gc messages of
<code>:stats</code> and <code>:verbose</code> being
true. When <code>:print</code> is true but both
<code>:stats</code> and <code>:verbose</code> are <code>nil</code>, a message like the following is printed during a
scavenge:</p>

<pre id="205">
gc: done
</pre>

<p id="206">When <code>:verbose</code> is also true but
<code>:stats</code> &nbsp;<code>nil</code>,
the message is:</p>

<pre id="207">
scavenging...done
</pre>

<p id="208">When <code>:stats</code> is true and
<code>:verbose</code> &nbsp;<code>nil</code>, the message is similar to:</p>



<pre id="209">
gc: E=34% N=30064 T+=872 A-=0 pfu=0+101 pfg=1+0
</pre>


<p id="210">The same message with <code>:verbose</code> true would be:</p>



<pre id="211">
scavenging...done eff: 9%, new copy: 148056 + tenure: 320 +  aclmalloc free: 0 = 148376
  Page faults: non-gc = 0 major + 1 minor
</pre>

<p id="212">
When <code>:verbose</code> is <code>nil</code>,
abbreviations are used. Their meanings are explained when
<code>:verbose</code> is true. <b>T</b> or <b>Tenure</b>
means bytes tenured to oldspace. <b>A</b> and <b>alcmalloc free</b>
refer to malloc space (see <a href="operators/excl/aclmalloc.htm"><b>aclmalloc</b></a>). 
</p>
<p id="213">
<b>E</b> or <b>eff.</b> is efficiency: the ratio of non-gc time and
all time (the efficiency is low in our example because we forced gc's
in order to produce the example; as we say elsewhere, efficiencies of
less than 75% are a cause for concern when the gc is triggered by the
system).
</p>
<p id="214">
The copy figures are the number of bytes copied within
newspace and to oldspace. 
</p>
<p id="215">
<b>X</b> means "expanding", so <b>XO</b> means "expanding oldspace"
and XN means "expanding newspace". XMN means "expanding and moving
newspace".
</p>
<p id="216">
Page faults are divided between user (pfu or
non-gc) caused and gc (pfg or gc) caused. See the Unix man page for
<strong>getrusage</strong> for a description of the difference between
major and minor page faults.
</p>
<p id="217">
Here are a couple of more examples (with <code>:verbose</code>
on and off in a fresh Lisp each time):
</p>
<pre id="218">
cl-user(1): (gc :print)
t
cl-user(2): (setf (sys:gc-switch :verbose ) t)
t
[...]
cl-user(7): (defconstant my-array (make-array 10000000))
scavenging...expanding new space...expanding and moving new space...done 
  eff: 36%, copy new: 7533984 + old: 85232 = 7619216
  Page faults: non-gc = 1 major + 0 minor
my-array

;; And in a fresh image with :verbose off:

cl-user(1): (gc :print)
t
cl-user(2): (defconstant my-array (make-array 10000000))

gc: XN-XMN-E=32% N=7522488 T+=85632 A-=0 pfu=4+0
my-array
</pre>



<hr><h2 id="219"><a name="gsgc-functions-variables-2">5.7 Gsgc functions and variables</a></h2>

<table BORDER="1" cellpadding="3" WIDTH="90%">
  <tr>
    <td WIDTH="27%" VALIGN="TOP"><b>Function or variable</b></td>
    <td WIDTH="27%" VALIGN="TOP"><b>Arguments of functions</b></td>
    <td WIDTH="45%" VALIGN="TOP"><b>Brief Description</b></td>
  </tr>
  <tr>
    <td WIDTH="27%" VALIGN="TOP"><a href="operators/system/gsgc-step-generation.htm"><b>gsgc-step-generation</b></a></td>
    <td WIDTH="27%" VALIGN="TOP"> </td>
    <td WIDTH="45%" VALIGN="TOP">Calling this function, which returns the new value of
    :current-generation, increases the current generation number and, if necessary, the value
    of <code>:tenure-limit</code> as well. </td>
  </tr>
  <tr>
    <td WIDTH="27%" VALIGN="TOP"><a href="operators/excl/gc.htm"><b>gc</b></a></td>
    <td WIDTH="27%" VALIGN="TOP">&optional <em>action</em></td>
    <td WIDTH="45%" VALIGN="TOP">Called with no arguments, perform a scavenge; called with
    argument <code>t</code>, perform a global gc. Other arguments cause setting of switches and the
    printing of information. Argument :help shows other arguments and their effects as does
    the <a href="operators/excl/gc.htm"><b>gc</b></a> page.</td>
  </tr>
  <tr>
    <td WIDTH="27%" VALIGN="TOP"><a href="operators/excl/print-type-counts.htm"><b>print-type-counts</b></a></td>
    <td WIDTH="27%" VALIGN="TOP">&optional<i> (location t)</i></td>
    <td WIDTH="45%" VALIGN="TOP">Prints a list of quantities and sizes of lisp objects in the
    specified location in the heap, along with type names and type codes of each object type
    printed. See the <a href="operators/excl/print-type-counts.htm"><b>print-type-counts</b></a>
    page for location details.</td>
  </tr>
  <tr>
    <td WIDTH="27%" VALIGN="TOP"><a href="operators/system/lispval-storage-type.htm"><b>lispval-storage-type</b></a></td> 
<td WIDTH="27%" VALIGN="TOP"><i>object</i></td> 
<td WIDTH="45%" VALIGN="TOP">Returns a keyword denoting where object is
    stored. See the <a href="operators/system/lispval-storage-type.htm"><b>lispval-storage-type</b></a> page for
    interpretation of the returned value and examples.  (In earlier
    releases, the function <a href="operators/system/pointer-storage-type.htm"><b>pointer-storage-type</b></a> performed
    this function. It is still supported, but its use is deprecated.
    <a href="operators/system/lispval-storage-type.htm"><b>lispval-storage-type</b></a>
    is more flexible and should be used instead.)
</td>
</tr>
  <tr>
    <td WIDTH="27%" VALIGN="TOP"><a href="operators/system/resize-areas.htm"><b>resize-areas</b></a></td>
    <td WIDTH="27%" VALIGN="TOP">&key<i> verbose old old-symbols new global-gc tenure
    expand sift-old-spaces pack-heap</i></td>
    <td WIDTH="45%" VALIGN="TOP">This function resizes old and newspaces, perhaps coalescing
    oldspaces, according to the arguments. See the <a href="operators/system/resize-areas.htm"><b>resize-areas</b></a> page for details.</td>
  </tr>
  <tr>
    <td WIDTH="27%" VALIGN="TOP"><a href="variables/excl/s_gc-after-hook_s.htm"><code>*gc-after-hook*</code></a></td>
    <td WIDTH="27%" VALIGN="TOP"> </td>
    <td WIDTH="45%" VALIGN="TOP">If the gsgc switch :hook-after-gc is true,
    then the value of this symbol, if true, will be funcalled immediately
    after a scavenge. See the description of <a href="variables/excl/s_gc-after-hook_s.htm"><code>*gc-after-hook*</code></a> for details. </td>
  </tr>
  <tr>
    <td WIDTH="27%" VALIGN="TOP"><a href="operators/excl/gc-after-c-hooks.htm"><b>gc-after-c-hooks</b></a></td>
    <td WIDTH="27%" VALIGN="TOP"></td>
    <td WIDTH="45%" VALIGN="TOP">Returns a list of addresses of C functions that will be
    called after a gc. See <a href="operators/excl/gc-after-c-hooks.htm"><b>gc-after-c-hooks</b></a>
    for details.</td>
  </tr>
  <tr>
    <td WIDTH="27%" VALIGN="TOP"><a href="operators/excl/gc-before-c-hooks.htm"><b>gc-before-c-hooks</b></a></td>
    <td WIDTH="27%" VALIGN="TOP"> </td>
    <td WIDTH="45%" VALIGN="TOP">Returns a list of addresses of C functions that will be
    called before a gc. See <a href="operators/excl/gc-before-c-hooks.htm"><b>gc-before-c-hooks</b></a>
    for details.</td>
  </tr>
</table>





<hr><hr><h2 id="220"><a name="global-gc-1">6.0 Global garbage collection</a></h2>

<p id="221">In a global garbage collection (global gc), objects in oldspace are
garbage collected.  Doing so frees up space in oldspace for newly
tenured objects. Global gc's are time consuming (they take much longer
than scavenges) and they are not necessary for Lisp to run. </p>

<p id="222">The effect of never doing a global gc is the Lisp process will
slowly grow larger. The rate of growth depends on what you are
doing. The costs of growth are that the paging overhead increases and,
if the process grows too much, swap space is exhausted, perhaps
causing Lisp to stop or fail. </p>

<p id="223">You have complete control over global gc's. The system will keep
track of how many bytes have been tenured since the last global
gc. You can choose one of these options for global gc: </p>

<ol>
  <li id="224">you can cause the system to print a message when a specified number of bytes have been
    tenured recommending that you cause a global gc; </li>
  <li id="225">you can cause the system to trigger a global gc automatically when that number of bytes
    have been tenured; </li>
  <li id="226">you can have the system trigger a global gc and print a message (the default behavior);
    or </li>
  <li id="227">you can have the system do nothing at all about global garbage collection. </li>
</ol>

<p id="228">The function that records how many bytes have been tenured since
the last global gc is the default value of the variable <a href="variables/excl/s_gc-after-hook_s.htm"><code>*gc-after-hook*</code></a>.  If you set
that variable (whose value must be a function or <code>nil</code>) to <code>nil</code> or a function
that does not keep records of bytes tenured, you will not get the
behavior described here. (See the description of <a href="variables/excl/s_gc-after-hook_s.htm"><code>*gc-after-hook*</code></a> for
information on defining a function that does what you want and records
bytes tenured correctly.)</p>

<p id="229">If <a href="variables/excl/s_gc-after-hook_s.htm"><code>*gc-after-hook*</code></a>
has as its value its initial value or a function that records bytes
tenured correctly, global gc behavior is controlled by the global
variable <a href="variables/excl/s_global-gc-behavior_s.htm"><code>*global-gc-behavior*</code></a>. </p>

<p id="230">The variable <a href="variables/excl/s_tenured-bytes-limit_s.htm"><code>*tenured-bytes-limit*</code></a> is used in conjunction
with <a href="variables/excl/s_global-gc-behavior_s.htm"><code>*global-gc-behavior*</code></a>.  The number of bytes
tenured (moved to oldspace) since the last global gc is remembered and
the <a href="variables/excl/s_global-gc-behavior_s.htm"><code>*global-gc-behavior*</code></a> depends on when <a href="variables/excl/s_tenured-bytes-limit_s.htm"><code>*tenured-bytes-limit*</code></a> is
exceeded.</p>

<hr><h2 id="231"><a name="tenuring-macro-2">6.1 The tenuring macro</a></h2>

<p id="232">
The <a href="operators/excl/tenuring.htm"><b>tenuring</b></a> macro causes
the immediate tenuring (moving to oldspace) of all objects allocated
while within the scope of its body. This is normally used when loading
files, or performing some other operation where the objects created by
forms will not become garbage in the short term. This macro is very
useful for preventing newspace expansion.
</p>



<hr><hr><h2 id="233"><a name="gc-cursors-1">7.0 Gc cursors</a></h2>

<p id="234">It is useful if possible to provide some sort of cue while garbage
collections are occurring. This allows users to know that a pause is
caused by a gc (and not by an infinite loop or some other
problem). Typical cues include changing the mouse cursor, printing a
message, or displaying something in a buffer as Emacs does when the
emacs-lisp interface is running. </p>

<p id="235">Unfortunately, providing such a cue for every scavenge is a
difficult problem and if it is done wrong, the consequences to Lisp
can be fatal. However, we have provided an interface for the
brave. The functions <a href="operators/excl/gc-before-c-hooks.htm"><b>gc-before-c-hooks</b></a> and <a href="operators/excl/gc-after-c-hooks.htm"><b>gc-after-c-hooks</b></a> return settable lists of
addresses of C functions to be called before and after a gc.</p>

<p id="236">Luckily, scavenges are usually fast and so failing to provide a cue
may not be noticeable. Global gc's, however can be slow but it is
possible to provide a cue for a global gc even without using C
functions. There are two strategies: (1) determine when a global gc is
necessary and either schedule it when convenient or warn the user that
one is imminent; (2) do not give advance warning but provide a cue
when it happens. Looking at these examples, you can probably craft
your own method of warning or cue.</p>

<p id="237">Note that in these examples, we replace the value of <a href="variables/excl/s_gc-after-hook_s.htm"><code>*gc-after-hook*</code></a> with a new
value, destroying the current value (which provides for the default
automated behavior). The default function is named by the (internal)
symbol <code>excl::default-gc-after-hook</code>.</p>

<p id="238">One way to implement the first strategy is to set a flag when a
global gc is needed and then have code that acts on that flag. This
code can be run at your choosing -- but be sure that it is run at some
point. You might do this:
</p>


<pre id="239">
(defvar *prevent-gc-recursion-problem* nil)
(defvar *my-gc-count* 0)
(defun my-gc-after-hook (global-p to-new to-old eff to-be-alloc)
  (declare (ignore eff to-new to-be-alloc))
  (when (atomic-conditional-setf
         *prevent-gc-recursion-problem*
         t
         nil)
    (if global-p
        (setq *my-gc-count* 0)
      (progn (setq *my-gc-count* (+ *my-gc-count* to-old))
        (when (&gt; *my-gc-count* excl:*tenured-bytes-limit*)
          ;; (&lt;change the cursor, print a warning, whatever&gt;)
          (gc t)
          ;; (&lt;reset the cursor if necessary, do whatever else&gt;)
          (setq *my-gc-count* 0))))
    (setq *prevent-gc-recursion-problem* nil)))
</pre>

<p id="240"><strong>Note</strong>: </p>

<ul>
  <li id="241">Because the after hook is called whenever a gc (including a global gc) occurs, one wants
    to be sure that the code doesn't get into some kind of recursive loop. <code>*prevent-gc-recursion-problem*</code>
    achieves that. </li>
  <li id="242">We use <a href="operators/excl/atomic-conditional-setq.htm"><b>atomic-conditional-setq</b></a> to ensure the value
  is <code>nil</code> when the function executes.</li>
  <li id="243">You replace these lines:</li>
</ul>

<pre id="244">
    ;; (&lt;change the cursor, print a warning, whatever&gt;) 
    ;; (&lt;reset the cursor if necessary, do whatever else&gt;)
</pre>

<blockquote>
  <p id="245">with whatever code you want, but be careful that there is no
  possibility of waiting (for user input, e.g.) or going into an
  infinite loop.</p>
</blockquote>




<hr><hr><h2 id="246"><a name="other-gc-info-1">8.0 Other gc information </a></h2>

<p id="247">The following list contains information and advice concerning
gsgc. Some of the information has already been provided above, but is
given again here for emphasis. </p>

<ol>
<li id="248">

While a garbage collection is happening, the handling of asynchronous
signals (such as results from entering the Unix interrupt character or
from certain mouse actions in a window system) is blocked. The signals
are queued (with duplicated signals thrown out) until the garbage
collection has completed.

</li>
<li id="249">

Do not set the <code>:auto-step</code> switch to <code>nil</code> unless some other method of stepping the
generation is enabled (including specific action by you). If objects
are not tenured, newspace will grow, filling up with long-lived
objects, and performance will degrade significantly.

</li>
<li id="250">

There is no way for you directly to cause a specific new object to be
tenured immediately except by calling <a href="operators/excl/gc.htm"><b>gc</b></a> with the argument
<code>:tenure</code> (which will cause <i>all</i> live objects
to be tenured) or with the <a href="operators/excl/tenuring.htm"><b>tenuring</b></a> macro.  There is no way to
prevent a specific object from ever being tenured except by disabling
generation stepping and thus preventing all objects from being
tenured.

</li>

<li id="251">

Users should not set the value of the current generation or the tenure
limit. The behavior of these values is algorithm-dependent in a
non-intuitive way. Control is exercised with generation stepping and
setting <code>:generation-spread</code>.

</li>
</ol>

<hr><hr><h2 id="252"><a name="gc-errors-1">9.0 gc errors</a></h2>

<p id="253">It is not easy to cause a gsgc error. Such errors are usually
catastrophic (often Lisp dies either without warning or with a brief
message that some unrecognizable object was discovered). Once the
garbage collector becomes confused, it cannot be straightened
out. </p>

<p id="254">
Such errors can be caused when Lisp code is compiled with the compiler
optimizations set so that normal argument and type checking is
disabled. For example, if a function is compiled with the values of
speed and safety such that the compiler:verify-argument-count-switch
is <code>nil</code>, and that function is passed the wrong
number of arguments (usually too few), it can trigger a fatal gsgc
error. Before you report a gsgc error as a bug (and please do report
them), please recompile any code where checking was disabled with
settings of speed and safety which allow checking. See if the error
repeats itself. See <a href="compiling.htm#decl-opts-1">Declarations and optimizations</a> in
<a href="compiling.htm">compiling.htm</a> for more information on compiler
optimization switches and values of speed and safety.
</p>

<p id="255">
Garbage collector errors may also be caused by foreign code signal
handlers. Note that foreign code signal handlers should not call
<strong>lisp_call_address</strong> or <strong>lisp_value</strong>.
See <a href="foreign-functions.htm">foreign-functions.htm</a> for more information on
signals.
</p>

<p id="256">
See the information on the <code>:dump-on-error</code>
gsgc-switch in 
<a href="#gsgc-switches-2">Section 5.6 Gc switches</a>.
</p>

<hr><h2 id="257"><a name="storage-condition-2">9.1 Storage-condition errors</a></h2>

<p id="258">
The Allegro CL image will grow as necessary while running. If it needs
to grow and it cannot, a storage-condition type error is signaled
(storage-condition is a standard Common Lisp condition type). While
these errors might arise from insufficient swap space, the typical
cause is a conflict in the virtual address space. That is, something
else (a program or a library location) has grabbed virtual address
space in a range that Lisp needs to grow the heap. (Allegro CL does
not allow discontinuous virtual address ranges.)
</p>
<p id="259">
Whatever the cause, the error is triggered by a request for space
which cannot be fulfilled. Here we show the error when a largish array
is created (this example is contrived in order to show the error: a
request for such an array does not typically cause a problem).
</p>

<pre id="260">
CL-USER(25): (setq my-array (make-array 100000))
Error: An allocation request for 483032 bytes caused a need for 12320768 more
bytes of heap.
The operating system will not make the space available.
  [condition type: STORAGE-CONDITION]
[1] CL-USER(26):
</pre>

<p id="261">
A global gc may free up enough space within Lisp to continue
without growing. Killing processes other than Lisp may free enough
space for Lisp to grow. But it may be the case that other allocations
of virtual address space conflicts with Lisp usage. Please contact
Franz customer support for assistance in determining whether this is
the case if the problem persists.
</p>
<p id="262">
You trigger a global gc by evaluating (see <a href="operators/excl/gc.htm"><b>gc</b></a>):</p>

<pre id="263">
(gc t)
</pre>



<hr><h2 id="264"><a name="gsgc-failure-2">9.2 Gsgc failure including System Error</a></h2>

<p id="265">
When the garbage collector gets confused, usually by following what it
believes to be a valid pointer, but one that does not point to an
actual Lisp object, Lisp fails with a two part message.  The first
part is a brief description of the specific problem. The second part
is a general statement about the gc failures and the fact they cannot
be recovered from, along with an opportunity of get a core file (which
may be useful for later analysis). Here are some examples of the
second part:
</p>

<pre id="266">
  The gc's internal control tables may have been corrupted and Lisp
  execution cannot continue.  

[or]

  The internal data structures in the running Lisp image have been
  corrupted and execution cannot continue.  

[then]

  Check all foreign functions
  and any Lisp code that was compiled with high speed and/or low safety,
  as these are two common sources of this failure.  If you cannot find
  anything incorrect in your code you should contact technical support
  for Allegro Common Lisp, and we will try to help determine whether
  this is a coding error or an internal bug.
  Would you like to dump core for debugging before exiting(y or n)? 
</pre>

<p id="267">
Here are some examples of the first part:
</p>
<pre id="268">
system error (gsgc): Unknown object type at (0xc50ec9a)

system error (gsgc): 
    Object already pointing to target newspace half: 0x42c43400

system error (gsgc): Scavenger invoked itself recursively.
</pre>

<p id="269">
As the text says in the second part, there is no recovery. 
</p>

<p id="270">
The causes of such errors can be one or more of the following:
</p>
<ul>
<li id="271">
a bad pointer introduced from foreign
code 
</li>
<li id="272">
foreign code inappropriately altering Lisp data
</li>
<li id="273">
an inappropriate call back from foreign code into Lisp
</li>
<li id="274">
incorrectly declared code when declarations are trusted
</li>
<li id="275">
a gc bug
</li>
</ul>

<p id="276">
Diagnosing and fixing the problem can be difficult. Here are some
initial steps to take where possible:
</p>
<ul>
<li id="277">
Determine if the problem is reliably repeatable (do you get a failure
every time or most times).
</li>
<li id="278">
Recompile with compiler settings speed 1 and safety and debug 3 (see
<a href="compiling.htm#decl-opts-1">Declarations and
optimizations</a> in <a href="compiling.htm">compiling.htm</a>). This
will suppress optimizations and most type declarations. If a variable
has been improperly typed (so, when declarations are believed, Lisp
thinks it is an object of one type when it is in fact another type),
the failure should go away. If it does, the problem reduces to finding
the false declaration.
</li>
<li id="279">
Turn on gc printing, so you have a record of gc's up to the
failure. (Evaluate <code>(gc :print)</code>, see <a href="operators/excl/gc.htm"><b>gc</b></a>.)
</li>
<li id="280">
Look at foreign code called by Lisp: are there call backs into Lisp,
are Lisp values or pointers passed to the foreign code, or does the
foreign code modify Lisp data. All these things are supported, but if
done wrong, can cause problems.
</li>
<li id="281">
Make sure that you have all the available patches (see <a href="operators/system/update-allegro.htm"><b>sys:update-allegro</b></a>). There may be
patches for gc bugs, and one may fix your problem.
</li>
</ul>

<p id="282">
If you cannot quickly determine the cause of the problem and a
solution for it, contact Franz Inc. technical support at <a href="mailto:support@franz.com">support@franz.com</a>. Be sure to
include the output of a call to <a href="operators/excl/print-system-state.htm"><b>print-system-state</b></a>, and provide any information
about foreign code, optimizations, etc. that you can. We may ask you
for a core file (which, as said above, can be optionally generated
when there is a failure).
</p>



<hr><hr><h2 id="283"><a name="weak-vecs-etc-1">10.0 Weak vectors, finalizations, static arrays, etc.</a></h2>

<p id="284">
A Lisp object becomes garbage when nothing points to or references
it. The way the garbage collector works is it finds and identifies
live objects (and, typically, moves them somewhere). Whatever is left
is garbage. Finalizations and weak vectors allow pointers to objects
which will not, however, keep them alive. If one of these pointers
exists, the garbage collector will see the item and (depending on the
circumstances), either keep it alive (by moving it) or abandon
it.
</p>

<p id="285">It is useful to distinguish two actions of the garbage
collector. When the only pointers to an object are weak pointers or
finalizations, the garbage collector follows those pointers and
`identifies the object as garbage'. If it decides not to keep the
object alive, it `scavenges the object away'. Note that any Lisp
object can be scavenged away - that just means that the memory it used
is freed and (eventually) overwritten with new objects. Only objects
pointed to by a weak vector or a finalization can be identified as
garbage, however. Live objects are not garbage and objects with
nothing pointing to them are not even seen by the garbage
collector.
</p>
<p id="286">
The function <a href="operators/system/lispval-storage-type.htm"><b>lispval-storage-type</b></a> applied to an object
returns a keyword providing information about the storage type of the
object. Weak vectors and finalizations are identified by this function
which can be used to test whether an object is a weak vector.
</p>

<hr><h2 id="287"><a name="weak-arrays-2">10.1 Weak arrays and hashtables</a></h2>

<p id="288">
Weak arrays are created with the standard Common Lisp function <a href="../ansicl/dictentr/make-arr.htm"><b>make-array</b></a> (using the non-standard
<em>weak</em> keyword argument) or (if a vector is desired) with the
function <a href="operators/excl/weak-vector.htm"><b>weak-vector</b></a>. When
you create a weak array by specifying a true value for the
<i>weak</i> keyword argument to <a href="../ansicl/dictentr/make-arr.htm"><b>make-array</b></a>, you cannot also:
</p>
<ul>
<li id="289">
Create a specialized array (<code>:element-type</code> should be
<code>t</code> or unspecified).
</li>
<li id="290">
Specify a value for the <code>:displaced-to</code> keyword
argument (weak arrays cannot be displaced into other arrays).
</li>
<li id="291">
Specify an <code>:allocation</code> other than
<code>:new</code> (the non-standard
<i>allocation</i> keyword argument allows specifying
where the arrays will be created, with choices including foreign
space, non-gc'ed Lisp space, or the Lisp heap, called for by
<code>:new</code>, which is also the default).
</li>
</ul>
<p id="292">
When <a href="../ansicl/dictentr/make-arr.htm"><b>make-array</b></a>
successfully accepts a true value for the <i>weak</i>
keyword argument, the object that is weak is always the underlying
simple-vector; if the resultant array is non-simple or is
multidimensional, then the array itself is not marked as weak, but
objects in the array will still be dropped by the gc when not
otherwise referenced, because the simple-array that is the data
portion of the array is itself weak. 
</p>
<p id="293">
See the discussion of extensions to <a href="implementation.htm#cl-make-array-2">make-array</a> (in
<a href="implementation.htm">implementation.htm</a>) for further details on the
Allegro CL implementation of <a href="../ansicl/dictentr/make-arr.htm"><b>make-array</b></a> and the <i>weak</i>
keyword argument.
</p>
<p id="294">
As we said in the brief description above, the most important feature
about weak arrays is that being pointed to by a weak array does not
prevent an object from being identified as garbage and scavenged
away. When an object is scavenged away, the entry in a weak array that
points to the object will be replaced with <code>nil</code>.
</p>
<p id="295">
Weak arrays allow you to keep track of objects and to discover when
they have become garbage and disposed of. An application of weak
arrays might be determining when some resource external to Lisp can be
flushed. Suppose that all references to a file external to Lisp are
made through a specific pathname. It may be that once all live
references to that pathname are gone (i.e. the pathname has become
garbage) the file itself is no longer needed and it can be removed
from the filesystem. If you have a weak array which points to the
pathname, when the reference is replaced by <code>nil</code> by the garbage collector, you can tell the system
to kill the file.
</p>
<p id="296">
It is important to remember that objects which have been tenured
will not be identified as garbage unless a global gc is performed. If
you use weak arrays, you should either arrange that global gc's are
done regularly or that you do an explicit global gc before checking
the status of an element of the weak array.
</p>

<p id="297">
We provide a simple example of weak vectors (weak arrays differ
from weak vectors only in having more dimensions) and finalizations in
<a href="#weak-array-finalization-example-2">Section 10.3 Example of weak vectors and finalizations</a>.
</p>

<p id="298">
Weak hashtables are also supported. See
<a href="implementation.htm">implementation.htm</a> for information on an extension
to <a href="../ansicl/dictentr/make-has.htm"><b>make-hash-table</b></a> that
creates weak hashtables.
</p>
<p id="299">
The function <a href="operators/system/lispval-storage-type.htm"><b>lispval-storage-type</b></a> applied to an object
returns a keyword providing information about the storage type of the
object. Weak vectors and finalizations are identified by this function
which can be used to test whether an object is a weak vector.
</p>



<hr><h2 id="300"><a name="finalizations-2">10.2 Finalizations</a></h2>



<p id="301">
A finalization associates an object with a function and optionally
with a <a href="classes/mp/queue.htm"><code>queue</code></a>. If the object
is identified as garbage by the garbage collector, either the function
is called with the object as its single argument before the object is
scavenged away (if there is no associated queue) or a list consisting
of the function and the object is placed on the queue. In the latter
case, no further action is taken by the system. The program must apply
the function <a href="operators/excl/call-finalizer.htm"><b>call-finalizer</b></a> at its convenience.
</p>
<p id="302">
Multiple finalizations can be scheduled for the same object; all are
run or placed on queues if and when the gc identifies the object as
garbage. The order of the running of multiple finalizations is
unspecified.
</p>


<p id="303">
The timing is important here. While the garbage collector is running,
nothing else can be done in Lisp. In particular, functions (except
those internal to the garbage collector itself) cannot be
called. Therefore, the process of running a finalization and the
eventual reclamation of the finalized object occurs over two
 invocations of the garbage collector. During
the first gc, the object is identified as garbage. The garbage
collector sees the finalization and so, instead of immediately
scavenging the object away, it keeps it alive and makes a
note to call the
finalization function or enqueue the list of the function and the
object as soon as it finishes the current scavenge (or global
gc). The finalization is removed from the object after the
function is run so that during a
subsequent garbage collection, the object is either garbage or,
if a weak vector points to it, again identified as garbage and (since
it no longer has a finalization) scavenged away. See the example in
<a href="#weak-array-finalization-example-2">Section 10.3 Example of weak vectors and finalizations</a>.
</p>

<p id="304">
A finalization is not a type of Lisp object. Finalizations are
implemented as vectors (but that may change in a later release). You
should not write any code which depends on the fact that finalizations
are implemented as vectors. 
</p>

<p id="305">You schedule a finalization with the function <a href="operators/excl/schedule-finalization.htm"><b>schedule-finalization</b></a>. The function <a href="operators/excl/unschedule-finalization.htm"><b>unschedule-finalization</b></a> removes the
finalization from the object. 
Finalizations are only run once, either immediately after the
garbage collection which identified the object as garbage or by the
program. The object is not scavenged away during the garbage
collection in which it is identified as garbage (since it must be
around to be the argument to the finalization function).
</p>

<hr><h2 id="306"><a name="finalization-weak-objects-3">10.2.1 A finalized object may still be pointed to by a weak vector or hash-table</a></h2>

<p id="307">
A reference from a weak vector or hash-table is not a reference from
the point of view of the garbage collector. Consequently, a weak
vector or hash-table can contain a pointer to an object on which a
finalization is being called, or has already been called. If it is
important for an application to know when an object has been
finalized, the application code must mark the object in some way.
</p>
<p id="308">
Without extra care on the part of the programmer, finalization
functions can run on any thread. In an SMP environment, this can
introduce contention for objects found via weak vectors or
hash-tables. Programmers should allow for this, using atomic update
operations as appropriate. See <a href="smp.htm">smp.htm</a> for
information on atomic operations.
</p>





<hr><h2 id="309"><a name="weak-array-finalization-example-2">10.3 Example of weak vectors and finalizations</a></h2>

<p id="310">
On Windows, load the file after the transcript example. Typing the
example into the Debug window in the Integrated Development
Environment on Windows does not work as described, because tools in
the IDE cause pointers to the objects to be preserved, and, as a
result, the example does not work as described. On Unix, you can type
the example directly to a prompt.
</p>

<pre id="311">
;; This example can be typed to a prompt on a UNIX platform.
;; We define a weak vector and a function to be called by finalizations.
CL-USER(10): (setq wv (weak-vector 1))
#(nil)
CL-USER(11): (defun foo (x) (format t "I am garbage!~%"))
foo
;; We create an object and put it in the weak vector:
CL-USER(12): (setq a (cons 1 2))
(1 . 2)
CL-USER(13): (setf (aref wv 0) a)
(1 . 2)
;; We schedule a finalization.
CL-USER(14): (schedule-finalization a 'foo)
#((1 . 2) foo nil)
;; We remove the reference to the cons by setting the value of A to NIL.
CL-USER(15): (setq a nil)
nil
;; We evaluate unrelated things to ensure that the object
;; is not the value of *, **, or ***.
CL-USER(16): 1
1
CL-USER(17): 2
2
CL-USER(18): 3
3
;; We trigger a scavenge. The finalization function is called.
;; Note: an automatic gc might occur while you are entering the
;; forms shown. If it does, you might see the message printed by
;; our finalization sooner.
CL-USER(19): (gc)
I am garbage!
 
;; At this point, the weak vector still points to the object:
CL-USER(20): wv
#((1 . 2))
;; The next gc causes the value in the weak vector to
;; be changed.
CL-USER(21): (gc)
CL-USER(22): wv
#(nil)
</pre>

<p id="312">
On Windows, put this in a file finalization.cl:
</p>

<pre id="313">
(in-package :cg-user)

(setq wv (weak-vector 1))

(defun foo (x) (format t "I am garbage!~%"))

(setq a (cons 1 2))

(setf (aref wv 0) a)
(schedule-finalization a 'foo)

(setq a nil)
</pre>

<p id="314">
and do this in the Debug Window (the transcript shows the <b>I am
garbage!</b> message occurring after <code>wv</code> is
evaluated at <b>cl-user(11)</b> but if a gc was triggered by the
loading of <i>finalization.cl</i>, you may see instead
the <b>I am garbage!</b> message sooner):
</p>

<pre id="315">
cl-user(10): :ld finalization.cl
Loading finalization.cl
cl-user(11): wv
#((1 . 2))
cl-user(12): (gc)
I am garbage!

cl-user(13): 1
1
cl-user(14): 2
2
cl-user(15): 3
3
cl-user(16): (gc)
cl-user(17): wv
#(nil)
</pre>



<hr><h2 id="316"><a name="static-arrays-2">10.4 Static arrays</a></h2>

<p id="317">The data in a static array is placed in an area that is <i>not</i>
garbage collected.  This means that the data is never moved and,
therefore, pointers to it can be safely stored in foreign
code. (Generally, Lisp objects are moved about by the garbage
collector so a pointer passed to foreign code is only guaranteed to be
valid during the call. See <a href="foreign-functions.htm">foreign-functions.htm</a>
for more information on this point.) Only certain element types are
permitted (listed below). General arrays (whose elements can be any
Lisp object) cannot be created as static arrays. </p>

<p id="318">The primary purpose of static arrays is for use with foreign
code. They may also be useful with pure Lisp code but only if the
array is needed for the whole Lisp run and the array never has to be
significantly changed. The problem is the array is not garbage
collected and there is no way (within Lisp) to free up the space. </p>

<p id="319">Static arrays are returned by <a href="../ansicl/dictentr/make-arr.htm"><b>make-array</b></a> with the (Allegro CL-specific)
<em>allocation</em> keyword argument specified. The data is stored in
an area which is not garbage collected but the header (if any) is
stored in standard Lisp space.  The following element types are
supported in static arrays.</p>

<pre id="320">
    bit
    (signed-byte 8)
    (unsigned-byte 4)
    (unsigned-byte 8)
    (signed-byte 16)
    (unsigned-byte 16)
    (signed-byte 32)
    (unsigned-byte 32)
    character
    single-float
    double-float
    (complex single-float)
    (complex double-float)
</pre>

<p id="321">
See <a href="implementation.htm">implementation.htm</a> for information on this
extension to <a href="implementation.htm#cl-make-array-2">make-array</a>. See <a href="operators/excl/lispval-other-to-address.htm"><b>lispval-other-to-address</b></a> for information on
freeing static arrays.
</p>





</body><hr><p id="2"><small>Copyright (c) 1998-2016, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page has had significant revisions compared to the 9.0 page.</small><br><small>Created 2016.6.21.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.0</b><br><small><a href="introduction.htm#updates-s">Significantly revised from 9.0.</a></small><br><a href="http://www.franz.com/support/documentation/9.0/doc/gc.htm">9.0 version</a></td></tr></table></html>