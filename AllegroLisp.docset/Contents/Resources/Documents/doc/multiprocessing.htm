<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"> <title>Multiprocessing</title></head><link rel="stylesheet" href="acldoc-styles.css" type="text/css"><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.0</b><br><small><a href="introduction.htm#updates-s">Unrevised from 9.0 to 10.0.</a></small><br><a href="http://www.franz.com/support/documentation/9.0/doc/multiprocessing.htm">9.0 version</a></td></tr></table><h1 id="2">Multiprocessing</h1><p id="3">This document contains the following sections:</p><a href="#mp-intro-1">1.0 Multiprocessing introduction</a><br>&nbsp;&nbsp;&nbsp;<a href="#data-types-2">1.1 Data types added to standard Common Lisp</a><br>&nbsp;&nbsp;&nbsp;<a href="#max-number-2">1.2 The maximum number of simultaneous processes</a><br><a href="#threads-model-functions-and-variables-1">2.0 Variables and functions</a><br>&nbsp;&nbsp;&nbsp;<a href="#threads-and-processes-ost-2">2.1 Threads and processes</a><br>&nbsp;&nbsp;&nbsp;<a href="#ost-and-ff-2">2.2 Native threads and foreign functions</a><br>&nbsp;&nbsp;&nbsp;<a href="#general-waiting-2">2.3 When all wait functions depend on external events</a><br>&nbsp;&nbsp;&nbsp;<a href="#waiting-for-input-ost-2">2.4 Waiting for input from a stream</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#process-wait-vs-wait-for-input-available-ost-3">2.4.1 mp:process-wait vs mp:wait-for-input-available</a><br><a href="#process-functions-and-variables-1">3.0 Process functions and variables</a><br><a href="#dynamic-environments-1">4.0 Processes and their dynamic environments</a><br>&nbsp;&nbsp;&nbsp;<a href="#listeners-and-specials-2">4.1 Lisp listeners and special variable bindings</a><br><a href="#gates-1">5.0 Gates</a><br>&nbsp;&nbsp;&nbsp;<a href="#semaphores-2">5.1 Semaphores</a><br><a href="#queues-1">6.0 Queues</a><br>&nbsp;&nbsp;&nbsp;<a href="#sized-queues-2">6.1 Sized queues</a><br><a href="#process-locks-1">7.0 Process locks</a><br><a href="#minimum-sleep-1">8.0 cl:sleep and minimum sleeping time</a><br><a href="#mp-example-1">9.0 A simple example of multiprocessing</a><br><a href="#wide-binding-1">Appendix A. Wide binding</a><br>&nbsp;&nbsp;&nbsp;<a href="#bindstack-index-2">Appendix A.1. The bindstack index</a><br><a href="#profiling-1">Appendix B. Processes and the runtime analyzer</a><br><hr><hr><h2 id="4"><a name="mp-intro-1">1.0 Multiprocessing introduction</a></h2>

<p id="5">
Allegro CL has extensions to support multiprocessing within a single
executing Lisp image. This can use a single processor (non-SMP)
or, on some platforms, use multiple
processors. See <a href="smp.htm">smp.htm</a> for information on SMP
processing. Note that non-SMP versions of Lisp are available on all
supported platforms.
</p>

<p id="6">
Note that the SMP version works on a machine that has only one
processor and using the SMP version may be more efficient on such
machines even though (obviously) only one process can run at a time.
</p>


<p id="7">
All processes share the same Lisp address space, sometimes called
the <i>Lisp world</i>. Each process has its own execution stack
(i.e. "call" stack) and dynamic variable bindings.  All
processes share everything else in the Lisp world, including packages,
streams, global function bindings, and global values of special
variables. (The global value of a special variable is its outermost
value, outside any dynamic binding.) The Allegro CL compiler,
interpreter, top level, and other subsystems all lambda bind their
necessary special variables, and Allegro CL code itself is
reentrant. Therefore, multiple processes can correctly maintain any
number of correct and independent ongoing computations simultaneously
within the single Lisp world.
</p>

<p id="8">
There are two implementations of multiprocessing in Allegro CL, the
<b>native threads</b> model and the <b>virtual threads</b>
model. <strong>:os-threads</strong> appears on the <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> list of the
implementation using the native threads model and does not appear on
the <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> list of
the implementation using the virtual threads model. In earlier
releases, the programming interface of the two models had significant
differences. These differences are almost all gone in release 7.0.
</p>

<p id="9">
In the <strong>native threads</strong> model, each process within Lisp
is implemented by an operating system thread and management tasks such
as scheduling are done by the operating system.  In the
<strong>virtual threads</strong> model, all processes are implemented
internally by Lisp.
</p>

<p id="10">
Although there are many subtle differences between these two
implementations, in actual practice it is very rare for actual
application code to have any dependency on these differences.  Most
code developed on one will run without modification on the other.
This has been verified during the porting of several preexisting
multiprocess-intensive subsystems.
</p>
<p id="11">
Most symbol names for multiprocessing are in the
<code>multiprocessing</code> package, nicknamed
<code>mp</code>.  Programmers must preface symbols with the
package prefix mp: or execute
</p>

<pre id="12">
(use-package :multiprocessing) 
</pre>

<p id="13">
before the first reference to any multiprocessing function. Depending
how Lisp is installed the multiprocessing module may not be loaded
into the initial Lisp system. To guarantee it is available, execute
the form
</p>

<pre id="14">
(require :process) 
</pre>

<p id="15">
before calling any multiprocessing functions, or place this
top-level form
</p>

<pre id="16">
(eval-when (:compile-top-level :load-top-level :execute) (require :process))
</pre>

<p id="17">
near the start of any  source file which uses multiprocessing.
</p>

<hr><h2 id="18"><a name="data-types-2">1.1 Data types added to standard Common Lisp</a></h2>

<p id="19">Multiprocessing adds these user-visible data types to
standard Common Lisp: </p>

<ol>
<li id="20">
A <em>process</em> corresponds to the usual operating system notion of
a thread. In the :os-threads implementation each process is associated
with a single Operating System thread.  In the non :os-threads
implementation each process is associated with a virtual thread.
</li>
<li id="21">
A <em>process-lock</em> provides a mechanism for process
synchronization. A process-lock is either free or seized by some
process. Any process trying to seize a seized lock will block until
the lock is free. See <a href="#process-locks-1">Section 7.0 Process locks</a>.
</li>
</ol>



<hr><h2 id="22"><a name="max-number-2">1.2 The maximum number of simultaneous processes</a></h2>

<p id="23">
The maximum number of simultaneous processes is the lesser of 2000 and
whatever the Operating System will make available. That is really a
limit on the number of simultaneous threads: running processes are
associated with threads. The garbage collector frees dead threads, so
there can be many more than that number of threads used while an
application runs, just no more than that number used used at one time.
</p>
<p id="24">
If a process tries to run when the limit of running processes/threads
is reached, an error will be signaled.
</p>





<hr><hr><h2 id="25"><a name="threads-model-functions-and-variables-1">2.0 Variables and functions</a></h2>



<p id="26">
The descriptions below provide only a brief introduction. Please
follow the links to the individual description pages for details.
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Name</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Notes</b></td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/symeval-in-process.htm"><b>symeval-in-process</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>symbol thread</i></td>
    <td WIDTH="33%" VALIGN="TOP"><p id="27">This
    function returns two values. The first is the value of the special symbol in the given
    thread (which may be the current thread). It only looks for actual bindings on the thread;
    if the symbol has a global value but is not bound on the thread, the global value is not
    returned. </p>
    <p id="28">The second returned value describes the status of the binding. t is returned
    if the symbol is bound on the thread, nil if the symbol has no binding, and :unbound if
    there is a binding which has been subjected to makunbound. In the latter two cases, the
    first returned value is nil. </p></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/system/global-symbol-value.htm"><b>sys:global-symbol-value</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>symbol</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns two values. The first is the global
    value for the special variable named by symbol, ignoring any bindings on the current
    thread and the second is t if the variable has a value (in the sense of <a href="../ansicl/dictentr/boundp.htm"><b>boundp</b></a>).
    Otherwise the first value will be nil and the second will be the symbol :unbound.</td>
  </tr>
<tr>
<td WIDTH="33%" VALIGN="TOP">
<a href="operators/mp/profile-process-p.htm"><b>profile-process-p</b></a>
</td>
<td WIDTH="33%" VALIGN="TOP">
<i>process</i>
</td>
<td WIDTH="33%" VALIGN="TOP">This function returns the value of the
profile-process-p flag for the thread specified by process. If the
value of the flag is non-<code>nil</code>, then the space
and time runtime analyzers will collect samples when this process is
executing.
</td>
</tr>
</table>


<hr><h2 id="29"><a name="threads-and-processes-ost-2">2.1 Threads and processes</a></h2>

<p id="30">
The process object implements the abstraction of independent processes
running within the same Lisp world. Process objects are CLOS
instances, allowing the application to define subclasses for whatever
purpose.  Processes are implemented on top of threads; each active
process is associated with a particular thread. Thread objects are
simple static structures that contain the information used to
schedule. Active process threads are managed by the Operating System
in native thread and SMP implementations and within Lisp
in non-SMP virtual thread
implementations. <a href="variables/system/s_current-thread_s.htm"><code>sys:*current-thread*</code></a> is bound in each thread
to the thread object representing this (native or virtual) thread.
</p>
<p id="31">
A process object is implemented as a CLOS class. Some of its slots
are meaningful to user code, but except for those explicitly noted
they should be treated as read only.
</p>

<p id="32">
Whether and when a process runs is controlled by several
mechanisms. First the process' initial function and arguments must be
specified, and then the process must be 'reset'.  (The <a href="operators/mp/process-preset.htm"><b>process-preset</b></a> function
combines these operations.)
</p>
<p id="33">
Second, a process maintains two lists: its
<i>run-reasons</i> and its <i>arrest-reasons</i>. These lists can
contain Lisp objects of any type (whether or not each list is empty is
the only relevant issue). For a process to be considered for execution,
it must have at least one object on its run-reasons list
and no objects on its arrest-reasons list. 
</p>
<p id="34">
Finally, a process that needs to wait for some arbitrary condition
does so using the <a href="operators/mp/process-wait.htm"><b>process-wait</b></a> function. This
function specifies a function and arguments. When the OS considers a
waiting process for running, it causes the wait-function to be applied
to the wait-arguments (in the process environment). If a non-null
value is returned the process runs and the call to <a href="operators/mp/process-wait.htm"><b>process-wait</b></a> returns. <a href="operators/mp/process-wait.htm"><b>process-wait</b></a> is most
efficient when the wait function is one of <a href="operators/mp/gate-open-p.htm"><b>gate-open-p</b></a>, <a href="operators/excl/read-no-hang-p.htm"><b>read-no-hang-p</b></a>, <a href="operators/excl/write-no-hang-p.htm"><b>write-no-hang-p</b></a>, or <a href="operators/excl/stream-listen.htm"><b>stream-listen</b></a>, but any appropriate function
can be used.
</p>

<p id="35">
It is useful to define some terms for process states. A process is
<i>active</i> if it has been preset, has not completed, has at least
one run reason, and has no arrest reasons; otherwise, it is
<i>inactive</i>. Active processes are further divided into two
classes. An active process is <i>waiting</i> if it has executed a
<a href="operators/mp/process-wait.htm"><b>process-wait</b></a>
that has not yet completed.  An active process is <i>runnable</i> if
it is not waiting. 
In addition, the process actually running at any time is called
the <i>current</i> process, or current processes in SMP.
</p>

<p id="36">
On Windows, even though a process may be waiting, it still typically
watches for operating system messages that require a response (because
Windows expects threads to do this). However, there are some rare
circumstances where this message handling should be suppressed. The
macro <a href="operators/mp/with-message-interrupts-disabled.htm"><b>mp:with-message-interrupts-disabled</b></a> will do
this.
</p>

<p id="37">
Processes run until complete or interrupted. When a process is run,
it is given an amount of processor time; when that time expires the
operating system interrupts the process and looks about for other
processes which can be run.
</p>

<ul>
  <li id="38">Each unblocked process is examined and its priority is noted.</li>
  <li id="39">The highest priority processes are considered (there may be several with the same high
    priority, or there may just be one).</li>
  <li id="40">The process itself ensures that it can run, examining its arrest reasons (cannot run if
    there are any) and its run reasons (cannot run unless there is one).</li>
  <li id="41">If the process has a wait function, it runs it. If the wait function returns nil, the
    process cannot run.</li>
  <li id="42">If the process cannot be run , it checks to see if there are priority messages that must
    be processed, and if so processes them. (On some operating systems, every thread must
    respond to a priority message; all other threads will block until all priority messages
    are handled. This check is to ensure that the system does not block because of such
    messages.)</li>
  <li id="43">Once a process is determined to be runnable, it looks at its pending interrupts. (These
    are Lisp interrupts queued via <a href="operators/mp/process-interrupt.htm"><b>process-interrupt</b></a>,
    not Operating System interrupts.) All lisp interrupts are processed.</li>
  <li id="44">After all Lisp interrupts are processed, normal process computation continues until
    another interrupt is received from the Operating System.</li>
</ul>

<p id="45">
A process has two parameters to control scheduling. Its
<i>priority</i> is an integer indicating its scheduling priority,
higher numbers request more frequent processing. Its <i>quantum</i>
indicates the minimum time (in the range 0.1 to 20.0 seconds
inclusive) the process should be allowed to run before a clock tick
might suspend it, assuming it does not give up execution
voluntarily. This is to prevent thrashing between processes,
particularly those that might have deep stacks. 
</p>


<p id="46">
The generic function <a href="operators/mp/process-join.htm"><b>process-join</b></a> connects processes and
suspends one while another completes.
</p>

<p id="47">
See <a href="smp.htm">smp.htm</a> for more information on SMP processes.
</p>




<hr><h2 id="48"><a name="ost-and-ff-2">2.2 Native threads and foreign functions</a></h2>

<p id="49">
In the virtual thread (non <strong>:os-threads</strong>) model,
foreign code is not interruptible and Lisp code cannot run until the
foreign code returns control to Lisp, either by completing or by
calling back to Lisp. In the native threads
(<strong>:os-threads</strong>) model, Lisp code on one process may run
while foreign code runs in another process. This means that certain
properties of foreign code may no longer hold. Among them these are
the most significant:
</p>

<ul>
<li id="50">
Lisp pointers passed to foreign code are not guaranteed to be valid
by default. In earlier releases, because Lisp code never ran while
foreign code was running, a Lisp pointer passed to foreign code was
guaranteed to be valid until the foreign code completed or called back
to Lisp. In the <strong>:os-threads</strong> model, because Lisp code
and foreign code can run in different OS processes, Lisp code may be
run concurrently with foreign code. A garbage collection may move Lisp
objects, rendering invalid pointers held by the foreign code. Each
foreign function's definition specifies whether a lisp process calling
that function retains exclusive control of the heap or releases the
heap so that other lisp processes can run. Releasing the heap can
improve overall application concurrency, especially if long-running or
blocking foreign functions are involved, but it also introduces the
danger that a lisp string passed as an argument may become invalid
before the called code is through with it. Foreign function
definitions by default perform non-releasing calls. A special keyword
argument must be used in the <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a> if a
heap-releasing linkage is desired. We recommend storing all values
used by both Lisp and foreign code in foreign (not garbage-collected)
space or dynamically allocated on the stack, whenever those values may
be used in heap-releasing calls. See <a href="foreign-functions.htm#releasing-the-heap-2">Releasing the
heap when calling foreign functions</a> in
<a href="foreign-functions.htm">foreign-functions.htm</a> for more information.
</li>
<li id="51">
It is possible for a
foreign function called from Lisp to explicitly start computation in
additional threads, as supported by the OS (by having foreign code
make the appropriate system calls to start the threads). One could
imagine any of these new threads using the foreign function interface
to invoke a Lisp function defined as foreign-callable (see <a href="operators/ff/defun-foreign-callable.htm"><b>defun-foreign-callable</b></a>). In an
Allegro CL with the non <strong>:os-threads</strong> model of
multiprocessing, doing this is almost certain to have disastrous
consequences.  It is wholly unsupported but there is no protection in
the foreign function interface to prevent it from happening.  The only
legitimate calls to a foreign-callable function will occur in the
Lisp's own thread of control, as call-backs from foreign code that was
itself called from lisp.
<p id="52">
In an <strong>:os-threads</strong> Allegro CL, however, it is
legitimate for a thread started outside Lisp to call into Lisp via any
foreign-callable function.  Some extra work has to be done to create a
Lisp process to represent that thread within the lisp world. That
extra work is performed by a "customs agent" process that is started
automatically (no specific programming is required).
</p>
</li>
<li id="53">
If foreign code spawns any new threads, or if it allows another thread
to run, and the other thread attempts to call back into lisp, it will
have to wait for the lisp heap. The danger is that the original thread
may be waiting for results from its partner thread, but it has not yet
given up the heap (this constitutes a deadlock situation). If this
situation holds (foreign code does spawn new thread which call back
into Lisp), <code>:when-ok</code> is the appropriate value for
the <i>release-heap</i> argument to <a href="operators/ff/def-foreign-call.htm"><b>def-foreign-call</b></a>. The default value for
<i>release-heap</i> is <code>:never</code>, so in
this situation, the value <code>:when-ok</code> must be
explicitly specified.
</li>
</ul>



<hr><h2 id="54"><a name="general-waiting-2">2.3 When all wait functions depend on external events</a></h2>

<p id="55">
In an SMP Lisp, all live processes are checked from time to time to
see if their wait function indicates they should be run. But in a
non-SMP Lisp, only changes in the Lisp trigger checking wait
functions. External changes (such as a file becoming available, will
not in itself cause a Lisp where all processes are waiting to become
active. If there is a possibility that all Lisp processes could be
waiting for external events in a non-SMP Lisp, you can ensure regular
running of wait functions be creating what is called a <i>heartbeat</i>
process:
</p>

<pre id="56">
(mp:process-run-function "heartbeat" #'(lambda () (loop (sleep 1))))
</pre>

<p id="57">
This process wakes up every second and this wake up is seen as a Lisp
event, which triggers running wait functions, thus ensuring that
external events are noticed.
</p>
<p id="58">
There is no harm in setting up a heartbeat procss in an SMP Lisp, but
doing so should not be necessary to avoid the apparent hung state that
is possible, as said above, in a non-SMP Lisp. If you find that a
heartbeat process seems necessary (that is, an SMP Lisp seems to get
into a hung state without a heartbeat process but not with one), please
report the circumstances to support@franz.com as it may indicate a
larger problem.
</p>



<hr><h2 id="59"><a name="waiting-for-input-ost-2">2.4 Waiting for input from a stream</a></h2>

<p id="60">This section deals with the situation where no process can run
until input arrives from outside of Lisp, typically via a stream. The
issue is how to have Lisp not waste machine cycles waiting for the
arrival of input, yet have Lisp wake up in a timely manner when the
input becomes available.</p>

<p id="61">Each waiting process has an associated wait function.  Whenever the
process' thread is given processor time, it executes the wait function
and if the result is still false, it immediately releases the
processor back to the OS.  If the OS were to cycle repeatedly through
all the waiting processes, the processor will be perpetually busy even
though no useful work is being done. This might be reasonable on a
dedicated machine -- the wasted processor cycles would not be valuable
as there would be nothing else for the processor to do. But this would
be bad computing citizenship on a host with other processes unrelated
to Lisp, since it would consume processor cycles and paging bandwidth
that might be in short supply. So Lisp tries to conserve machine
resources by keeping waiting process threads completely quiescent when
nothing is runnable, and allowing the OS to give threads processor
time to check their wait functions only when something may have
changed that could affect the result of one or more wait
functions. However, Lisp needs a little help to do this.
</p>

<p id="62">
There are only three things that can cause a wait function to return
true after previously having returned <code>nil</code>:
(1) some other running Lisp process has changed some piece of state in
the Lisp world that the wait function tests; (2) an asynchronous
signal arrives; or (3) input becomes available on a file descriptor
(generally associated with a Lisp stream) that the wait-function
tests.
</p>

<p id="63">Case (1) requires that wait functions be tested periodically
whenever (or at least immediately after) any Lisp process actually
runs.  The operating system thread management does this automatically.
But what should happen when absolutely no processes are runnable? We
want Lisp to stop running completely until either (2) or (3)
happens.</p>

<p id="64">When a process finds that its wait function is not yet satisfied,
it releases the CPU by performing the equivalent of a Unix select() on
the set of "interesting" file descriptors. This causes the
process to block. The OS will not give the associated thread any CPU
time until a signal arrives (2) or input becomes available on one of
the interesting file descriptors (3). The process can run its
wait-function again to determine whether it has actually become
unblocked.</p>

<p id="65">Unfortunately, the process machinery has no way to correlate wait
functions with OS file descriptors, such that input becoming available
on the file descriptor would (or might) cause the wait-function to
return true. The system needs to be told explicitly that a file
descriptor is interesting to some wait-function. The low-level input
handlers (e.g., for read-char) for Allegro CL streams do this
automatically, but any user implementing custom streams and/or making
a low-level foreign-function interface to (for example) the underlying
operating-system socket interface will need to write input functions
in such a way that they inform the process machinery about input file
descriptors. The description of <a href="operators/mp/wait-for-input-available.htm"><b>wait-for-input-available</b></a>
describes how this is done.</p>

<hr><h2 id="66"><a name="process-wait-vs-wait-for-input-available-ost-3">2.4.1 mp:process-wait vs mp:wait-for-input-available</a></h2>

<p id="67">The purpose of <a href="operators/mp/wait-for-input-available.htm"><b>wait-for-input-available</b></a> is to
wait on one or more input streams. <a href="operators/mp/wait-for-input-available.htm"><b>wait-for-input-available</b></a> takes a
wait function just like <a href="operators/mp/process-wait.htm"><b>process-wait</b></a>, but before
suspending the calling process it carefully records the input file
descriptors for each stream or file descriptor argument. While the
calling process is blocked inside the call to <a href="operators/mp/wait-for-input-available.htm"><b>wait-for-input-available</b></a>, these
file descriptors will be passed to select() so that available input
will immediately return from select() and awaken this thread.</p>

<p id="68">If <a href="operators/mp/process-wait.htm"><b>process-wait</b></a> is used instead of
<a href="operators/mp/wait-for-input-available.htm"><b>wait-for-input-available</b></a>, the
thread may fail to notice when input becomes available and not run the
wait function until some other possibly-unrelated interrupt or input
causes the entire Lisp image to wake up and eventually run through all
wait functions again.</p>





<hr><hr><h2 id="69"><a name="process-functions-and-variables-1">3.0 Process functions and variables</a></h2>

<p id="70">The descriptions below provide only a brief introduction. Please
follow the links to the individual description pages for details.</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Name</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Notes</b></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="variables/system/s_all-processes_s.htm"><code>*all-processes*</code></a></td>
    <td WIDTH="33%" VALIGN="TOP">[variable]</td>
    <td WIDTH="33%" VALIGN="TOP">The value of this variable is a list of all processes that
    have ever been created and have never completed or been killed.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="variables/system/s_current-process_s.htm"><code>*current-process*</code></a></td>
    <td WIDTH="33%" VALIGN="TOP">[variable]</td>
    <td WIDTH="33%" VALIGN="TOP">The value of this variable is the process currently running (<strong>:os-threads</strong>)
    or which the scheduler is currently running (non <strong>:os-threads</strong>). In non <strong>:os-threads</strong>
    implementations, nil is returned if the scheduler itself is running.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="variables/mp/s_default-process-quantum_s.htm"><code>*default-process-quantum*</code></a></td> <td WIDTH="33%" VALIGN="TOP">[variable]</td> <td WIDTH="33%" VALIGN="TOP">Default quantum given to each process.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="variables/system/s_disallow-scheduling_s.htm"><code>*disallow-scheduling*</code></a></td>
    <td WIDTH="33%" VALIGN="TOP">[variable]</td>
    <td WIDTH="33%" VALIGN="TOP"><p id="71">This special variable is bound to t whenever multiprocessing
    scheduling is disabled. For example, the system binds this variable to t during the
    execution of the forms within a <a href="operators/system/without-scheduling.htm"><b>without-scheduling</b></a>
    form.</p>
    <p id="72">This variable should be treated as read-only and should never be set or bound by
    user code.</p></td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/make-process.htm"><b>make-process</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><code>&key<em> name reset-action run-reasons
    arrest-reasons priority quantum resume-hook suspend-hook initial-bindings
    message-interrupt-function stack-allocation run-immediately</em></code></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns a new process object, but does nothing
    about making it runnable. Follow the link to the full description for details.</td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-add-arrest-reason.htm"><b>process-add-arrest-reason</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process object</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function adds object to the list of arrest-reasons for
    process.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-add-run-reason.htm"><b>process-add-run-reason</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process object</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function adds object to the list of run-reasons for
    process.</td>
  </tr>

<tr>
<td WIDTH="33%" VALIGN="TOP">
<a href="operators/mp/process-allow-schedule.htm"><b>process-allow-schedule</b></a>
</td>
<td WIDTH="33%" VALIGN="TOP"><i>&optional other-process</i></td>
<td WIDTH="33%" VALIGN="TOP">
This function allows processes other than the executing (and hence
calling) process to run. All other processes of equal or higher
priority will have a chance to run before the executing (and thus
calling) process is next run. The optional argument is ignored, but if
supplied it should be another process.
</td>
</tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-arrest-reasons.htm"><b>process-arrest-reasons</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns the list of arrest-reasons for <i>process</i>.
    </td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-disable.htm"><b>process-disable</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function makes process inactive by revoking all its run
    and arrest reasons. The effect is immediate if a process disables itself.</td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-enable.htm"><b>process-enable</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">Makes process active by removing all its run and arrest
    reasons, then giving it a single run reason of :enable.</td>
  </tr>



  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-initial-bindings.htm"><b>process-initial-bindings</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This slot of a process stores an <i>alist</i> of initial
    special bindings which are established in a process when it is started. The value may be
    set with <b>setf</b>. </td>
  </tr>
<tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-initial-form.htm"><b>process-initial-form</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns a cons of the initial function of
    process and its argument list.</td>
  </tr>


  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-interrupt.htm"><b>process-interrupt</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process function &rest args</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function forces process to apply function to args when
    it next executes. When function returns, the original computation of process continues. If
    process is waiting when interrupted, it runs the interrupt function and then continues
    waiting. If process is not active, <a href="operators/mp/process-interrupt.htm"><b>process-interrupt</b></a>
    makes it active for the interrupt function, then makes it inactive again.</td>
  </tr>


  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-join.htm"><b>process-join</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i> &key (<i>errorp</i> t) <i>error-values</i> 
(<i>search-list</i> '(:current :previous :next))</td>
    <td WIDTH="33%" VALIGN="TOP">Suspend the current process until <a href="operators/mp/process-thread.htm"><b>mp:process-thread</b></a>
of <b><i>process</i></b> exits, and then return the list
of result values of the preset function
of <i>process</i>. See function description for behavior when
process does not exit normally and other details.</td>
  </tr>

<tr>
<td WIDTH="33%" VALIGN="TOP">
<a href="operators/mp/process-kill.htm"><b>process-kill</b></a>
</td>
<td WIDTH="33%" VALIGN="TOP">
<i>process</i>
</td>
<td WIDTH="33%" VALIGN="TOP">
This function resets the process to unwind it, then removes it from
consideration by the scheduler and from the <a href="variables/system/s_all-processes_s.htm"><code>*all-processes*</code></a> list.
</td>
</tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-name.htm"><b>process-name</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns the name of process, which must be a
    string. This value may be changed with setf.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-name-to-process.htm"><b>process-name-to-process</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>name &key :abbrev :error</i></td>
<td WIDTH="33%" VALIGN="TOP">This function returns the process whose
process-name is <i>name</i>. <i>name</i>
must be a string. If the <i>abbrev</i> keyword argument
is specified non-<code>nil</code>, then name is matched to
the beginning of each process-name to find a match.</td>
</tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-preset.htm"><b>process-preset</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process function &rest arguments </i></td>
    <td WIDTH="33%" VALIGN="TOP">This function sets the initial function and arguments of
    process, then resets any computation in progress in it. This does not make process active
    if it was not already active.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-priority.htm"><b>process-priority</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns the priority of <i>process</i>. It
    defaults to 0 and may be set to any fixnum with <b>setf</b>.</td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-property-list.htm"><b>process-property-list</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">The <i>property-list</i> slot of a process implements a
    generalized property list as a convenient place to store additional information about a
    process.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-quantum.htm"><b>process-quantum</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns the quantum for <em>process</em>. 
    The quantum may be specified when the process is created; it defaults to the value
    of  <a href="variables/mp/s_default-process-quantum_s.htm"><code>*default-process-quantum*</code></a>
    and may be set to any real value between 0.1 and 20 with <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>.</td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-reset.htm"><b>process-reset</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process &optional no-unwind kill</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function causes <i>process</i> when 
    it next runs to throw out
    of its present computation, if any, then apply its initial 
    function to its initial
    argument.</td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-resume-hook.htm"><b>process-resume-hook</b></a></td>
    <td WIDTH="33%" VALIGN="TOP" ROWSPAN="2"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP" ROWSPAN="2">It is normal for execution of a process to be
    interrupted many times. This is transparent to the process and usually it is not necessary
    for the process to know when its execution is suspended and resumed. However, if these
    slots are non-nil, they should be functions of no arguments which are called on the
    process' stack-group or thread each time the execution is suspended or resumed (but not
    when the process is first started or when it is killed).</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-suspend-hook.htm"><b>process-suspend-hook</b></a></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-revoke-arrest-reason.htm"><b>process-revoke-arrest-reason</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process object</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function removes object from the list of arrest reasons
    for process.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-revoke-run-reason.htm"><b>process-revoke-run-reason</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process object</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function removes object from the list of run reasons for
    <i>process</i>.</td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-run-function.htm"><b>process-run-function</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>name-or-keywords function &rest args</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function does a <a href="operators/mp/make-process.htm"><b>make-process</b></a>, then presets the new
    process with function and args. The first argument is either a string, which is the name
    of the process, or is a list of keyword arguments accepted by <a href="operators/mp/make-process.htm"><b>make-process</b></a>. The new process is
    returned. By default, the process is killed when and if it completes.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-run-reasons.htm"><b>process-run-reasons</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns the list of run-reasons for <i>process</i>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-run-restartable-function.htm"><b>process-run-restartable-function</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>name-or-keywords function &rest args</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function is just like <a href="operators/mp/process-run-function.htm"><b>process-run-function</b></a> (just
    above), but automatically provides a :reset-action argument of t. The process thus started
    will restart if it is reset or completes.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-runnable-p.htm"><b>process-runnable-p</b></a></td>
    <td WIDTH="33%" VALIGN="TOP" ROWSPAN="2"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP" ROWSPAN="2">These functions return t if, respectively, <i>process</i>
    is runnable or active. A process is active if it has been reset and not yet completed, and
    has at least one run reason and no arrest reasons. It is runnable if it is active and not
    waiting.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-active-p.htm"><b>process-active-p</b></a></td>
  </tr>
<tr>
<td WIDTH="33%" VALIGN="TOP">
<a href="operators/mp/process-sleep.htm"><b>process-sleep</b></a>
</td>
<td WIDTH="33%" VALIGN="TOP">
<i>seconds &optional whostate</i>
</td>
<td WIDTH="33%" VALIGN="TOP">
process-sleep suspends the current process for at least the number of
seconds specified. That number may be any non-negative, non-complex
number. While the process sleeps, other processes are allowed to
run. The whostate (default "Sleep") is a string which
temporarily replaces the process' whostate during the
sleep.
<p id="73">
When multiprocessing is initialized, Common Lisp
function sleep is changed to be equivalent to process-sleep. Instead
of causing the entire Lisp world to suspend execution for the
indicated time, only the executing process is suspended. This is
usually the desired action.
</p>
</td>
</tr>

<tr>
<td WIDTH="33%" VALIGN="TOP">
<a href="operators/mp/process-thread.htm"><b>process-thread</b></a>
</td>
<td WIDTH="33%" VALIGN="TOP">
<i>process</i>
</td>
<td WIDTH="33%" VALIGN="TOP">
Returns the thread associated with <i>process</i>.
</td>
</tr>
<tr>
<td WIDTH="33%" VALIGN="TOP">
<a href="operators/mp/process-wait.htm"><b>process-wait</b></a>
</td>
<td WIDTH="33%" VALIGN="TOP">
<i>whostate function &rest arguments</i>
</td>
<td WIDTH="33%" VALIGN="TOP">
This function suspends the current process (the value of <a href="variables/system/s_current-process_s.htm"><code>*current-process*</code></a>) until
applying function to arguments yields true. The whostate argument must
be a string which temporarily replaces the process' whostate for the
duration of the wait. This function returns nil.
<p id="74">
See the discussion under the headings
<a href="#waiting-for-input-ost-2">Section 2.4 Waiting for input from a stream</a> and
<a href="#process-wait-vs-wait-for-input-available-ost-3">Section 2.4.1 mp:process-wait vs mp:wait-for-input-available</a>.
</p>
</td>
</tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-wait-args.htm"><b>process-wait-args</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns the list of arguments passed to the
    wait-function of <i>process</i>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-wait-function.htm"><b>process-wait-function</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns the function used to determine when a
    waiting process becomes runnable.</td>
  </tr>

<tr>
<td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-wait-with-timeout.htm"><b>process-wait-with-timeout</b></a></td>
<td WIDTH="33%" VALIGN="TOP"><i>whostate seconds function &rest args</i></td>
<td WIDTH="33%" VALIGN="TOP">This function is similar to <a href="operators/mp/process-wait.htm"><b>process-wait</b></a>, but with a timeout. The
units of time are seconds. The value of seconds may be any real number. Negative values
are treated the same as 0. The wait will timeout if function does not return true before
the timeout period expires.</td>
</tr>


  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-whostate.htm"><b>process-whostate</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>process</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns the current who-line string of process.</td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/start-scheduler.htm"><b>start-scheduler</b></a></td>
    <td WIDTH="33%" VALIGN="TOP">nil</td>
    <td WIDTH="33%" VALIGN="TOP"><p id="75"><strong>:os-threads</strong>: initializes multiprocessing
    (the function is misnamed since there is no scheduler but used for consistency with the
    non <strong>:os-threads</strong> implementation.)</p>
    <p id="76">Non <strong>:os-threads</strong>:
    start the scheduler process and initialize multiprocessing.</p></td>
  </tr>

  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>&body body</i></td>
    <td WIDTH="33%" VALIGN="TOP">This macro executes <em>body</em> protecting against any
    handling of asynchronous interrupts. Execution of body is guaranteed to complete without
    any other process running, or any asynchronous interrupt being dispatched, unless the
    process does something to block or otherwise explicitly yield to the scheduler (e.g., with <a href="operators/mp/process-allow-schedule.htm"><b>process-allow-schedule</b></a>). It is
    an error to call a heap-releasing foreign function within the scope of <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/system/without-scheduling.htm"><b>without-scheduling</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>&body body</i></td>
    <td WIDTH="33%" VALIGN="TOP">This macro inhibits the OS (in <strong>:os-threads</strong>)
    or the scheduler (non <strong>:os-threads</strong>) from suspending a process
    involuntarily (asynchronously) during the execution of body. This always works in non <strong>:os-threads</strong>
    versions since the scheduler is a Lisp process. However, in <strong>:os-threads</strong>
    versions, the OS will run another process if the current process blocks, waits, or
    executes a <a href="operators/mp/process-allow-schedule.htm"><b>process-allow-schedule</b></a>.
    </td>
  </tr>




<tr>
<td><a href="operators/mp/wait-for-input-available.htm"><b>wait-for-input-available</b></a></td>
<td WIDTH="33%" VALIGN="TOP"><i>streams &key :wait-function :whostate :timeout</i></td>
<td WIDTH="33%" VALIGN="TOP">This lower-level function extends the capabilities of <a href="operators/mp/process-wait.htm"><b>process-wait</b></a> and <a href="operators/mp/process-wait-with-timeout.htm"><b>process-wait-with-timeout</b></a>
to allow a process to wait for input from multiple streams and to wait for input from a
file.</td>
</tr>
<tr>
<td WIDTH="33%" VALIGN="TOP">
<a href="operators/system/with-timeout.htm"><b>sys:with-timeout</b></a></td>
<td WIDTH="33%" VALIGN="TOP">
<i>(seconds . timeout-forms) &body body</i>
</td>
<td WIDTH="33%" VALIGN="TOP">
This macro evaluates the body as a progn body. If the evaluation of
body does not complete within the specified interval, execution throws
out of the body and the timeout-forms are evaluated as a progn body,
returning the result of the last form. The timeout-forms are not
evaluated if the body completes within <i>seconds</i>.
</td>
</tr>


</table>

<hr><hr><h2 id="77"><a name="dynamic-environments-1">4.0 Processes and their dynamic environments</a></h2>

<p id="78">The multiprocessing system described in this chapter is a
nonstandard but upward-compatible extension to Common Lisp. Although
multiprocessing can be used within a single application towards
performing a single, integrated task, it is an important design
feature that multiprocessing allows multiple unrelated tasks to reside
in the same Lisp image. A user might run a window system, several
independent Lisp listeners, a Lisp editor, and an expert system
application (with network connections to processes in other hosts) all
in the same Lisp world. </p>

<p id="79">For independent tasks to coexist in a single world, the names of
functions and special variables in separate systems cannot interfere
with one another. This is the problem the package system is intended
to solve, and with a little care it is quite possible to keep names
separate. However, there are a number of public common-lisp package
special variables which are implicitly used by all Lisp
applications. Each process may want its own values assigned to these
special variables. This section discusses how conflicting demands on
these variables can be supported. </p>

<p id="80">For example, according to the Common Lisp standard, the default
value of the special variable *print-base* is 10. A stand-alone
application may assume that if it never changes *print-base* its value
will be 10. Or, if a stand-alone application always wanted to print in
octal, it might set *print-base* to 8. The effect on its own
calculation is well defined by the Common Lisp standard, but changing
the global value of *print-base* may have an unfortunate effect on
other unrelated applications running in the same Lisp world.  If one
application changes *print-base* what about others that assume it will
always have the default value, or want to exercise independent
control? </p>

<p id="81">A solution to this problem is to make a process that uses public
variables maintain its own bindings for those variables. When a
process is first started, a stack-group or thread is created on which
it will run. Whenever the process' computation binds special
variables, those bindings are recorded on its stack-group or
thread. <i>Binding</i> hides the value of special variables with
(possibly) different values. Inside the scope of a binding, code will
only see the bound value, not the original value, of a variable.
Special variable bindings are local to the process that creates them
and are never seen by other processes. </p>

<p id="82">Note that there is only one global "binding" for a
variable. While it always exists and is shared by all processes, if
the variable has been bound in the process to another value, code
inside that binding in that process will only see the bound value, not
the global value. This is important to understand when there are
multiple processes.  Sometimes it is useful for processes to
communicate through the value in a global binding.  Other times
processes must be protected from seeing the value other processes have
bound a variable to. </p>

<p id="83">Assume you have several processes and none of them binds the
special variable *print-base*. If one process sets the variable, the
global binding is the one affected and all of the processes will see
the new value. However, any process that binds the variable as a
special will not see changes to the global binding while its own
binding is in effect, and conversely, any <a href="../ansicl/dictentr/setq.htm"><b>setq</b></a> it does will not affect the value seen by
the others. </p>


<p id="84">The multiprocessing system provides a mechanism to allow processes
to bind special variables at process startup time. These bindings are
done in the process when it starts up so any reference to a global
variable as a value will see the <a href="operators/system/global-symbol-value.htm"><b>sys:global-symbol-value</b></a> of that symbol.
</p>
<p id="85">
First of all, the bindings specified by <a href="variables/excl/s_required-thread-bindings_s.htm"><code>*required-thread-bindings*</code></a> are extablished for
all new processes (not controlled by any argument or slot). The
initial value of this list is a alist associating various variables
with values. The only exported symbol appearing in an entry
is <code>(*readtable* . *readtable*)</code>. This means that the
global variable <a href="../ansicl/dictentr/readtabl.htm"><code>*readtable*</code></a> is bound to the global symbol value
of <a href="../ansicl/dictentr/readtabl.htm"><code>*readtable*</code></a> which is
the original Lisp readtable (which cannot be modified). This is often
not what you want, but specifying a different value should be done as
we describe just below. This binding is established here to avoid
accidentally changing the global symbol value of *readtable* (which is
permitted, of course; what is not permitted is changing the initial
readtable itself).
</p>
<p id="86">
Then the
<i>process-initial-bindings</i> slot of the process is
examined. If not <code>nil</code>, it should be an alist
of symbols and forms to evaluate for value. The symbols are bound in
the process as special variables with the given initial values,
effectively wrapping those bindings around the entire execution of
that process. If a particular variable appears more than once on the
alist, entries after the first are ignored. It is here you should bind
*readtable* if desired.
</p>

<p id="87">
By default, <a href="operators/mp/make-process.htm"><b>make-process</b></a> and <a href="operators/mp/process-run-function.htm"><b>process-run-function</b></a>
create processes with a null process-initial-bindings list. Such
action is not appropriate for processes which may do arbitrary
computations - for instance, a Lisp listener which accepts
computations from a user - or for applications which need to be
isolated from others. In such cases, the multiprocessing system
provides a list of special variables with appropriate default
values. The variable <a href="variables/excl/s_required-top-level-bindings_s.htm"><code>excl:*required-top-level-bindings*</code></a> is bound to
that list. </p>

<p id="88">
Another binding automatically established is <a href="variables/system/s_current-process_s.htm"><code>*current-process*</code></a>. When a process is running
that process is the value of <a href="variables/system/s_current-process_s.htm"><code>*current-process*</code></a>.  
</p>

<p id="89">The standard CL stream variables are bound to the value of
*terminal-io* but that variable itself is not given a dynamic
binding. This can cause problems because sometimes *terminal-io* may
be set to a stream that will signal an error when used (see 
<a href="debugging.htm">debugging.htm</a>). The variable <a href="variables/excl/s_initial-terminal-io_s.htm"><code>excl:*initial-terminal-io*</code></a>
holds the original *terminal-io* stream when Lisp starts up. It may be
useful for processes that aren't connected to a usable *terminal-io*
but wish to produce some output, for example for debugging. </p>

<p id="90">Note (again) that the value forms are evaluated in the dynamic
environment of the new process, not the process that created it, and
this new dynamic environment has no special bindings in effect. Those
value forms that themselves depend upon special variable values will
therefore see the global values of those variables. The intention of
this mechanism is that the new process should not inherit variable
values from the process that started it without something explicit
being done to pass the value.  Some other ways to achieve the same end
are shown below. </p>

<p id="91">If, for example, you want your new process to share the readtable
of the invoking process, putting an entry </p>

<pre id="92">
(*readtable* . *readtable*) 
</pre>

<p id="93">on the alist would not work. The value form would be evaluated on
the new process, and the global value of *readtable* would
result. Instead, you should do something like this (note that this is
a code fragment - you must add forms where there are suspension
points): </p>

<pre id="94">
(process-run-function 
       `(:name ... 
         :initial-bindings 
          ((*readtable* . ',*readtable*) 
           ,@excl:*required-top-level-bindings*)) 
         ...) 
</pre>

<p id="95">Since the :initial-binding list is treated as an alist, the first entry shadows all
succeeding ones. The effect of the above will be to set the alist cons for *readtable* to
something like: </p>

<pre id="96">
(*readtable* . (quote #&lt;readtable @ #x504a1&gt;))
</pre>

<p id="97">where the readtable object is the readtable of the invoking
process, and the quote is stripped off by the evaluation when the new
process begins. </p>

<p id="98">Using <a href="operators/mp/process-run-function.htm"><b>process-run-function</b></a> and related functions it
is possible to run any kind of Lisp computation as a separate
quasi-parallel process. All processes share the same Lisp world, so
the only thing that differentiates one process from another (besides
the state of its computation, of course) is the set of
special-variable dynamic bindings of its binding stack. For example,
in an environment with multiple windows it is possible to run multiple
top-level Lisp listeners or other interactive command loops, each
process in its own window; *terminal-io* would be bound in each
process to a stream object connected to its particular input-output
window. </p>

<p id="99">There are two ways to create special bindings in a new process. The
simple way is just to place the special variable on the lambda list of
the process' initial function, and pass the value as an argument (note
that this is a code fragment - the suspension points indicate where
additional forms are required): </p>

<pre id="100">
(defun my-command-processor (*terminal-io* *page-width*)
  (declare (special *page-width*))
    ...)
 
(let ((my-window (create-a-window ...)))
  (process-run-function "Bizarre Command Interpreter"
    #'my-command-processor my-window
    (page-size my-window))) 
</pre>

<p id="101">However, this requires the process' initial function to provide for
each variable that will be bound. The following more general idiom
permits establishment of arbitrary bindings for the new process: </p>

<pre id="102">
(defun establish-bindings (symbol-list value-list function args)
  (progv symbol-list value-list (apply function args)))
   
(let ((my-win (create-a-window ...)))
  (process-run-function "Bizarre Command Interpreter"
    #'establish-bindings
    '(*user-name* *phone-number*)
    (list "Fred" "555-1234")
    #'my-command-processor
    (list my-win (window-size my-win)))) 
</pre>

<p id="103">Here the establish-bindings function is <i>wrapped</i> around the
application of my-command-interpreter function to its arguments; while
the function is executing it will see bindings of the special
variables user-name and phone-number.</p>

<p id="104">
See <a href="operators/excl/required-thread-binding.htm"><b>required-thread-binding</b></a>
and <a href="operators/excl/required-top-level-binding.htm"><b>required-top-level-binding</b></a> which are macros
which add elements to the <a href="variables/excl/s_required-thread-bindings_s.htm"><code>*required-thread-bindings*</code></a> and
<a href="variables/excl/s_required-top-level-bindings_s.htm"><code>*required-top-level-bindings*</code></a> alists.
</p>

<hr><h2 id="105"><a name="listeners-and-specials-2">4.1 Lisp listeners and special variable bindings</a></h2>

<p id="106">The problem of starting a real Lisp listener is actually somewhat
more complex than the above discussion and sample code fragments
suggest. For one thing, the Lisp system defined by Common Lisp depends
on a large number of special variables, such as *readtable*,
*package*, and *print-level*. Since commands executed by one Lisp
listener might side effect some variables and thereby inappropriately
affect other processes, each process should maintain separate bindings
for these variables. Allegro CL provides a wrapping function,
tpl:start-interactive-top-level, which automatically binds to
reasonable default initial values all the special variables in the
Lisp system. Within a call to <a href="operators/tpl/start-interactive-top-level.htm"><b>tpl:start-interactive-top-level</b></a>, a
read-eval-print loop can be started with <a href="operators/tpl/top-level-read-eval-print-loop.htm"><b>top-level-read-eval-print-loop</b></a>.</p>

<p id="107">Thus, the Allegro CL idiom for running a standard Lisp listener
communicating with *terminal-io* (this might be done in a <a href="variables/excl/s_restart-app-function_s.htm"><code>excl:*restart-app-function*</code></a>)
looks something like this: </p>

<pre id="108">
(tpl:start-interactive-top-level *terminal-io* 
  #'tpl:top-level-read-eval-print-loop
  nil)
</pre>

<p id="109">And the idiom for running a standard Lisp listener inside a window
looks something like this: </p>

<pre id="110">
(process-run-function "My Lisp Listener"
  #'tpl:start-interactive-top-level
  my-window-stream
  #'tpl:top-level-read-eval-print-loop
  nil) 
</pre>

<p id="111">Entry to <a href="operators/tpl/top-level-read-eval-print-loop.htm"><b>tpl:top-level-read-eval-print-loop</b></a>
establishes additional bindings for certain variables used by the top
level loop. These bindings are established inside any bindings
established by <a href="operators/tpl/start-interactive-top-level.htm"><b>start-interactive-top-level</b></a>.  The
variables and initial binding values are taken from the alist bound to
the variable <a href="variables/tpl/s_default-lisp-listener-bindings_s.htm"><code>*default-lisp-listener-bindings*</code></a>.
</p>

<p id="112"><a href="operators/tpl/top-level-read-eval-print-loop.htm"><b>tpl:top-level-read-eval-print-loop</b></a> also
provides a hook to customize individual Lisp listeners. It calls the
function which is the value of <a href="variables/tpl/s_top-level-read-eval-print-loop-wrapper_s.htm"><code>*top-level-read-eval-print-loop-wrapper*</code></a>,
with two arguments, the internal function to invoke the
read-eval-print loop, and the argument it requires. </p>

<p id="113">In this rather trivial example, we define the wrapper so that the
command character (the value of <a href="variables/tpl/s_command-char_s.htm"><code>*command-char*</code></a>,
initially #\:) is #\$. Of course, in a real example, something more
complex would be done, but the form would be similar to this
example.</p>

<pre id="114">
(defun my-lisp-listener-wrapper (function args)
  (let ((tpl:*command-char* #\$))
    (apply function args)))
 
;; After we evaluate the following forms, the command character will be $
;; (rather than :) in any new lisp listener process.
 
(setq tpl:*top-level-read-eval-print-loop-wrapper*
  'my-lisp-listener-wrapper) 
</pre>

<p id="115">
What about setting up personal customizations? When Allegro CL is
first started it searches for <i>.clinit.cl</i> files as described in
<a href="startup.htm">startup.htm</a>. The typical purpose of a
<i>.clinit.cl</i> file is to load other files and to define
personalized functions and top-level commands, but it is possible for
a <i>.clinit.cl</i> file to <a href="../ansicl/dictentr/setq.htm"><b>setq</b></a> special variables. It is important to
understand what it means to do so. 
</p>

<p id="116">
A <i>.clinit.cl </i>file is loaded into a Lisp before
multiprocessing is started and even before the initial Lisp listener
is created. If a <i>.clinit.cl </i>file sets any special variables,
the value affected will (in general) be the global value of the
special. If the purpose is to customize Lisp for some particular
application this is probably the wrong way to do it. Someday an
unrelated system may be loaded into the same Lisp world which may
depend on reasonable default global variable values. Furthermore, the
various default binding mechanisms described above will generally keep
the global value even from being seen. </p>

<p id="117">For example, if it is necessary to set *print-escape* to nil for
some application, it is better for the application to set up its own
binding of the variable in the application code itself, or if that is
impossible, to have the code that starts the process wrap a binding of
the variable around execution of the application with the mechanisms
illustrated above. The worst way is to setq *print-escape* in a
<i>.clinit.cl</i> file.  Processes that assume the documented Common
Lisp standard simply might not work properly if *print-escape* is
nil. </p>

<p id="118">A dynamic binding - that is, a 'location' where a value is stored -
cannot be shared between processes. Each process may store the same
(i.e. eql) value in its binding, but if one process does a setf of
*print-base* it cannot affect the value of the binding of *print-base*
seen by another process. If that value is a Lisp object that can be
modified, side effects to that object will obviously be seen by both
processes. Of the variables listed above, those that typically hold
obviously side-effectable objects are *package*, *read-table* and the
several stream variables. Numbers (such as the value of *print-base*)
and the boolean values t and nil (such as might be the value of
*print-escape*) are not objects that can be side affected. 
</p>

<p id="119">
Unlike the standard common-lisp package special variables, it is
quite reasonable to place in your <i>.clinit.cl </i>file personal
customizations for top-level Lisp listener variables documented in
<a href="top-level.htm">top-level.htm</a>, such as <a href="variables/tpl/s_prompt_s.htm"><code>*prompt*</code></a>, that are not bound per
process. No standard Common Lisp code should depend on these. 
</p>

<p id="120">
Since the multiprocessing system tries hard to insulate variable
bindings between processes, the macro tpl:setq-default is provided to
make it easier for a user to change the default value of some standard
variable when that is what is really desired. It is intended primarily
for inclusion in<i> .clinit.cl</i> files. </p>

<p id="121"><a href="operators/tpl/setq-default.htm"><b>setq-default</b></a> is
convenient for simple customization and suffices for simple
environments. However, because it sets the global value of a symbol
which is seen by <i>all</i> processes, it may not be appropriate in
Lisp environments where the user may not have control over the needs
of some processes. In such circumstances it may be preferable not to
change a global symbol value in a <i>.clinit.cl</i> file with <a href="operators/tpl/setq-default.htm"><b>tpl:setq-default</b></a>. Instead,
users may just push a new cons onto the <a href="variables/tpl/s_default-lisp-listener-bindings_s.htm"><code>*default-lisp-listener-bindings*</code></a>
alist. Such action will have much the same effect with regard to any
code run inside a Lisp listener but will not affect non-listener
processes.</p>



<hr><hr><h2 id="122"><a name="gates-1">5.0 Gates</a></h2> 


<p id="123">
A gate is an object with two states, open and closed. It is created
with <a href="operators/mp/make-gate.htm"><b>make-gate</b></a>.
Its state can be open (see <a href="operators/mp/open-gate.htm"><b>open-gate</b></a>) or closed (see <a href="operators/mp/close-gate.htm"><b>close-gate</b></a>) and can be
tested with the <a href="operators/mp/gate-open-p.htm"><b>gate-open-p</b></a> function. A waiting
process whose wait function is <code>#'gate-open-p</code> places
much lower cpu demands on an os-threaded lisp than a waiting process
that has a general wait function. That is because <a href="operators/mp/process-wait.htm"><b>process-wait</b></a> threading code recognizes this
function (either the name or the function itself) specially and knows
how to treat it much more efficiently that other arbitrary Lisp
functions.
</p>
<p id="124">
Therefore, it is often worthwhile to add gates to a program (expending
the additional programming effort) to reduce the overhead of blocked
processes, even though gates might not be logically necessary. The
example just below illustrates this. Logically, the gate object is not
necessary, in that the example also depends on process-locks and could
be written more simply using just the <a href="operators/mp/process-lock.htm"><b>process-lock</b></a>. But the example is more efficient
because it uses gates.
</p>
<h3 id="125">
What is the difference between a gate and a lock?
</h3>
<p id="126">
A gate is either open or closed.  Any process can open or close a gate
at any time with no restrictions.  Therefore, a process has no
information about who opened or closed a gate or how long it will
remain in that state.  Gates are very light-weight and efficient, but
require careful coordination among the processes which change and/or query
the gate.
</p>
<p id="127">
Locks implement specific guarantees about when and which processes may
acquire or release a lock. A <a href="classes/mp/process-lock.htm"><code>process-lock</code></a> allows exactly one process
to acquire the lock; the same process must (normally) release it.
<a href="classes/mp/sharable-lock.htm"><code>sharable-lock</code></a> implements a
more complex locking policy. Process locks are described in the
section <a href="#process-locks-1">Section 7.0 Process locks</a> in this
document and sharable locks are described in <a href="smp.htm#sharable-locks-2">Sharable locks</a>
in <a href="smp.htm">smp.htm</a>.
</p>
<h3 id="128">
Gate example
</h3>
<p id="129">
Here is an example of using a gate to control execution.
</p>

<pre id="130">
;; an instance of xqueue represents a server and its queue.
;; a gate is used to indicate that data needing to be handled
;; is on the queue.

(defstruct xqueue
   data
   lock
   gate
   process)

;; anyone with access to an xqueue item can add to its work queue by calling
;; xqueue-add. After the data is added, the associated gate is opened
;; (an open gate indicates that data is waiting to be handled).

(defun xqueue-add (xq item)
   (mp:with-process-lock ((xqueue-lock xq))
     (setf (xqueue-data xq) (nconc (xqueue-data xq) (list item)))
     (mp:open-gate (xqueue-gate xq)))
   item)

;; create-xqueue-server starts a server process running and returns
;; the associated xqueue item to which work items can be queued.
;; The server process calls server-function on each element it retrieves
;; from the queue.  When server-function returns :exit, the server
;; process exits.
;;
;; note that the main loop (the process that is set to 
;; the value of (xqueue-process xq)) waits on the gate being open
;; (indicating unhandled data is present) and closes the gate when
;; all available data is handled.

(defun create-xqueue-server (server-function &key (name "Server"))
  (let ((xq (make-xqueue)))
    (setf (xqueue-lock xq) (mp:make-process-lock)
	  (xqueue-gate xq) (mp:make-gate nil)
	  (xqueue-process xq)
	  (mp:process-run-function
	      name
	    #'(lambda (lxq sf)
		(loop
		  (mp:process-wait "Waiting for data"
				   #'mp:gate-open-p
				   (xqueue-gate lxq))
		  (let (e run)
		    (mp:with-process-lock ((xqueue-lock lxq))
		      (if* (null (xqueue-data lxq))
			 then (mp:close-gate (xqueue-gate lxq))
			 else (setq e (pop (xqueue-data lxq)))
			      (setq run t)))
		    (when (and run (eq :exit (funcall sf e)))
		      (return)))))
	    xq server-function))
    xq))
</pre>


<hr><h2 id="131"><a name="semaphores-2">5.1 Semaphores</a></h2> 

<p id="132">
Each gate has an associated semaphore count, which is an integer
starting at 0. The function <a href="operators/mp/get-semaphore.htm"><b>get-semaphore</b></a> decrements that value (if it is
greater than 0, and when it becomes 0, it closes the associated
gate. The function <a href="operators/mp/put-semaphore.htm"><b>put-semaphore</b></a> increments the count, opens the
gate (if necessary), and releases just one of the threads waiting on
that gate, if there are any. Semaphores can be more efficient at
controlling gates when several threads are processing a work queue.
</p>




<hr><hr><h2 id="133"><a name="queues-1">6.0 Queues</a></h2> 

<p id="134">
Conceptually, a queue is a first in, first out (FIFO) list.  (Note
that queues may not be implemented as lists, but details of its actual
implementation are not necessary for understanding the concept.)
Enqueuing an object is conceptually appending an object to the end of
the list, dequeuing an object is conceptually equivalent to returning
the car (first element of the list and replacing the list with its
cdr).
</p>
<p id="135">
Queues are often useful, and because certain Allegro CL features
required queues, we decided to make the queue implementation
public. The advantage of using queues over using lists (and appending
to and popping from that list) are:
</p>
<ul>
<li id="136">
The <a href="operators/mp/enqueue.htm"><b>enqueue</b></a> and
<a href="operators/mp/dequeue.htm"><b>dequeue</b></a> operations
are atomic in a multiprocessing sense: once started, the operations
will complete without interruption.
</li>
<li id="137">
Dequeuing is provided with a waiting facility, so a process that 
tries to dequeue an object from a queue will (optionally) wait, if 
the queue is empty, until something is placed on it.
</li>
</ul>
<p id="138">
Queues are instances of the class <a href="classes/mp/queue.htm"><code>queue</code></a>. Create a queue with
<code>(make-instance 'mp:queue)</code>. Objects are added to
queues with the <a href="operators/mp/enqueue.htm"><b>enqueue</b></a> generic function and
removed from queues with the <a href="operators/mp/dequeue.htm"><b>dequeue</b></a> generic function. Queues
have no intrinsic size limit.
</p>
<p id="139">
Other queue functions include <a href="operators/mp/queue-empty-p.htm"><b>queue-empty-p</b></a> and <a href="operators/mp/queue-length.htm"><b>queue-length</b></a>.
</p>


<hr><h2 id="140"><a name="sized-queues-2">6.1 Sized queues</a></h2> 

<p id="141">
The basic queue has no restriction on size, so in any production
environment queue size will need to be regulated or its growth could
exhaust the amount of a available memory and crash your program.
</p>
<p id="142">
To ensure that a queue cannot grow beyond an expected size we can
customize the basic CLOS object to track its current size as well as
denote the maximum number of items we'll allow.  Here is the
definition of our finite sized queue:
</p>
<pre id="143">
(defclass finite-queue (mp:queue)
  ((count :documentation "The current size of the queue."
          :initform 0
	  :accessor queue-count)
   (max-size :documentation "The maximum size of the queue."
             :initform *default-finite-queue-max-size*
	     :accessor queue-max-size))
  (:documentation "A mp:queue with finite size."))

(defvar *default-finite-queue-max-size* 100
  "The default maximum size for a finite-queue.")
</pre>
<p id="144">
In the event of the queue being full during an enqueue attempt, we'll
create a <b>queue-full</b> condition:
</p>
<pre id="145">
(define-condition queue-full (simple-error)
  ((queue :initarg :queue
          :reader queue-full-queue))
  (:report (lambda (condition stream)
  	     (let ((queue (queue-full-queue condition)))
               (format stream 
               	       "~A is at it's maximum size of ~D."
  		       queue
                       (queue-max-size queue))))))
</pre>
<p id="146">
We then wrap the default methods for <a href="classes/mp/queue.htm"><code>mp:queue</code></a> to ensure that our
finite-queue tracks and holds to its boundaries:
</p>
<pre id="147">
(defmethod mp:enqueue :around ((queue finite-queue) what)
   (declare (ignorable what))
   (when (&gt;= (queue-count queue) (queue-max-size queue))
     (error 'queue-full :queue queue))
   (incf-atomic (slot-value queue 'count) 1)
   (call-next-method))

(defmethod mp:dequeue :around ((queue finite-queue) &amp;key wait empty-queue-results)
  (declare (ignorable wait empty-queue-results))
  (let ((item (call-next-method)))
    (decf-atomic (slot-value queue 'count) 1)
    item))
</pre>
<p id="148">
Notice the use of <a href="operators/excl/incf-atomic.htm"><b>incf-atomic</b></a>/<a href="operators/excl/decf-atomic.htm"><b>decf-atomic</b></a> in the above <a href="operators/mp/enqueue.htm"><b>mp:enqueue</b></a> method.  These ensure
that simultaneous increments and decrements from multiple threads will
all be accounted for. But this doesn't eliminate all possible
concurrency effects.  Since there is no locking around the check of
the max-size or the current count of the queue there is a small
opportunity for these values to change between when they are checked
and when the next method is called.
</p>
<p id="149">
Depending on how sensitive our application is to the number of items
on the queue this technique might be satisfactory and even have
performance benefits over the strict locking technique.  The other
positives of the non-locking technique is that once the enqueuing
finishes we still have an accurate queue-count and the queue size will
never grow larger than a known amount calculable by this formula:
</p>
<pre id="150">
  maximum queue size + number of enqueuing threads - 1 = adjusted maximum
</pre>
<p id="151">
For many cases this type of queue limiting is sufficient.  In the
case that an absolute maximum must be maintained or if the maximum
number of enqueuing threads is unknown, we can provide stricter
locking that comes at the performance cost of acquiring and holding a
lock.  Here is an example of such a technique: 
</p>
<pre id="152">
  (defmethod mp:enqueue :around ((queue finite-queue) what)
    (declare (ignorable what))
    (let ((queue-full-p nil))
      (mp:with-process-lock ((mp:queue-lock queue))
        (if (&gt;= (queue-count queue) (queue-max-size queue))
            (setf queue-full-p t)
            (incf (queue-count queue))))
      (if queue-full-p
          (error 'queue-full :queue queue)
          (call-next-method))))
</pre>
<p id="153">
The lock is acquired to read, compare, and update the size of the queue.
This prevents inaccuracies in the reported size of the queue and
ensures that the queue stays within its designated size. 
</p>
<p id="154">
In all cases, programming in a multiprocessing environment, and
particularly in an SMP environment, is an exercise in matching a
design choice that meets program requirements, thread safety, and
satisfactory performance.  We hope this helps introduce you to
the <a href="classes/mp/queue.htm"><code>mp:queue</code></a>
object, how to customize it, and to introduce you to loose and strict
locking techniques.
</p>



<hr><hr><h2 id="155"><a name="process-locks-1">7.0 Process locks</a></h2> 

<p id="156">
A <i>process-lock</i> is a defstruct which provides a mechanism for
interlocking process execution. Lock objects are created with <a href="operators/mp/make-process-lock.htm"><b>make-process-lock</b></a>.  A process-lock is
either <i>free</i> or it is <i>seized</i> by exactly one process. When
a lock is seized, a non-<code>nil</code> value is
stored in the lock object (in the slot named <em>locker</em>). Usually
this is the process which seized the lock, but can be any Lisp object
other than <code>nil</code>. Any process which tries to
seize the lock before it is released will block. This includes the
process which has seized the lock; the <a href="operators/mp/with-process-lock.htm"><b>with-process-lock</b></a> macro protects
against such recursion.
</p>

<p id="157">
The locker slot (accessed with <a href="operators/mp/process-lock-locker.htm"><b>process-lock-locker</b></a>) indicates
whether the lock is seized or free. If the value of the locker slot is
<code>nil</code>, the lock is free. If it is non-<code>nil</code>, the lock is seized. Both <a href="operators/mp/process-lock.htm"><b>process-lock</b></a> and <a href="operators/mp/process-unlock.htm"><b>process-unlock</b></a> take a lock-value
first optional argument. This argument defaults to the current process
(the value of <a href="variables/system/s_current-process_s.htm"><code>*current-process*</code></a>). This value, whatever it
is, is stored in the locker slot of the lock object by <a href="operators/mp/process-lock.htm"><b>process-lock</b></a>. When
<a href="operators/mp/process-unlock.htm"><b>process-unlock</b></a> is
called, the lock-value argument is compared to the value in the locker
slot. If the values are the same, the lock is unlocked. If the values
are different, <a href="operators/mp/process-unlock.htm"><b>process-unlock</b></a> signals an
error.
</p>

<p id="158">
The normal operation is as follows. Suppose that a lock object has
been created and is the value of the variable
<code>my-lock</code>:
</p>
<pre id="159">
(setq my-lock (mp:make-process-lock :name "my-lock")
</pre>
<p id="160">
Suppose as well that at least two processes
are running, the FOO process and the BAR process. When the FOO process
is current, <a href="operators/mp/process-lock.htm"><b>process-lock</b></a> is called on my-lock:
</p>

<pre id="161">
(mp:process-lock my-lock)
</pre>

<p id="162">
Now the value in the locker slot is #&lt;FOO process&gt;. Now
<a href="operators/mp/process-unlock.htm"><b>process-unlock</b></a>
is called in the FOO process
</p>

<pre id="163">
(mp:process-unlock my-lock)
</pre>

<p id="164">
The #&lt;FOO process&gt; is passed as the value of the lock-value
optional argument, and, since it matches the value in the locker slot,
the lock is unlocked and the value of the locker slot is set to
<code>nil</code>.
</p>

<p id="165">Meanwhile, suppose in process BAR, <a href="operators/mp/process-lock.htm"><b>process-lock</b></a> is called:</p>

<pre id="166">
(mp:process-lock my-lock)
</pre>

<p id="167">
If this call occurs while the lock is seized by the FOO process,
the BAR process blocks (waits) until the lock is freed and then itself
seizes the lock (we assume no other process is waiting for the
lock). As soon as the FOO process gives up the lock, the call to
<a href="operators/mp/process-lock.htm"><b>process-lock</b></a>
in the BAR process completes, with the value in the locker slot being
set to #&lt;BAR process&gt;.
</p>

<p id="168">
Both <a href="operators/mp/process-lock.htm"><b>process-lock</b></a> and the <a href="operators/system/without-scheduling.htm"><b>without-scheduling</b></a> macro
protect a segment of code from interleaving execution with other
processes. Neither has significant execution overhead, although
<a href="operators/system/without-scheduling.htm"><b>without-scheduling</b></a> is somewhat more
efficient. However, the mechanisms have different ranges of
applicability. A process-lock blocks only those other processes which
request the same lock; <a href="operators/system/without-scheduling.htm"><b>without-scheduling</b></a> unconditionally
blocks all other processes, even those completely unrelated to the
operation being protected. This might include high-priority processes
that need to field interrupts with low latency. Therefore, the <a href="operators/system/without-scheduling.htm"><b>without-scheduling</b></a> macro
should not be used around a code body that might require significant
time to execute.
</p>

<p id="169">
The descriptions below provide only a brief introduction. Please
follow the links to the individual description pages for details.
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Name</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Notes</b></td>
  </tr>
<tr>
<td WIDTH="33%" VALIGN="TOP">
<a href="operators/mp/make-process-lock.htm"><b>make-process-lock</b></a>
</td>
<td WIDTH="33%" VALIGN="TOP">
<i>&key name</i>
</td>
<td WIDTH="33%" VALIGN="TOP">
This function creates a new lock object. The value of the :name
keyword argument should be a string which is used for documentation
and in the whostate of processes waiting for the lock. (There are
additional keyword argument for internal use not listed. They should
not be set by user code.)
</td>
</tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-lock.htm"><b>process-lock</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>lock &optional lock-value whostate timeout</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function seizes lock with the value lock-value (which
    must be non-nil).</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-unlock.htm"><b>process-unlock</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>lock &optional lock-value</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function unlocks lock, setting the value in the locker
    slot to nil. The value of the locker slot of the lock must be the same as the lock-value
    argument. If it is not, an error is signaled.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-lock-locker.htm"><b>process-lock-locker</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>lock</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns the value of the locker slot of lock.
    This value is usually the process holding the lock, but can be any Lisp value. If the
    value is nil, the lock is not locked.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/process-lock-p.htm"><b>process-lock-p</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>object</i></td>
    <td WIDTH="33%" VALIGN="TOP">Returns true if object is a lock (as returned by <a href="operators/mp/make-process-lock.htm"><b>make-process-lock</b></a>) and returns nil
    otherwise.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/mp/with-process-lock.htm"><b>with-process-lock</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>(lock &key norecursive) &body body</i></td>
    <td WIDTH="33%" VALIGN="TOP">This macro executes the body with lock seized.</td>
  </tr>
</table>


<hr><hr><h2 id="170"><a name="minimum-sleep-1">8.0 cl:sleep and minimum sleeping time</a></h2> 

<p id="171">
While not strictly a multiprocessing issue, <a href="../ansicl/dictentr/sleep.htm"><b>cl:sleep</b></a> functionality is actually implemented
as part of the multiprocessing (though it is in a module always
present in a running Lisp).
</p>
<p id="172">
A call to <a href="../ansicl/dictentr/sleep.htm"><b>cl:sleep</b></a> is in fact
effective a call to <a href="operators/mp/process-sleep.htm"><b>mp:process-sleep</b></a> (with the
<i>whostate</i> argument set to "sleeping").<a href="../ansicl/dictentr/sleep.htm"><b>cl:sleep</b></a> requires a non-negative
argument. It will error when passed a negative argument.
</p>
<p id="173">
As to how short a time one can sleep, that is the minimum effective
argument to sleep is an internal parameter in Allegro CL. For a
variety of reasons, mostly historic, the initial value is 75 (meaning
75 milliseconds). To allow for shorter waiting times, you can change
the internal value. This form:
</p>
<pre id="174">
     (sys::thread-control :clock-event-delta)
</pre>
<p id="175">
returns the value the system is currently using, as an integer number
of milliseconds. (Note that <b>sys::thread-control</b> is an internal
function and is not further documented. It should not be used for any
purpose other than determining or changing the minimum sleep time.) The form is a setf-able location. To make the delta 10 milliseconds,
evaluate this:
</p>
<pre id="176">
     (setf (sys::thread-control :clock-event-delta) 10)
</pre>
<p id="177">
Reasonable values range from 0 to 75. The value is not saved
in a <a href="operators/excl/dumplisp.htm"><b>dumplisp</b></a> image. Each
fresh invocation of Lisp must reset it if something other than the
default value is desired.
</p>


<hr><hr><h2 id="178"><a name="mp-example-1">9.0 A simple example of multiprocessing</a></h2> 

<p id="179">
The example below can be loaded into Lisp either compiled or
interpreted. It shows simple use of mp:process-run-function and
mp:with-process-lock. Three parallel processes compute the number of
trailing zeroes in factorial N for different ranges of N. 
</p>
<p id="180">
The results are printed to a stream which is in the default designated
by <code>t</code>, which denotes <a href="../ansicl/dictentr/debug-io.htm"><code>*standard-output*</code></a>. When using the IDE,
in processes outside the Listener (Debug
Window), <a href="../ansicl/dictentr/debug-io.htm"><code>*standard-output*</code></a> is typically the
console on Windows and the shell that started Allegro CL and the IDE
on Linux and the Mac. You must display the console or shell to see the
output. On Windows, you can show the console (which is often hidden)
by evaluating <code>(</code><code><a href="operators/cg/s/show-console.htm"><b>show-console</b></a></code><code>)</code>.
</p>
<p id="181">
Or you can also open and editor pane,
use <a href="ide-menus-and-dialogs/tools-menu.htm#get-component">Tools | Get Component</a> to set the value of
a variable to that pane and use that as the value
of <i>stream</i> in the call
to <b>moby-process-test</b>, in which case the output will go to that
pane.
</p>

<pre id="182">
(in-package :cl-user)  
;; in the IDE (in-package :cg-user)
(require :process)
 
(defun factorial (n) (if (&lt; n 2) n (* n (factorial (1- n)))))
 
;; This lock is used to prevent output interleaving.
(defvar moby-output-lock (mp:make-process-lock))
 
;; Print to the stream the number of trailing
;; zeros in (factorial n) from n=from up to n=to.
;; This is a *very* inefficient way to do this computation,
;; but the point is to make it run slow enough to see.
 
(defun process-test (stream from to)
  (do ((n from (1+ n))) 
      ((&gt;= n to)) 
    (do ((x (factorial n) (/ x 10)) 
         (zeros -1 (1+ zeros))) 
        ((not (integerp x)) 
         (mp:with-process-lock (moby-output-lock) 
            (format stream &quot;factorial(~d) has ~d trailing zeros~%&quot;
                    n zeros)))))) 
 
;; This starts three processes in parallel. 
;; The original Lisp listener returns immediately, 
;; and will accept types forms while the other processes run. 
 
(defun moby-process-test (&amp;optional (stream t)) 
  (mp:process-run-function &quot;Test 1&quot; #'process-test stream 400 440)
  (mp:process-run-function &quot;Test 2&quot; #'process-test stream 440 470)
  (mp:process-run-function &quot;Test 3&quot; #'process-test stream 470 500) 
  t) 
 
;; Make sure factorial itself is compiled 
;; because large factorials exceed the interpreter's stack. 
 
(unless (compiled-function-p #'factorial) (compile 'factorial)) 
 
(format t &quot;Type (moby-process-test) to test multi-processing.~%&quot;) 
</pre>



<hr><hr><h2 id="183"><a name="wide-binding-1">Appendix A: Wide binding</a></h2>

<p id="184">
The value of a variable depends on its current binding. In a
multiprocessing environment, the current binding can be different in
different processes. Programmers must be aware of the fact that they
must establish bindings in different processes for variables for which
different processes require different values. For example, a process
printing a value to a file for debugging purposes may want <a href="../ansicl/dictentr/print-le.htm"><code>*print-length*</code></a> and <a href="../ansicl/dictentr/print-le.htm"><code>*print-level*</code></a> both to be <code>nil</code> so that all the information is printed, but a
listener process may want those variables to be small integers so that
the user is not overwhelmed with unneeded data. Without some form of
per-process binding, the process doing the printing to a file could
mess up the process managing the listener.
</p>
<p id="185">
While the need for binding is important for programmers to understand,
the multiprocessing binding implementation in theory is not. So long
as it works as described, implementation details are at best simply
distracting, and at worst actually misleading. (They can be misleading
because a programmer might try to take advantage of details of the
implementation that are either misunderstood or once properly
understood but since modified, perhaps by a patch or a new release.
For example, in this section, we talk of the virtual vector of
bindings associated with the value of a symbol. It would be a mistake
to try to get a handle on this vector and manipulate it directly
instead of using a documented tool such as <a href="operators/mp/symeval-in-process.htm"><b>symeval-in-process</b></a>.)
</p>
<p id="186">
However, certain features of the binding model are visible to
programmers and users, such as the <i>bind index</i> (which we
describe below). In order to understand these features, it is
necessary to understand some of the multiprocessing binding
model. And, so long as the information is not used to get around
proper ways of doing things, general understanding of the model is
probably desirable.
</p>
<p id="187">
There are various binding models that can be used. Broadly, there is
<i>shallow</i> binding, where the value slot contains the
current binding in some form, and <i>deep</i> binding,
where a process's binding stack is searched for a symbol's value.
</p>
<p id="188">
Releases of Allegro CL prior to 6.2 used a narrow form of the standard
shallow binding model: the value slot of a symbol held the current
binding of the current process. (The global value was held in a
separate slot.)  Each process had an associated bindstack with
bindings recorded. Switching processes required unwinding out the
current set of bindings and winding in the newly current processes
bindings. This made accessing the current value in a process fast, but
made both process switching and accessing the binding in another
process slow.
</p>
<p id="189">
Allegro CL now uses a <i>wide</i> variant of shallow
binding. A symbol has a logically wide value cell; it is conceptually
a vector of values, one for each process. Each process's bindstack has
an index by which the symbol's value vector is accessed, so that every
process has immediate access to its own set of current bindings.
Because of the way the conceptual value-vector is implemented, the
bindstacks need not be unwound and rewound when the current process
changes.
</p>
<p id="190">
One consequence of the new model is symbol-value access for wide
binding is slightly slower than for narrow binding; an extra
indirection is needed into the value vector in order to access a
symbol's value.  However, since wide binding is still a
shallow-binding technique, it is still much faster than deep binding.
</p>
<p id="191">
The advantages to wide binding over narrow binding are:
</p>
<ul>
<li id="192">
Because the bindstacks do not have to be unwound/rewound during
process switches, process-switching overhead is reduced, making
processes lighter weight and faster.
</li>
<li id="193">
Because symbol values are immediately accessible, wide binding becomes
a step toward making concurrent lisp thread execution possible.
</li>
</ul>

<p id="194">
We wish to emphasize again that the details of the vector of values
implementation are internal. Programs should not try to access or
modify the vector of values associated with a symbol.
</p>

<hr><h2 id="195"><a name="bindstack-index-2">Appendix A.1 The bindstack index</a></h2>

<p id="196">
Under the normal multiprocessing model, each process has one
implementation structure.  Each of these implementation structures
normally have one bindstack.  When a bindstack is first allocated, it
is given an index not used by any other bindstack in the system
(including dead bindstacks which have however not been
garbage-collected).  This index serves as the index into each symbol's
value-vector.  When a process has had a bindstack allocated for it,
the bindstack's index is shown by the process's print-object method.
Note that this index cannot be considered an identifier; if a process
dies and is gc'd, another process will eventually take on the same
index.  However, the index can be useful in distinguishing between
currently running processes, especially if these processes have been
given the same name.
</p>
<p id="197">
A bindstack index will be seen in several places:
</p>
<ul>
<li id="198">
The <a href="tpl-commands/processes.htm"><b>:processes</b></a>
command will print the bindstack-index of the process, if any, under
the new header named "Bix".
<pre id="199">
cl-user(3): :pro
P Bix Dis   Sec  dSec  Priority  State   Process Name, ...
*   1   3     0   0.0         0 runnable Initial Lisp Listener
cl-user(4): 
</pre>
</li>
<li id="200">
The print-object method for a process will include the bindstack
index in square brackets after the name:
<pre id="201">
cl-user(1): (mp:start-scheduler)
nil
cl-user(2): sys:*current-process*
#&lt;multiprocessing:process Initial Lisp Listener[1] @ #x7145d76a&gt;
cl-user(3): 
</pre>
</li>
<li id="202">
The <a href="ide-menus-and-dialogs/process-dialog.htm">Process
dialog</a> in the IDE and the Process browser in <a href="composer.htm">Allegro Composer</a> display the Bindstack
index in the "Bix" column.
</li>
<li id="203">
Trace output shows the bindstack index in square brackets after the
indentation (see <a href="tpl-commands/trace.htm"><b>:trace</b></a>):
<pre id="204">
cl-user(1): (defun fact (n)
              (if (= n 1) 1 (* n (fact (1- n)))))
fact
cl-user(2): :trace fact
(fact)
cl-user(3): (fact 3)
 0[1]: (fact 3)
   1[1]: (fact 2)
     2[1]: (fact 1)
     2[1]: returned 1
   1[1]: returned 2
 0[1]: returned 6
6
cl-user(4): 
</pre>
</li>
</ul>
<p id="205">
A full sample run of tracing in a multiprocessing context is given
below.  This example is only for demonstration of the wide-binding
concepts and has no other useful purpose.  In this example, a client
starts up a server and then writes a buffer-full to it, after which
it waits to read the data back again.  The server reads the buffer
from the client and then writes it back again, after which it goes
into a break loop (so that the process does not die).  The client is
then able to read the buffer sent by the client, and prints it and
enters a break loop itself.
</p>
<p id="206">
Note that after the first two nonrelated <a href="operators/excl/device-read.htm"><b>device-read</b></a> entry/exit pairs, the traced
device-read call appears to have been entered twice without the first
of these two exitting.  However, with the aid of the <a href="tpl-commands/processes.htm"><b>:processes</b></a> command, we can see that the first
entry is on behalf of the "run-client" process, which has
bindstack-index 3, and the second device-read entry is for
bindstack-index 5, or the "server" process.  It may be hard to see the
second return from <a href="operators/excl/device-read.htm"><b>device-read</b></a> (although it actually corresponds
to the first <a href="operators/excl/device-read.htm"><b>device-read</b></a>
entry of the pair), but it does appear after the server enters its
break loop.
</p>


<pre id="207">
cl-user(1): (shell &quot;cat socket-trace.cl&quot;)
(in-package :user)

(eval-when (compile load eval)
  (require :sock))

(defun start-server (buffer)
  (let ((sock (socket:make-socket :connect :passive)))
    (mp::process-run-function
     &quot;server&quot; #'server-get-connection sock buffer)
    (socket:local-port sock)))

(defun server-get-connection (sock buffer)
  (let ((stm (socket:accept-connection sock)))
    (close sock) ;; don't need it anymore
    (unwind-protect
	(progn
	  (read-in-buffer stm buffer)
	  
	  (write-out-buffer stm buffer))
      (close stm))
    (break &quot;server breaks&quot;)))

(defun run-client (port buffer)
  (let ((stm (socket:make-socket :remote-host &quot;localhost&quot;
				 :remote-port port)))
    (unwind-protect
	(progn
	  (dotimes (i (length buffer))
	    (setf (aref buffer i) (mod i 256)))
	  (write-out-buffer stm buffer)
	  (socket:shutdown stm :direction :output)
	  (read-in-buffer stm buffer)
	  )
      (close stm))))

(defun write-out-buffer (stm buffer)
  (dotimes (i (length buffer))
    (write-byte (aref buffer i) stm)))

(defun read-in-buffer (stm buffer)
  (dotimes (i (length buffer))
    (setf (aref buffer i)
      (read-byte stm))))

(defun socket-run (&amp;optional (message-length 10))
  (let ((client-buffer
	 (make-array message-length :element-type '(unsigned-byte 8)))
	(server-buffer
	 (make-array message-length :element-type '(unsigned-byte 8))))
    (run-client (start-server server-buffer) client-buffer)
    (format t &quot;~s~%&quot; client-buffer)
    (force-output)
    (break &quot;client breaks&quot;)))
0
cl-user(2): :cl socket-trace
; Fast loading [...]/socket-trace.fasl
cl-user(3): (require :acldns)
; Fast loading [...]/code/acldns.fasl
t
cl-user(4): (trace (device-read :inside (or server-get-connection run-client) :not-inside break))
(device-read)
cl-user(5): (mp:process-run-function &quot;run-client&quot; #'socket-run)
#&lt;multiprocessing:process run-client @ #x71b375fa&gt;
cl-user(6): 
 0[3]: (device-read #&lt;file-simple-stream
                      #p&quot;/etc/resolv.conf&quot; for input pos 0 @
                      #x71b397ea&gt;
                    nil 0 nil t)
 0[3]: returned 109
 0[3]: (device-read #&lt;file-simple-stream
                      #p&quot;/etc/resolv.conf&quot; for input pos 109 @
                      #x71b397ea&gt;
                    nil 0 nil t)
 0[3]: returned -1
 0[3]: (device-read #&lt;multivalent stream socket connected from
                      localhost/4137 to localhost/4136 @ #x71b3f912&gt;
                    nil 0 nil t)
 0[5]: (device-read #&lt;multivalent stream socket connected from
                      localhost/4136 to localhost/4137 @ #x71b44e42&gt;
                    nil 0 nil t)
 0[5]: returned 10
Break: server breaks

Restart actions (select using :continue):
 0: return from break.
 1: Abort entirely from this process.
[Current process: server]
[1c] cl-user(1): 
 0[3]: returned 10
#(0 1 2 3 4 5 6 7 8 9)
Break: client breaks

Restart actions (select using :continue):
 0: return from break.
 1: Abort entirely from this process.
[Current process: run-client]
[1c] cl-user(1): :pro
P Bix Dis   Sec  dSec  Priority  State   Process Name, Whostate, Arrest
*   5   1     0   0.0         0 waiting  server, waiting for input
*   3   3     0   0.0         0 waiting  run-client, waiting for input
*   4   1     0   0.0         0 waiting  Domain Name Server Client,
                                           waiting for input
*   1   2     0   0.0         0 runnable Initial Lisp Listener
cl-user(7): 
</pre>


<hr><hr><h2 id="208"><a name="profiling-1">Appendix B: Processes and the runtime analyzer</a></h2>

<p id="209">
The time runtime analyzer in Allegro CL (documented in
<a href="runtime-analyzer.htm">runtime-analyzer.htm</a>) collects data by periodically
recording which functions are on the stack. The space runtime analyzer
records all requests for new allocations. It is possible to set a flag
in a process object that prevents sampling when that process is the
current process.  This permits more accurate data for time spent or
space used by the process and code of interest.
</p>

<p id="210">
When a new process is created, the value of the flag is set to its
value in the current process. The predicate <a href="operators/mp/profile-process-p.htm"><b>profile-process-p</b></a> polls the
profiling flag and can be used with <b>setf</b> to change its value.
</p>

</body><hr><p id="2"><small>Copyright (c) 1998-2016, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page was not revised from the 9.0 page.</small><br><small>Created 2015.5.21.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.0</b><br><small><a href="introduction.htm#updates-s">Unrevised from 9.0 to 10.0.</a></small><br><a href="http://www.franz.com/support/documentation/9.0/doc/multiprocessing.htm">9.0 version</a></td></tr></table></html>