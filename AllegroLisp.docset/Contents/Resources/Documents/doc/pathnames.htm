<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"> <title>Pathnames</title></head><link rel="stylesheet" href="acldoc-styles.css" type="text/css"><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.0</b><br><small><a href="introduction.htm#updates-s">Unrevised from 9.0 to 10.0.</a></small><br><a href="http://www.franz.com/support/documentation/9.0/doc/pathnames.htm">9.0 version</a></td></tr></table><h1 id="2">Pathnames</h1><p id="3">This document contains the following sections:</p><a href="#symbolic-links-1">1.0 Unix symbolic links and truenames</a><br><a href="#windows-devices-1">2.0 Windows devices</a><br><a href="#parsing-unix-pathnames-1">3.0 Parsing Unix pathnames</a><br>&nbsp;&nbsp;&nbsp;<a href="#preprocessing-2">3.1 Preprocessing</a><br>&nbsp;&nbsp;&nbsp;<a href="#directory-component-2">3.2 Determining the :directory component</a><br>&nbsp;&nbsp;&nbsp;<a href="#name-component-2">3.3 Determining the :name component</a><br>&nbsp;&nbsp;&nbsp;<a href="#type-component-2">3.4 Determining the :type component</a><br>&nbsp;&nbsp;&nbsp;<a href="#pathname-anomalies-2">3.5 Anomalies</a><br>&nbsp;&nbsp;&nbsp;<a href="#pathname-examples-2">3.6 Table of examples</a><br><a href="#directory-component-of-merged-1">4.0 The directory component of merged pathnames</a><br><a href="#parsing-windows-pathnames-1">5.0 Parsing Windows pathnames</a><br><a href="#miscellaneous-pathname-functions-1">6.0 Miscellaneous pathname functions</a><br><a href="#logical-pathnames-1">7.0 Logical pathnames</a><br>&nbsp;&nbsp;&nbsp;<a href="#logical-pathnames-intro-2">7.1 Logical pathnames: introduction</a><br>&nbsp;&nbsp;&nbsp;<a href="#logical-pathnames-implementation-2">7.2 Logical pathnames: general implementation details</a><br>&nbsp;&nbsp;&nbsp;<a href="#logical-pathnames-notes-2">7.3 Logical pathnames: some points to note</a><br>&nbsp;&nbsp;&nbsp;<a href="#load-logical-pathname-translations-2">7.4 Details of cl:load-logical-pathname-translations</a><br><a href="#wildcards-1">8.0 Pathname wildcard syntax</a><br><p id="4">
Common Lisp pathnames do not always map easily into
operating-system filenames. In this document we describe the mapping
chosen for Allegro CL on the Unix and Windows operating systems and
discuss the implementation of logical pathnames.
</p><p id="5">
Most symbols naming pathname functionality are standard CL symbols in
the <code>:common-lisp</code> package. Extensions are usually in
the <code>:excl</code> package.
</p><hr><hr><h2 id="6"><a name="symbolic-links-1">1.0 Unix symbolic links and truenames</a></h2>

<p id="7">
Symbolic links are a feature of Unix filesystems. A symbolic link is a
Unix file that is interpreted as a filename in a different
location. Since a symbolic link can contain arbitrary filenames, a
symbolic link can traverse an arbitrary number of hierarchical levels,
can create back reference loops, and can make directories on other
filesystems appear local. The Common Lisp function <a href="../ansicl/dictentr/truename.htm"><b>truename</b></a> does resolve symbolic links in the
default. An additional keyword argument to that function (and to
<a href="../ansicl/dictentr/open.htm"><b>open</b></a> (when
<code>:direction</code> is <code>:probe</code>), <a href="../ansicl/dictentr/probe-fi.htm"><b>probe-file</b></a>, and <a href="operators/excl/rename-file-raw.htm"><b>rename-file-raw</b></a>),
<i>follow-symlinks</i>, controls whether symbolic links
are followed. When its value is true (the default for <a href="../ansicl/dictentr/truename.htm"><b>truename</b></a>, <a href="../ansicl/dictentr/open.htm"><b>open</b></a>, and <a href="../ansicl/dictentr/probe-fi.htm"><b>probe-file</b></a>), symbolic links are
followed. When the value is <code>nil</code> (the default
for <a href="operators/excl/rename-file-raw.htm"><b>rename-file-raw</b></a>),
they are not. This means that <code>(delete-file (truename
p))</code> deletes the actual file while <code>(delete-file
(truename p :follow-symlinks nil))</code> deletes the symbolic
link. See also <a href="operators/excl/rename-file-raw.htm"><b>rename-file-raw</b></a> and <a href="implementation.htm#extensions-to-clfuns-one-2">Extensions
to cl:make-package, cl:disassemble, cl:truename, cl:probe-file,
cl:open, cl:apropos</a> in
<a href="implementation.htm">implementation.htm</a>, and also <a href="operators/excl/pathname-resolve-symbolic-links.htm"><b>pathname-resolve-symbolic-links</b></a>.
</p>

<hr><hr><h2 id="8"><a name="windows-devices-1">2.0 Windows devices</a></h2>

<p id="9">
The drive (usually a letter followed by a colon e.g. <em>c:</em>) in a
Windows pathname is the <code>:device</code> component of the
pathname. It is not part of the <code>:directory</code>
component. Therefore, this will fail:
</p>

<pre id="10">
(defvar *root* #+mswindows "d:/foo/bar/" 
  #-mswindows "/usr/foo/")

(make-pathname :directory *root* ...)
</pre>

<p id="11">
You can either specify "d:" as the value of the
<i>device</i> keyword argument to <a href="../ansicl/dictentr/make-pat.htm"><b>make-pathname</b></a> or use the <a href="../ansicl/dictentr/pathnam3.htm"><b>pathname</b></a> function to convert the string and add
additional components using <a href="../ansicl/dictentr/merge-pa.htm"><b>merge-pathnames</b></a>:
</p>

<pre id="12">
(defvar *root* (pathname #+mswindows "d:/foo/bar/" 
  #-mswindows "/usr/foo/")
  
(merge-pathnames ... *root*)
</pre>

<h3 id="13">
Windows devices and logical pathnames
</h3>

<p id="14">
<code>(pathname "c:foo.cl")</code> would in Unix file system be
interpreted as a logical pathname with host "c" and filename and tyoe
"foo.cl". On Windows, so long as "c" has not been defined as a logical
host (in, for example, <i>hosts.cl</i>), it is interpreted as
specifying the device. This is a deviation from the ANS which makes
behavior on Windows more intuitive.
</p>
<p id="15">
Suppose <i>hosts.cl</i> contains this line:
</p>

<pre id="16">
"r"     '(";**;*.*" #p"sys:;code;")
</pre>

<p id="17">
but has no other single letter hosts defined. Then on Windows, we have
this behavior:
</p>

<pre id="18">
cg-user(6): (pathname "r:foo.cl")
#P"r:foo.cl"
cg-user(7): (type-of *)
logical-pathname
cg-user(8): (pathname "s:foo.cl")
#P"s:foo.cl"
cg-user(9): (type-of *)
pathname
cg-user(10): 
</pre>

<p id="19">
<code>(pathname "r:foo.cl")</code> returns a logical pathname
because "r" is known to be a logical host. <code>(pathname
"s:foo.cl")</code> returns a (regular) pathname because since "s"
is not known to be a logical host, it is assumed to be a device in the
Windows file system. On Unix system, both are logical pathnames even
if there is no definition of "r" or "s" as logical hosts.
</p>

<hr><hr><h2 id="20"><a name="parsing-unix-pathnames-1">3.0 Parsing Unix pathnames</a></h2>

<p id="21">Common Lisp pathnames have six components: </p>

<ol>
  <li id="22"><code>:host</code></li>
  <li id="23"><code>:device</code></li>
  <li id="24"><code>:version</code></li>
  <li id="25"><code>:directory</code></li>
  <li id="26"><code>:name</code></li>
  <li id="27"><code>:type</code></li>
</ol>

<p id="28">
On Unix systems, the <code>:host</code>,
<code>:device</code>, and <code>:version</code> components
are ignored. Only the other three have meaning. In this section, we
will describe how to transform a Unix pathname into an Allegro CL
pathname object. There are four steps:
</p>

<blockquote>
  <blockquote>
    <p id="29">
    <a href="#preprocessing-2">Section 3.1 Preprocessing</a>
    <br>
    <a href="#directory-component-2">Section 3.2 Determining the :directory component</a>
    <br>
    <a href="#name-component-2">Section 3.3 Determining the :name component</a>
    <br>
    <a href="#type-component-2">Section 3.4 Determining the :type component</a>
    </p>
  </blockquote>
</blockquote>

<p id="30">We then have several paragraphs describing unusual cases and labeled:</p>

<blockquote>
  <blockquote>
    <p id="31"><a href="#pathname-anomalies-2">Section 3.5 Anomalies</a></p>
  </blockquote>
</blockquote>

<p id="32">Finally, there are some examples, labeled</p>

<blockquote>
  <blockquote>
    <p id="33"><a href="#pathname-examples-2">Section 3.6 Table of examples</a></p>
  </blockquote>
</blockquote>

<hr><h2 id="34"><a name="preprocessing-2">3.1 Preprocessing</a></h2>

<p id="35">
The tilde (~) character is used to denote the user's home
directory. If Allegro CL encounters a tilde <i>as the first
character</i> of a pathname string, Allegro CL converts it to the
absolute pathname of the home directory of the user whose name
follows, or, if a slash (/') follows, the home directory of the user
running Lisp. Further, double slashes (`//') are converted to single
slashes (`/') and `/./' is also converted to a single slash (`/'). At
this point, the pathname string will have the form of the following
schematic: </p>

<pre id="36">
[/][&lt;dir1&gt;/]...[&lt;dirn&gt;/][&lt;name&gt;][.&lt;type&gt;]
      (1)( ..... 2 ......)(. 3 ..)(.. 4 ..) 
</pre>

<p id="37">The brackets (`[ ]') indicate that the elements may or may not
appear. The contents of the angle brackets (`&lt; &gt;') describe what
type of object goes in a particular location. The suspension points
(`...') indicate that any number of objects of the specified type may
appear. </p>



<hr><h2 id="38"><a name="directory-component-2">3.2 Determining the :directory component</a></h2>

<p id="39">
The <code>:directory</code> component (a list in Allegro CL) is
determined by parts (1), (2), and (3) of the schematic. Here are the
rules:
</p>

<ol>
<li id="40">
If (1) is present, the first element of the list that is the
<code>:directory</code> component is
<code>:absolute</code>. If (1) is not present and (2) is not
empty, the first element is <code>:relative</code>. If (1) and
(2) are both empty, the <code>:directory</code> component is
<code>nil</code> unless (3) is `..' and (4) is empty. In
the latter case (where the whole pathname is `..'), the
<code>:directory</code> component is <code>:up</code>. We
now have the first element of the list that is the
<code>:directory</code> component.
</li>
<li id="41">
If (1) is present and (2) is empty, the entire list is
<pre id="42">
(:absolute :root) 
</pre>
</li>
<li id="43">
If (2) is not empty, each `&lt;dir<i>i</i>&gt;' is made into a string
and added to the list unless it is two dots (`..'), in which case the
keyword <code>:up</code> is added to the list. We have now
resolved both (1) and (2).
</li>
<li id="44">
(3) affects the <code>:directory</code> component only if it is
`..' and the type, (4), is empty. In that case, the keyword
<code>:up</code> is added to the end of the list. If (3) is
anything other than `..' or if (4) is not empty, its value does
not affect the <code>:directory</code> component.
</li>
<li id="45">
Finally, if <code>:up</code> appears anywhere in the list
following a string, the <code>:up</code> and the string are
removed. For example
<pre id="46">
(:absolute "foo" :up "bar")
</pre>
<p id="47">
is resolved to
</p>
<pre id="48">
(:absolute "bar")
</pre>
</li>
</ol>

<p id="49">
We have now determined the <code>:directory</code> component. See
<a href="#pathname-examples-2">Section 3.6 Table of examples</a> below for examples.
</p>



<hr><h2 id="50"><a name="name-component-2">3.3 Determining the :name component</a></h2>

<p id="51">
The <code>:name</code> component is determined from (3) in the
schematic. Whatever appears as `&lt;name&gt;' is converted to a string
to become the <code>:name</code> component unless the type, (4),
is empty and `&lt;name&gt;' is all dots (`.', `..', `...', etc.). In
that case, a single dot (`.') means the <code>:name</code>
component will be <code>nil</code>. Two dots (`..'), as
mentioned above, cause the keywords <code>:up</code> to be added
to the list which is the value of the <code>:directory</code>
component. Three or more dots are put in a string which becomes the
value of the <code>:name</code> component.
</p>



<hr><h2 id="52"><a name="type-component-2">3.4 Determining the :type component</a></h2>

<p id="53">
The type, (4), must start with a dot, cannot contain another dot,
and must contain at least one character other than the dot. In that
case, everything after the dot (but <i>not</i> the dot itself) is made
into a string and it becomes the value of the <code>:type</code>
component.
</p>



<hr><h2 id="54"><a name="pathname-anomalies-2">3.5 Anomalies</a></h2>

<p id="55">
There are anomalies because dots play so many roles in Unix
pathnames. We have already discussed most of these. The remaining two
are illustrated by the following cases: 
</p>

<pre id="56">
  .bar
  bar. 
</pre>

<p id="57">
The <em>.bar</em> looks like a type, as if the file has no name and
type <em>bar</em>.  Instead, <em>.bar</em> is taken to be the filename
(including the dot) since the use of the dot in this case is to hide
the file from the standard Unix <strong>ls</strong> command listing,
not to specify a type.
</p>

<p id="58">
In the case of <em>bar.</em>, the <code>:name</code> is
"bar" and the <code>:type</code> is the empty string
(not <code>nil</code>).
</p>



<hr><h2 id="59"><a name="pathname-examples-2">3.6 Table of examples</a></h2>

<p id="60">
That completes the rules for converting pathnames in Allegro CL. Table
1 just below has many examples of pathnames including ones with dots
in all locations. Following each example, we indicate which rules were
used in producing the result. There are 5 Directory (<a href="#directory-component-2">D</a>) rules. Rules for name
(<a href="#name-component-2">N</a>) and type
(<a href="#type-component-2">T</a>) are not
subdivided. Anomalies are shown as `<a href="#pathname-anomalies-2">A</a>'.
</p>

<div align="left">

<table BORDER="1" CELLSPACING="1" CELLPADDING="8" WIDTH="589">
  <tr>
    <td VALIGN="TOP" COLSPAN="5"><p id="61" ALIGN="CENTER">Table 1: Examples of converting
    Namestrings to Pathnames </p></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP"><p id="62" ALIGN="CENTER">Namestring</p></td>
    <td WIDTH="78%" VALIGN="TOP" COLSPAN="4"><p id="63" ALIGN="CENTER">Pathname components</p></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP"></td>
    <td WIDTH="29%" VALIGN="TOP"><p id="64" ALIGN="CENTER">Directory</p></td>
    <td WIDTH="16%" VALIGN="TOP"><p id="65" ALIGN="CENTER">Name</p></td>
    <td WIDTH="16%" VALIGN="TOP"><p id="66" ALIGN="CENTER">Type</p></td>
    <td WIDTH="16%" VALIGN="TOP"><p id="67" ALIGN="CENTER">Rules</p></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"/" </td>
    <td WIDTH="29%" VALIGN="TOP">(:absolute :root) </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1,2
    </td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"/foo" </td>
    <td WIDTH="29%" VALIGN="TOP">(:absolute :root) </td>
    <td WIDTH="16%" VALIGN="TOP">"foo" </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1, 
    <a href="#name-component-2">N</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"/foo." </td>
    <td WIDTH="29%" VALIGN="TOP">(:absolute :root) </td>
    <td WIDTH="16%" VALIGN="TOP">"foo" </td>
    <td WIDTH="16%" VALIGN="TOP">""</td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1, 
    <a href="#name-component-2">N</a>, 
    <a href="#type-component-2">T</a>
    </td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"/foo.b" </td>
    <td WIDTH="29%" VALIGN="TOP">(:absolute :root) </td>
    <td WIDTH="16%" VALIGN="TOP">"foo" </td>
    <td WIDTH="16%" VALIGN="TOP">"b"</td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1, 
    <a href="#name-component-2">N</a>, 
    <a href="#type-component-2">T</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"/foo.bar." </td>
    <td WIDTH="29%" VALIGN="TOP">(:absolute :root) </td>
    <td WIDTH="16%" VALIGN="TOP">"foo.bar" </td>
    <td WIDTH="16%" VALIGN="TOP">""</td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1, 
    <a href="#name-component-2">N</a>, 
    <a href="#type-component-2">T</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"/foo.bar.baz" </td>
    <td WIDTH="29%" VALIGN="TOP">(:absolute :root) </td>
    <td WIDTH="16%" VALIGN="TOP">"foo.bar" </td>
    <td WIDTH="16%" VALIGN="TOP">"baz"</td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1, 
    <a href="#name-component-2">N</a>, 
    <a href="#type-component-2">T</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"/foo/bar" </td>
    <td WIDTH="29%" VALIGN="TOP">(:absolute "foo") </td>
    <td WIDTH="16%" VALIGN="TOP">"bar" </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1,3, 
    <a href="#name-component-2">N</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"/foo..bar" </td>
    <td WIDTH="29%" VALIGN="TOP">(:absolute :root) </td>
    <td WIDTH="16%" VALIGN="TOP">"foo." </td>
    <td WIDTH="16%" VALIGN="TOP">"bar"</td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1, 
    <a href="#name-component-2">N</a>, 
    <a href="#type-component-2">T</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"foo.bar" </td>
    <td WIDTH="29%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP">"foo" </td>
    <td WIDTH="16%" VALIGN="TOP">"bar"</td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1, 
    <a href="#name-component-2">N</a>, 
    <a href="#type-component-2">T</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"foo/" </td>
    <td WIDTH="29%" VALIGN="TOP">(:relative "foo") </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1,3</td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"foo/bar" </td>
    <td WIDTH="29%" VALIGN="TOP">(:relative "foo") </td>
    <td WIDTH="16%" VALIGN="TOP">"bar" </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1,3, 
    <a href="#name-component-2">N</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"foo/bar/baz" </td>
    <td WIDTH="29%" VALIGN="TOP">(:relative "foo" "bar") </td>
    <td WIDTH="16%" VALIGN="TOP">"baz" </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1,3, 
    <a href="#name-component-2">N</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"foo/bar/" </td>
    <td WIDTH="29%" VALIGN="TOP">(:relative "foo" "bar") </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1,3</td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"foo/bar/.." </td>
    <td WIDTH="29%" VALIGN="TOP">(:relative "foo") </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1,3,4,5</td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"/foo/../" </td>
    <td WIDTH="29%" VALIGN="TOP">(:absolute :root) </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#directory-component-2">D</a> 1,3</td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">".lisprc" </td>
    <td WIDTH="29%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP">".lisprc" </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#name-component-2">N</a>,
    <a href="#pathname-anomalies-2">A</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"x.lisprc" </td>
    <td WIDTH="29%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP">"x" </td>
    <td WIDTH="16%" VALIGN="TOP">"lisprc"</td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#name-component-2">N</a>, 
    <a href="#type-component-2">T</a> </td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"." </td>
    <td WIDTH="29%" VALIGN="TOP">(:relative) </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#name-component-2">N</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">".." </td>
    <td WIDTH="29%" VALIGN="TOP">(:relative :up) </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#name-component-2">N</a></td>
  </tr>
  <tr>
    <td WIDTH="22%" VALIGN="TOP">"..." </td>
    <td WIDTH="29%" VALIGN="TOP"><code>nil</code> </td>
    <td WIDTH="16%" VALIGN="TOP">"..." </td>
    <td WIDTH="16%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="16%" VALIGN="TOP"><a href="#name-component-2">N</a></td>
  </tr>
</table>
</div>



<hr><hr><h2 id="68"><a name="directory-component-of-merged-1">4.0 The directory component of merged pathnames</a></h2>

<p id="69">Merging of pathnames is handled by Allegro CL to take advantage of
directory hierarchies. Allegro CL follows the Common Lisp standard for
merging pathnames. This section provides examples showing the
directory component of the resulting pathname. </p>

<p id="70">Given two pathnames <em>a</em> and <em>b</em>, then the result,
<em>c</em>, of merging these pathnames may cause merging of their
directory components. </p>

<pre id="71">
(setf c (merge-pathnames a b))
</pre>

<p id="72">This merging follows these rules: </p>

<ol>
<li id="73">
If pathname <i>a</i> does not have a directory component, then the
directory component of pathname <i>b</i> becomes the directory
component of the result <i>c</i>.
</li>
<li id="74">
If pathname <i>a</i>'s directory component is absolute (i.e. it begins
with <code>:absolute</code>) then pathname <i>c</i> will have
pathname <i>a</i>'s directory component.  </li>
<li id="75">
If pathname <i>a</i> has a directory component that is relative, (that
is begins with <code>:relative</code>), then the directory
component of pathname <i>c</i> depends on the combined directory
component of pathname <i>a</i> and <i>b</i>. If pathname <i>b</i> is
absolute, then the resulting directory component will also be
absolute.  When <i>a</i> and <i>b</i>'s directory components are
combined they are canonicalized by the appropriate removal of
<code>:back</code> entries.
For example:
<pre id="76">
cl-user(4): (let ((a #p"bar/")
		  (b #p"/foo/"))
	      (pathname-directory (merge-pathnames a b)))
(:absolute "foo" "bar")
cl-user(5): (let ((a #p"bar/")
		  (b #p"foo/"))
	      (pathname-directory (merge-pathnames a b)))
(:relative "foo" "bar")
cl-user(6): (let ((a #p"../bar/")
		  (b #p"foo/"))
	      (pathname-directory (merge-pathnames a b)))
(:relative "bar")
cl-user(7): (let ((a #p"../bar/")
		  (b #p"../foo/"))
	      (pathname-directory (merge-pathnames a b)))
(:relative :back "bar")
cl-user(8): 
</pre>
</li>
<li id="77">
Finally, if pathname <i>b</i> does not have a directory component, the
directory component of pathname <i>a</i> becomes <i>c</i>'s directory
component.
</li>
</ol>

<hr><hr><h2 id="78"><a name="parsing-windows-pathnames-1">5.0 Parsing Windows pathnames</a></h2>

<p id="79">We have tried to make the handling of Windows pathnames (really DOS
pathnames) as consistent as possible with the handling of UNIX
pathnames. Note the following differences: </p>

<ul>
  <li id="80">/ and \ can be used interchangeably but if you use \ in a string, it should be doubled.
    (\ is the Lisp escape character and in a string is interpreted as `treat the next
    character specially'. The combination \\ in a string is interpreted as a single \.) Thus
    these strings name the same pathnames:</li>
</ul>

<pre id="81">
      "foo\\bar.cl"
      "foo/bar.cl"
</pre>

<ul>
  <li id="82">The drive, specified with a letter followed by a colon, is the device component of a
    pathname. It cannot be combined with the directory component. In particular</li>
</ul>

<pre id="83">
(make-pathname :directory "c:\\foo\\" ...)
</pre>

<p id="84">will fail. This will work:</p>

<pre id="85">
(make-pathname :device "c" :directory "\\foo\\" ...)
</pre>

<ul>
  <li id="86">UNC pathnames (e.g. \\&lt;machine-name&gt;\&lt;share-name&gt;\&lt;path&gt;) are
    supported as follows: the share name must be in the <code>:device</code> slot and the
    machine name in the <code>:host</code> slot. This classification of the parts of a UNC
    pathname are important when creating a pathname with <a href="../ansicl/dictentr/make-pat.htm"><b>make-pathname</b></a>. If
    you apply <a href="../ansicl/dictentr/pathnam3.htm"><b>pathname</b></a> to a string naming a UNC pathname, the parts are
    classified correctly automatically. In the following example, the <code>:host</code> is <em>hobart</em>
    and the share name <em>cl</em>, the directory is <em>src</em>, the filename <em>acl</em>
    and the type <em>mak</em>.</li>
</ul>

<pre id="87">
(pathname "\\\\hobart\\cl\\src\\acl.mak")
</pre>

<p id="88">
See also <a href="#windows-devices-1">Section 2.0 Windows devices</a> for a
discussion of why <code>(pathname "c:foo.cl")</code> returns a
regular pathname on Windows (unless "c" has been defined as a logical
host) but a logical pathname on Unix.
</p>

<hr><hr><h2 id="89"><a name="miscellaneous-pathname-functions-1">6.0 Miscellaneous pathname functions</a></h2>

<p id="90">
Allegro CL provides some additional pathname manipulation functions that
users might find useful:
</p>

<ul>
<li id="91">
<a href="operators/excl/probe-directory.htm"><b>probe-directory</b></a>:
an analog of the Common Lisp function probe-file. It returns
<a href="../ansicl/dictentr/truename.htm"><b>truename</b></a> applied to its argument
if its argument exists and names a
directory. It returns <code>nil</code> if its argument
does not exist or if its argument does not name a directory
(i.e. if it names a file rather than a
directory).
</li>
<li id="92">
<a href="operators/excl/path-pathname.htm"><b>path-pathname</b></a> takes a
filespec argument and returns the path portion as a pathname (leaving
out the <a href="../ansicl/dictentr/pathnam0.htm"><b>pathname-name</b></a> and the
<a href="../ansicl/dictentr/pathnam0.htm"><b>pathname-type</b></a>, but including
the <a href="../ansicl/dictentr/pathnam0.htm"><b>pathname-device</b></a> and the
<a href="../ansicl/dictentr/pathnam0.htm"><b>pathname-host</b></a>).
</li>
<li id="93">
<a href="operators/excl/path-namestring.htm"><b>path-namestring</b></a> applies
<a href="../ansicl/dictentr/namestri.htm"><b>namestring</b></a> to the result of
<a href="operators/excl/path-pathname.htm"><b>path-pathname</b></a>.
</li>
<li id="94">
<a href="operators/excl/enough-pathname.htm"><b>enough-pathname</b></a> is similar
to <a href="../ansicl/dictentr/namestri.htm"><b>enough-namestring</b></a> except it
returns a pathname rather than a namestring.
</li>
</ul>

<hr><hr><h2 id="95"><a name="logical-pathnames-1">7.0 Logical pathnames</a></h2>

<p id="96">
The logical pathname facility was added to the Common Lisp standard
by the X3J13 committee. The logical pathname specification leaves
various details of behavior up to the implementation. Here we describe
these details of the Allegro CL implementation. We do not describe the
whole facility.
</p>

<hr><h2 id="97"><a name="logical-pathnames-intro-2">7.1 Logical pathnames: introduction</a></h2>

<p id="98">
Logical pathnames were added to the Common Lisp language by X3J13
as a facility for the portable specification of filenames comprising
an application. This section describes various implementation
specifics about logical pathnames on Allegro CL, and then gives
suggestions how logical pathnames can be used effectively in both
developing and delivering a complex lisp application with many
files. A final section discusses issues raised by Unix symbolic links,
first in general, and then with regard to logical pathnames.
</p>



<hr><h2 id="99"><a name="logical-pathnames-implementation-2">7.2 Logical pathnames: general implementation details</a></h2>

<p id="100">A pathname or logical pathname is a Lisp object, but the language
defines conversions of a pathname to and from a character string
representation, called a namestring or logical-pathname
namestring. The mapping between physical pathnames and namestrings is
implementation dependent, but (with certain exceptions discussed in
table 1 above) a physical pathname representing a file in a Unix
filesystem will have a namestring representation equivalent to the
filename used by Unix utilities to name that file. Since Unix is
fairly permissive about which characters may be used as pathname
components, almost any character other than / (slash) is allowed
almost anywhere in a non-logical-pathname namestring. In Allegro,
physical pathnames and physical pathname namestrings (again with
certain minor exceptions) can represent all possible Unix
filenames.</p>

<p id="101">There is also a mapping between logical pathnames and
logical-pathname namestrings.  Logical pathnames exist so a portable
application written in portable code can reference the files it needs
to operate, so this mapping is not implementation dependent. It is not
the purpose of logical-pathname namestrings to represent all filenames
possible on an arbitrary host filesystem, e.g. Unix. Rather,
logical-pathname namestrings are limited to a reasonable subset of
possible filename syntax that can be accommodated by all plausible
filesystems. 
</p>
<p id="102">
For this reason, characters other than alphabetics, decimal digits,
and the minus sign are not supported in "words" of a logical-pathname
namestring (see <a href="../ansicl/subsecti/syntaxof.htm">this
section</a> of the ANSI Spec, noting particularly the definition of a
word). The intention is that a large multi-file system should limit
its filenames in this way, and then the logical pathname mechanism
will guarantee that the software can be ported to other platforms with
minimal difficulty.
</p>
<p id="103">
Many have found this restriction onerous. Because actual work is
typically done on just a few platforms, forbidding characters such as
an underscore (_), which in fact causes no problems on any popular
platform, contributes nothing to actual portability and adds
additional development rules whose purpose (to non-Lisp programmers
and to many Lisp programmers) is obscure. For this reason, Allegro CL
has added the variable <a href="variables/excl/s_additional-logical-pathname-name-chars_s.htm"><code>*additional-logical-pathname-name-chars*</code></a>. Characters
on this list are permitted in logical pathname "words" regardless of
the standard. The initial value of this variable is <code>nil</code>. Character objects can be pushed onto this list
as desired.
</p>

<p id="104">
To encourage portability the Allegro CL implementation will not
convert any namestring containing incorrect logical-pathname syntax
into a logical pathname (except as the allowed syntax is extended by
characters in the list which is the value of <a href="variables/excl/s_additional-logical-pathname-name-chars_s.htm"><code>*additional-logical-pathname-name-chars*</code></a>). Thus,
assuming that expert has been defined as a logical host, this call to
pathname
</p>

<pre id="105">
(pathname "expert:;engine;steam-power.lisp")
</pre>

<p id="106">will return a logical-pathname object with name component
<em>steam-power</em>, type <em>lisp</em>, and directory <em>(:relative
"engine")</em>. However, this call</p>

<pre id="107">
(pathname "expert:;engine;steam_power.lisp")
</pre>

<p id="108">
cannot parse the string as a valid logical-pathname namestring and
will instead return a physical pathname with name component
<em>expert:;engine;steam_power</em>. This is obviously not what was
intended; nonetheless, the implementation is not justified signaling
an error because this physical pathname is a perfectly legal Unix
filename, however unlikely.
</p>

<p id="109">
But if the underscore character, #\_, is added to the list which is
the value of <a href="variables/excl/s_additional-logical-pathname-name-chars_s.htm"><code>*additional-logical-pathname-name-chars*</code></a>, then
"expert:;engine;steam_power.lisp" will parse as a logical pathname:
</p>

<pre id="110">
(push #\_ *additional-logical-pathname-name-chars*)
(describe (pathname "expert:;engine;steam_power.lisp"))
#p"expert:;engine;steam_power.lisp" is a structure of 
type logical-pathname.
It has these slots:
 host               "expert"
 device             nil
 directory          (:relative "engine")
 name               "steam_power"
[...]
</pre>

<p id="111">
Extending allowable logical pathname syntax is not, of course,
portable.  It may be necessary for a system to refer to
platform-dependent files (perhaps preexisting library files) with
non-conforming names in a portable way. There is no reason not to use
the translation services provided by logical pathnames for such files
as well, given that such files are platform dependent in the first
place. While the pathname implementation will not parse such a
namestring as a logical pathname, it is nonetheless possible to
construct a logical pathname with arbitrary strings as words, and
portably so, using <a href="../ansicl/dictentr/make-pat.htm"><b>make-pathname</b></a>. For example, the
<em>expert:;engine;steam_power.lisp</em> pathname above could be
constructed with a form such as this, assuming logical host expert has
been defined:</p>

<pre id="112">
(make-pathname :host "expert"
   :directory '(:relative "engine")
   :name "steam_power" 
   :type "lisp") 
<strong>[returns]</strong> 
#p"expert:;engine;steam_power.lisp" ; a logical-pathname
</pre>

<p id="113">This logical-pathname will violate print/read consistency if and
when the printed representation is re-read because a physical pathname
will be created. Otherwise, it will work just like any other logical
pathname. One obvious place where this technique could be useful is in
naming pre-existing foreign code system object files and libraries,
perhaps in conjunction with defsystem.</p>



<hr><h2 id="114"><a name="logical-pathnames-notes-2">7.3 Logical pathnames: some points to note</a></h2>

<ol>
<li id="115">
<code>:device</code> and <code>:version</code> default to
<code>:unspecific</code>. (The standard requires
<code>:device</code> always to be <code>:unspecific</code>
since devices are not supported in logical pathnames.)
</li>
<li id="116">
In <a href="../ansicl/dictentr/make-pat.htm"><b>make-pathname</b></a>, device and
version default to <code>:unspecific</code>. An error is
signaled if these arguments are not <code>nil</code> or
<code>:unspecific</code> (or <code>:newest</code> for
version). Hosts are represented as strings in Allegro CL. They are
always compared case-insensitively.
</li>
<li id="117">
<a href="../ansicl/dictentr/make-pat.htm"><b>make-pathname</b></a>: returns a
logical pathname if <em>host</em> is given and it is `logical', that
is if logical pathname translations have been defined for it.
</li>
<li id="118">
The specification says of <a href="../ansicl/dictentr/parse-na.htm"><b>parse-namestring</b></a>:
</li>
</ol>

<blockquote>
  <blockquote>
    <p id="119"><em>thing</em> is recognized as a logical pathname namestring when <em>host</em> is logical or
    <em>defaults</em> is a logical pathname. In the latter case the host portion of the logical
    pathname namestring and its following colon are optional. If the host portion of the
    namestring and host are both present and do not match, an error is signaled.</p>
  </blockquote>
  <p id="120">Allegro CL implements the following extension:</p>
  <blockquote>
    <p id="121">Allegro CL recognizes a namestring as a logical pathname in one additional
    circumstance: the namestring has logical namestring syntax and host is given. In other
    words, the host need not already have translations defined for it.</p>
  </blockquote>
</blockquote>

<ol start="5">
<li id="122">
<a href="../ansicl/dictentr/merge-pa.htm"><b>merge-pathnames</b></a>: 
<ol>
<li id="123">
when <em>pathname</em> is a relative logical pathname and
<em>defaults</em> is not a logical of the same host, then Allegro CL
translates <em>pathname</em> before the merge. Keep in mind that the
relative logical pathname could translate into an absolute physical
pathname--this is the reason for this rule, as relative and absolute
merging rules are different. For example:
<pre id="124">
cl-user(1): (setf (logical-pathname-translations "frob")
               `((";foo;**;*.*" "/bar/**/*.*")))
((";foo;**;*.*" "/bar/**/*.*"))
cl-user(2): (merge-pathnames "frob:;foo;whack.cl" "/blam/")
#p"/bar/whack.cl"
cl-user(3): (setf (logical-pathname-translations "frob")
               `((";foo;**;*.*" "bar/**/*.*")))
((";foo;**;*.*" "bar/**/*.*"))
cl-user(4): (merge-pathnames "frob:;foo;whack.cl" "/blam/")
#p"/blam/bar/whack.cl"
cl-user(5): 
</pre>
</li>
<li id="125">
when <em>pathname</em> is an absolute physical pathname and
<em>defaults</em> is a logical pathname, <em>pathname</em>
is returned without further consideration, thus
preventing obvious nonsensical merging such as:
<pre id="126">
(merge-pathnames "/foo/bar/baz.fasl" "sys:;wham;.fasl")
    RETURNING #p"sys:foo;bar;baz.fasl"
</pre>
<p id="127">
That would not make sense because #p"sys:foo;bar;baz.fasl" will (in
all probability) not make sense, especially if <code>sys:</code>
has translation into an absolute pathname, since rarely, if ever,
would the concatenation of two absolute pathnames make any sense.
</p>
</li>
<li id="128">
The ANSI specification says "merge-pathnames returns a logical pathname 
if and only if its first argument is a logical pathname, or 
its first argument is a logical pathname namestring with an 
explicit host, or its first argument does not specify a host and the 
default-pathname is a logical pathname." In Allegro CL, ANSI compliance
is modified by 1. above. That is, in the
case of a relative logical pathname (or logical namestring) and an
absolute default, Allegro CL will return a physical not a logical
pathname.
</li>
</ol>
</li>


<li id="129">
<a href="../ansicl/dictentr/parse-na.htm"><b>parse-namestring</b></a>: a directory
sub-component of "**" is parsed as <code>:wild-inferiors</code>
and "*" as <code>:wild</code>.
</li>
<li id="130">
There is a translation for the logical host "sys" which is defined as
follows:
</li>
</ol>

<pre id="131">
(setf (logical-pathname-translations &quot;sys&quot;) 
      (list 
        (list &quot;**;*.&quot; 
          (namestring &lt;location of exe file&gt;))))
</pre>

<blockquote>
  <p id="132">The <code>&lt;location of the exe file&gt;</code> is the location
  of the executable being run. With the initial installation, the executable
  is named <em>mlisp.exe</em>, <em>alisp.exe</em> , or <em>allegro.exe</em>
  on Windows and
  <em>mlisp</em> or <em>alisp</em> on Unix, or <em>allegro.exe</em> on
  platforms that support the IDE. You may have made copies of the
  executable with different names for general use or as part of a
  runtime distribution.</p>
</blockquote>

<ol start="8">
<li id="133">
Implementation notes for <a href="../ansicl/dictentr/load-log.htm"><b>load-logical-pathname-translations</b></a>: see the
description of this function <a href="#load-logical-pathname-translations-2">below</a>.
</li>
<li id="134">
Implementation notes for <a href="../ansicl/dictentr/translat.htm"><b>translate-logical-pathname</b></a>: if this function is
called on a logical pathname for which no translation exists, it will
in Allegro CL try calling <a href="../ansicl/dictentr/load-log.htm"><b>load-logical-pathname-translations</b></a> for the host
rather than signaling an error immediately.
</li>
<li id="135">
Implementation notes for <a href="../ansicl/dictentr/transla0.htm"><b>translate-pathname</b></a> and <a href="../ansicl/dictentr/pathnam1.htm"><b>pathname-match-p</b></a>: In addition to the meanings of
* and ** as entire pathname words, standing for
<code>:wild</code> and <code>:wild-inferiors</code>,
Allegro CL also allows * within a single pathname word, with the
normal UNIX globbing interpretation. These capabilities also apply to
<a href="../ansicl/dictentr/translat.htm"><b>translate-logical-pathname</b></a>,
which calls these functions. On the right hand side of a translation
rule, a * indicates where to substitute the wildcard-matched
text. Only one * is allowed within each word on the right hand side of
a rule.
</li>
<li id="136">
See also <a href="#windows-devices-1">Section 2.0 Windows devices</a> for a
discussion of why <code>(pathname "c:foo.cl")</code> returns a
regular pathname on Windows (unless "c" has been defined as a logical
host) but a logical pathname on Unix.  
</li>
</ol>



<hr><h2 id="137"><a name="load-logical-pathname-translations-2">7.4 Details of cl:load-logical-pathname-translations</a></h2>

<blockquote>
  <p id="138"><a href="../ansicl/dictentr/load-log.htm"><b>load-logical-pathname-translations</b></a></p>
  <p id="139"><strong>Arguments:</strong> <i><code>host</code></i></p>
  <p id="140">Certain details of this standard Common Lisp function are
  explicitly implementation dependent. In all implementations,
  <em>host</em> must be a string naming a logical-pathname host and
  this function returns <code>nil</code> if the
  logical-pathname host named <em>host</em> is already
  defined. Otherwise, it searches for a logical pathname host
  definition as follows (This is the implementation-dependent part):
  </p> 

<ol> 
<li id="141">
<a href="operators/excl/logical-pathname-translations-database-pathnames.htm"><b>logical-pathname-translations-database-pathnames</b></a>
is called. 
</li>
<li id="142">
It returns a list of strings or pathnames which
can be coerced to pathnames naming files.
</li> 
<li id="143">
These files are
examined in order (if a file does not exist, it is skipped) until a
translation is found. The format of these files is:
</li>
</ol>
  <p id="144"><code>[</code><code><em>host</em></code><code>  (</code><code><i>from-wildcard to-wildcard</i></code><code>)+]*</code></p>
  </blockquote>
<blockquote>
<p id="145">where <em>host</em> is a string naming a logical host (i.e., "src") and
<em>from-wildcard</em> and <em>to-wildcard</em>
specify the translation (i.e., are the source and
target), such as
</p>
<pre id="146">
(list "**;*.*" "sys:**;*.*") 
</pre>
<p id="147">
The list of <em>from-wildcard</em> and <em>to-wildcard</em> is
evaluated.
</p>
</blockquote>

<p id="148">
For example, <a href="operators/excl/logical-pathname-translations-database-pathnames.htm"><b>logical-pathname-translations-database-pathnames</b></a>
initially returns the list
<code>("sys:hosts.cl")</code>, which tells the system
to look at the files <em>hosts.cl</em> in the Allegro directory
(usually the directory containing the executable).
</p>



<p id="149">Other files besides <em>hosts.cl</em> can be searched for logical
pathname information.  The function <a href="operators/excl/logical-pathname-translations-database-pathnames.htm"><b>logical-pathname-translations-database-pathnames</b></a>
returns a list of strings naming files that will be searched for
logical-pathname information. It initially returns
<code>("sys:hosts.cl")</code>. Additional strings can
be added with <a href="../ansicl/dictentr/pushnew.htm"><b>pushnew</b></a> and
friends, like this:</p>

<pre id="150">
(pushnew "~/myhosts"
(excl:logical-pathname-translations-database-pathnames))
</pre>

<p id="151"><a href="operators/excl/logical-pathname-translations-database-pathnames.htm"><b>logical-pathname-translations-database-pathnames</b></a>
will now return</p>

<pre id="152">
("~/myhosts" "sys:hosts.cl")
</pre>

<p id="153">
The ANSI Specification nowhere defines how a logical host can be
undefined, or whether a logical host may have an empty set of
translations. However, Allegro CL interprets an empty set of translations as
equivalent to the logical host not being defined at all. Therefore, a
logical host may be undefined by setting its <a href="../ansicl/dictentr/logical0.htm"><b>logical-pathname-translations</b></a> to
<code>nil</code>. Note that this behavior may be different
from that of other Common Lisp implementations.
</p>
<p id="154">
If you have set <a href="../ansicl/dictentr/logical0.htm"><b>logical-pathname-translations</b></a> to
<code>nil</code> for a host defined in
<i>sys:hosts.cl</i> and then call <a href="../ansicl/dictentr/translat.htm"><b>translate-logical-pathname</b></a> on a
logical pathname using that host, the system will, as usual, look in
<i>sys:hosts.cl</i> to find translation rules, and,
finding them will use them.
</p>
<p id="155">
All logical-pathname translations are flushed
when an image dumped (by <a href="operators/excl/dumplisp.htm"><b>dumplisp</b></a>) is restarted.
</p>



<hr><hr><h2 id="156"><a name="wildcards-1">8.0 Pathname wildcard syntax</a></h2>

<p id="157">
Pathnames can have wildcard components, which causes all files that
match the remainder of the pathname to match. See <a href="../ansicl/dictentr/director.htm"><b>cl:directory</b></a>, <a href="../ansicl/dictentr/pathnam1.htm"><b>cl:pathname-match-p</b></a>, and <a href="../ansicl/dictentr/wild-pat.htm"><b>cl:wild-pathname-p</b></a>. The newly added function
<a href="shell-module.htm#glob-op-bookmarkxx"><b>glob</b></a> also supports
wildcards. This section (added after the initial release of Allegro CL
6.2) describes wildcards in pathnames and how they are processed by
Allegro CL.
</p>
<p id="158">
The definition of `wild' is
(<i>ansicl/glossary/w.htm#wild</i>):
</p>
<p id="159">
<blockquote>
wild: adj. 1. (of a namestring) using an implementation-defined syntax
for naming files, which might "match" any of possibly several possible
filenames, and which can therefore be used to refer to the aggregate
of the files named by those filenames. 2. (of a pathname) a structured
representation of a name which might "match" any of possibly several
pathnames, and which can therefore be used to refer to the aggregate
of the files named by those pathnames. The set of wild pathnames
includes, but is not restricted to, pathnames that have a
<code>:wild</code> component, or that have a
<code>:wild</code> or <code>:wild-inferiors</code>
directory component. See the function <a href="../ansicl/dictentr/wild-pat.htm"><b>wild-pathname-p</b></a>.
</blockquote>
</p>
<p id="160">
That implementation-defined syntax in Allegro CL is this:
</p>

<p id="161">
<blockquote>
A <b>*</b> or <b>?</b> can appear in the filename portion of a
pathname or path namestring. <b>*</b> will match 0 or more characters
and <b>?</b> will match a single character.  For example, the wild
pathname <code>#p"foo?.cl</code>" will match
<code>#p"foo1.cl</code>" and <code>#p"foo2.cl</code>", but
not <code>#p"foo12.cl"</code>.
</blockquote>
</p>
<p id="162">
The above, in addition to the following two definitions complete the
description of what the <i>wildcard</i> argument to
<a href="../ansicl/dictentr/pathnam1.htm"><b>pathname-match-p</b></a>
can contain:
</p>
<ul>
<li id="163">
A pathname with a name and/or type component of
<code>:wild</code>.  A string that when parsed as a pathname has
a name or type that parses as "*" is converted to :wild.  That is:
<pre id="164">
cl-user(6): (describe (pathname "*.*"))
#p"*.*" is a structure of type pathname.  It has these slots:
 host               nil
 device             :unspecific
 directory          nil
 name               :wild
 type               :wild
 version            :unspecific
 namestring         "*.*"
 hash               nil
 dir-namestring     "./"
 plist              nil
cl-user(7): 
</pre>
</li>
<li id="165">
A pathname with a directory component containing an element of
<code>:wild</code> or <code>:wild-inferiors</code>.  A
string that when parsed as a pathname has a directory component that
contains "*" or "**" are converted to <code>:wild</code> and
<code>:wild-inferiors</code>, respectively. Test is:
<pre id="166">
cl-user(9): (describe (pathname "a/b/*/foo.cl"))
#p"a/b/*/foo.cl" is a structure of type pathname.  It has these slots:
 host               nil
 device             :unspecific
 directory          (:relative "a" "b" :wild)
 name               "foo"
 type               "cl"
 version            :unspecific
 namestring         "a/b/*/foo.cl"
 hash               nil
 dir-namestring     "a/b/*/"
 plist              nil
cl-user(10): (describe (pathname "a/b/**/foo.cl"))
#p"a/b/**/foo.cl" is a structure of type pathname.  It has these slots:
 host               nil
 device             :unspecific
 directory          (:relative "a" "b" :wild-inferiors)
 name               "foo"
 type               "cl"
 version            :unspecific
 namestring         "a/b/**/foo.cl"
 hash               nil
 dir-namestring     "a/b/**/"
 plist              nil
cl-user(11): 
</pre>
</li>
</ul>

</body><hr><p id="2"><small>Copyright (c) 1998-2016, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page was not revised from the 9.0 page.</small><br><small>Created 2015.5.21.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.0</b><br><small><a href="introduction.htm#updates-s">Unrevised from 9.0 to 10.0.</a></small><br><a href="http://www.franz.com/support/documentation/9.0/doc/pathnames.htm">9.0 version</a></td></tr></table></html>