<html><head><meta name="viewport" content="width=device-width, initial-scale=1"> <meta http-equiv="content-type" content="text/html; charset=UTF-8"> <link rel="stylesheet" href="acldoc-styles.css" type="text/css"><title>Gray Streams in Allegro CL</title></head><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/gray-streams.htm">10.0 version</a></td></tr></table><h1 id="2">Gray Streams in Allegro CL</h1><p id="3">This document contains the following sections:</p><a href="#gs-intro-1">1.0 Introduction to Gray streams in Allegro CL</a><br><a href="#gs-oop-1">2.0 Documenting object-oriented protocols</a><br><a href="#gs-classes-1">3.0 Stream classes</a><br><a href="#gs-char-input-1">4.0 Generic functions for character input</a><br><a href="#gs-char-output-1">5.0 Generic functions for character output</a><br><a href="#gs-bin-streams-1">6.0 Generic functions for binary streams</a><br><a href="#gs-efficient-seq-io-1">7.0 Functions for efficient input and output of sequences</a><br><a href="#gs-creating-1">8.0 Creating streams</a><br><a href="#gs-misc-1">9.0 Miscellaneous stream functions</a><br><p id="4">
Since release 6.0, Allegro CL has a new streams model using
simple-streams, which have no element-type, but which act
as if they have element type <code>(unsigned-byte
8)</code>. The new implementation is described in
<a href="streams.htm">streams.htm</a>. This document describes the Gray
Streams implementation in Allegro CL, which was the stream
implementation in releases prior to 6.0. The
Gray Streams implementation is preserved for backward compatibility.
</p><p id="5">
Gray stream code is not typically included in the Allegro CL
image. Load it with <code>(require :streamc)</code>.
</p><p id="6">
In general, a Gray stream is created whenever a file is opened (with
<a href="../ansicl/dictentr/open.htm"><b>open</b></a>) with an element-type
specified. If <a href="../ansicl/dictentr/open.htm"><b>open</b></a> is called
without an element-type specified, a simple-stream is created. If you
have code which does not specify an element-type, and you want a Gray
stream, specify <code>:element-type 'character</code>. Do note
that you cannot assume that system-created streams will be Gray
streams in version 6.1 or later.
</p><p id="7">
String output streams are always simple-streams even though both
<a href="../ansicl/dictentr/make-st0.htm"><b>make-string-output-stream</b></a> and
<a href="../ansicl/dictentr/with-out.htm"><b>with-output-to-string</b></a> accept
an <i>element-type</i> keyword argument. Both operators
create simple-streams regardless of whether a value is specified for
the <i>element-type</i> keyword argument or not.
</p><p id="8">
The transition from Gray streams to simple-streams should be easy and
transparent unless you have done extensive stream customization.
</p><p id="9">
The rest of this document is more or less unchanged from release 5.0.1.
It describes the Gray stream implementation.
</p><p id="10">
Symbols naming gray stream functionality are generally in
the <code>:excl</code> package.
</p><hr><hr><h2 id="11"><a name="gs-intro-1">1.0 Introduction to Gray streams in Allegro CL</a></h2>

<p id="12">
Streams in Common Lisp have always been first-class objects and the
stream type a first-class type. The inability of user code to
customize or extend stream behavior has been an unfortunate limitation
especially because the capabilities of the Common Lisp reader and
printer can only be obtained through the interface of a
stream. Suppose, for example, one wants to do normal Lisp printing
while performing some simple output character translations. The only
portable way to do this -- that is, without knowing about each
implementation's internal functions -- would be to rewrite the whole
printer from scratch for the single purpose of interposing a
translation function around every call to write-char and
write-string. This is clearly unacceptable. It should be possible to
customize a stream to add such simple behavior without reimplementing
large portions of Common Lisp. 
</p>

<p id="13">
When Common Lisp was first defined the Common Lisp Object System
(CLOS) was not yet conceived. Some portable stream construction
utilities were originally provided by the several "indirect"
stream types - synonym-stream, concatenated-stream, etc. - but these
provide only very limited kinds of customization. The subsequent ANSI
standard for Common Lisp includes CLOS, so that is now the obvious
mechanism to support user-customizable stream types. 
</p>

<p id="14">
Fairly late in the ANSI standardization process there was some
consideration of closifying streams. The most complete proposal was by
David N. Gray, then of Texas Instruments. Gray's proposal was only a
draft and it acknowledged a number of problems and omissions. It was
intended only as a starting point towards a complete specification.
However, Gray and the standardization committee soon decided it best
not to act because the change to the language would be large (causing
a lot of work for implementors) and also because there was little
actual experience with implementations of CLOS streams.  Despite the
feeling that it was not yet the time to adopt closified streams into
the language standard, most members of the committee feel that
redefining streams in terms of CLOS would be intrinsically worthwhile,
and experimentation with extensions should be encouraged. 
</p>

<p id="15">
The implementation of streams in Allegro CL from release 4.0 (on Unix)
through release 5.0.1 (on Unix and Windows) is based largely on the
X3J13 issue writeup entitled "STREAM-DEFINITION-BY-USER, Version
1, 22-Mar-89 by David N. Gray." Some of the text in this chapter
is taken from that proposal, but there are numerous additions,
modifications, clarifications, and comments specific to the Allegro
implementation. 
</p>

<p id="16">
An important feature of the Gray proposal is that it is upward
compatible with both the current language standard and earlier
implementations of Allegro CL. Programmers need not know anything
about closified streams unless they actually use its features. 
</p>

<p id="17">
The symbols naming classes and generic functions for the CLOS Gray
stream interface are exported from the <code>excl</code> package. 
</p>

<p id="18">
The existing Common Lisp I/O functions cannot be made generic because
in nearly every case the <i>stream</i> argument is
optional and therefore cannot be specialized. It is therefore
necessary to define new generic functions which are called internally
by the standard Common Lisp functions. In order to make the meaning as
obvious as possible, the names of the generic functions have been
formed by prefixing "stream-" to the corresponding
non-generic function (e.g. <a href="../ansicl/dictentr/terprifr.htm"><b>terpri</b></a> and <a href="operators/excl/stream-terpri.htm"><b>stream-terpri</b></a>). Note that for all of these
generic functions, the <i>stream</i> argument must be a stream object,
not <code>t</code> or <code>nil</code>.
</p>

<p id="19">
Having the generic input functions consistently return
<code>:eof</code> at end-of-file, with the higher-level
functions handling the <i>eof-error-p</i> and <i>eof-value</i>
arguments, simplifies the generic function interface and makes it more
efficient by not needing to pass through those arguments. Note that
the functions that use this convention can only return a character or
integer as a stream element, so there is no possibility of
ambiguity. 
</p>

<hr><hr><h2 id="20"><a name="gs-oop-1">2.0 Documenting object-oriented protocols</a></h2>

<p id="21">
There is much uncertainty in the industry about how to document an
object-oriented protocol. There are many ways to do it wrong, and it
is far from clear how to do it right.  Of course, problems with
documentation can often be ascribed to poor design of the underlying
system itself or else design based on assumptions that are not made
explicit. 
</p>

<p id="22">
For example, the default method for <b>stream-write-string</b> is
defined to do repeated calls to <b>stream-write-char</b>. The
character-translation problem mentioned at the beginning of
<a href="#gs-intro-1">Section 1.0 Introduction to Gray streams in Allegro CL</a> above could be implemented
minimally by defining an <code>:around</code> method for
<b>stream-write-char</b>, and everything ought to work. But what if
some stream specialization -- say, the
<code>excl::file-gray-stream</code> classes provided by the
implementation -- optimizes out the repeated calls to
<b>stream-write-char</b> in the interest of efficiency? The Gray
proposal is silent whether this would conform, but it is clear that
independently-written mixin classes will need to know each other's
assumptions about which publicly-specializable generic functions do or
do not call each other's publicly-specializable generic
function. There is also controversy whether there should be a default
method for a particular generic function or whether a method
definition should be required on specialized stream classes. The
difference is important if mixin methods normally do a
<b>call-next-method</b>, because the question is left open whether the
default method should be, should not be, or may optionally be
shadowed.
</p>

<p id="23">
In attempting to answer these questions over the years, we have
decided that this is not the best approach, and have opted to redesign
streams per documentation in <a href="streams.htm">streams.htm</a>.
</p>

<p id="24">
This said, there are several kinds of information this document needs
to specify:
</p>

<ol>
  <li id="25">The public superclasses (base and mixin) that may be used to define customized stream
    classes. </li>
  <li id="26">The generic functions that are defined on these classes, when and how they are called,
    and which ones call others. </li>
  <li id="27">The methods that are defined on these generic functions by the implementation, and what
    functionality is required if the user chooses to override any builtin methods. </li>
  <li id="28">Which builtin methods and built-in nongeneric functions call other public generic
    functions. </li>
  <li id="29">Which methods are required of any specialization of a class that are not provided by
    default methods on base classes. </li>
  <li id="30">Which public superclasses (if any) are required to be mixed into a user-customized
    class. </li>
</ol>

<p id="31">
It is a legitimate criticism that this chapter does not exhaustively
cover all these details. The legitimate excuse is that cogent,
defensible design decisions have not yet been made for all of them. In
particular, there is something of a trade-off between (5) and (6)
depending on whether one believes subclassing should be defined in
terms of class inheritance or in terms of generic function behavior
protocol. The new implementation described in
<a href="streams.htm">streams.htm</a> addresses these issues in a different
way.
</p>

<hr><hr><h2 id="32"><a name="gs-classes-1">3.0 Stream classes</a></h2>

<p id="33">
Two kinds of classes are mentioned here. Some are "mixin"
classes intended to be used as super classes of user-defined stream
classes. They are not intended to be directly instantiated; they
primarily provide places to hang default methods. Others are classes
actually instantiated by Allegro CL, for example, to service a call to
<b>open</b>.
</p>

<p id="34">
Those classes that are sufficiently complete to be meaningfully
instantiated are labeled as <b>Instantiable Class</b> in their
description pages while mixin classes are labeled simply as
<b>Class</b>. You can, of course, further subclass both kinds of
classes. Although most stream classes have their own description page,
the pages do not contain more information than is present in this
document and so we have not provided links.
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="95%">
  <tr>
    <td VALIGN="TOP" COLSPAN="2"><b>Table of mixin (non-instantiable) stream classes</b></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><b>Class</b></td>
    <td WIDTH="64%" VALIGN="TOP"><b>Notes</b></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><a href="classes/excl/fundamental-stream.htm"><code>fundamental-stream</code></a></td>
    <td WIDTH="64%" VALIGN="TOP"><small>This class is a subclass of 
    <code>stream</code> and of
    standard-object. <strong>streamp</strong> will 
    return true for an instance of any class
    that includes this.</small></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><a href="classes/excl/fundamental-input-stream.htm"><code>fundamental-input-stream</code></a></td>
    <td WIDTH="64%" VALIGN="TOP">A subclass of <code>fundamental-stream</code>. Its
    inclusion causes input-stream-p to return true. Note: any user-defined stream class that
    will do input must include this class. Bidirectional streams may be formed by including
    subclasses of both <code>fundamental-output-stream</code> and <code>fundamental-input-stream</code>.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>fundamental-output-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">A subclass of <code>fundamental-stream</code>. Its
    inclusion causes <strong>output-stream-p </strong>to return true. Note: any user-defined
    stream class that will do output must include this class. Bidirectional streams may be
    formed by including subclasses of both <code>fundamental-output-stream</code> and <code>fundamental-input-stream</code>.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>fundamental-character-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">A subclass of <code>fundamental-stream</code>. It
    provides a method for <strong>stream-element-type</strong> which returns <code>character</code>.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>fundamental-binary-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">A subclass of <code>fundamental-stream</code>. The
    Allegro CL implementation requires the <code>:element-type</code> keyword be provided to <strong>make-instance</strong>
    for streams of this class.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>fundamental-character-input-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">Includes <code>fundamental-input-stream</code> and <code>fundamental-character-stream</code>.
    Any user-defined stream class that will be used as an argument to <b>read</b> and friends
    must include this class.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>fundamental-character-output-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">Includes <code>fundamental-input-stream</code> and <code>fundamental-character-stream</code>.
    Any user-defined stream class that will be used as an argument to <b>print</b>, <b>format</b>,
    etc. must include this class.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>fundamental-binary-input-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">Includes <code>fundamental-input-stream</code> and <code>fundamental-binary-stream</code>.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>fundamental-binary-output-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">Includes <code>fundamental-output-stream</code> and <code>fundamental-binary-stream</code>.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP">
    <code>file-gray-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">See just below.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP">
    <code>excl::string-gray-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">See just below.</td>
  </tr>
</table>

<p id="35">
ANSI Common Lisp mandates these seven subtypes of type <a href="../ansicl/dictentr/stream.htm"><code>stream</code></a>: <a href="../ansicl/dictentr/file-str.htm"><code>file-stream</code></a>, <a href="../ansicl/dictentr/string-s.htm"><code>string-stream</code></a>, <a href="../ansicl/dictentr/echo-str.htm"><code>echo-stream</code></a>, <a href="../ansicl/dictentr/concaten.htm"><code>concatenated-stream</code></a>, <a href="../ansicl/dictentr/two-way-.htm"><code>two-way-stream</code></a>, <a href="../ansicl/dictentr/broadcas.htm"><code>broadcast-stream</code></a>, and <a href="../ansicl/dictentr/synonym-.htm"><code>synonym-stream</code></a>.  The first two are mixin classes
and the rest are instantiable classes. <a href="../ansicl/dictentr/file-str.htm"><code>file-stream</code></a> has two subclasses used in Allegro
CL: <code>excl::file-gray-stream</code> and
<code>excl::file-simple-stream</code>. <a href="../ansicl/dictentr/string-s.htm"><code>string-stream</code></a> also has two subclasses:
<code>excl::string-gray-stream</code> and
<code>excl::string-simple-stream</code>.
</p>

<p id="36">
Since in Allegro CL's implementation stream is a CLOS class (more
precisely, a subclass of <code>clos:standard-object</code>) then
the subtypes of <a href="../ansicl/dictentr/stream.htm"><code>stream</code></a> must
also be CLOS classes.
</p>

<p id="37">
The stream types other than <a href="../ansicl/dictentr/file-str.htm"><code>file-stream</code></a> and <a href="../ansicl/dictentr/string-s.htm"><code>string-stream</code></a> are sometimes called indirect
streams. The creator functions for these stream types
(<b>make-synonym-stream</b>, <b>make-echo-stream</b>,
<b>make-broadcast-stream</b>, <b>make-concatenated-stream</b>, and
<b>make-two-way-stream</b>) are unmodified from the standard Common
Lisp definitions.  These stream types represent an early (and awkward)
attempt in Common Lisp to obtain part of an extensible stream
facility. These stream types may not be defined in an image but the
module defining them, <em>streama</em>, will be loaded if it is
<strong>require</strong>'d or if <code>(find-class '<em>x</em>)</code>
is evaluated or <strong>make-<em>x</em></strong> is called (where
<em>x</em> is one of the classes). <em>streama</em> is also loaded
automatically if any of the Common Lisp slot-readers for one of these
streams is called. (<i>streama</i> stands for
<em>stream-ansi</em>. The other module is
<i>streamc</i>, which originally stood for
<em>stream-clos</em>, but that interpretation is no longer appropriate
since yet another stream module, <i>streamd</i>, is also
CLOS-based (so `c' and `d' are single letter file indentifiers
only). <i>streamd</i> implements simple-streams.
<i>streamc</i> is only loaded into a Lisp when gray
streams are used. Gray streams include the indirect streams --
synonym-stream, concatenated-stream, etc.)
</p>

<p id="38">
The generic function approach does not integrate very well with
indirect streams because the indirect stream classes cannot anticipate
the full set of generic functions that user code may want to define
over all streams in order to indirect them to the contained
streams. It is arguable that no purely automatic mechanism can handle
this, not even by defining a general method for
<code>no-applicable-method</code>. For example, consider the problem a
two-way-stream has choosing whether to pass to its input stream,
output stream, or both a call to a generic function about which it
knows nothing. For this reason there has been no attempt to extend or
make customizable the five indirect streams.
</p>

<p id="39">
The five indirect stream classes are instantiable, but at present
cannot successfully be instantiated other than with their standard
constructor functions (e.g. <b>make-synonym-stream</b>).
</p>

<p id="40">
The <code>excl::file-gray-stream</code> class is customizable
since it embodies the interface to the file
system. <code>excl::file-gray-stream</code> is a mixin not intended to be
instantiated directly. Its subclasses are normally instantiated by the
<b>open</b> function (see below) although it is also possible to
create them directly with <b>make-instance</b>.
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="95%">
  <tr>
    <td VALIGN="TOP" COLSPAN="2"><b>Table of instantiable stream classes</b></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><b>Class</b></td>
    <td WIDTH="64%" VALIGN="TOP"><b>Notes</b></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>cl:echo-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">See discussion above. Created with <b>cl:make-echo-stream</b>.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>cl:concatenated-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">See discussion above. Created with <b>cl:make-concatenated-stream</b>.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>cl:two-way-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">See discussion above. Created with <b>cl:make-two-way-stream</b>.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>cl:broadcast-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP">See discussion above. Created with <b>cl:make-broadcast-stream</b>.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>cl:synonym-stream</code>.</td>
    <td WIDTH="64%" VALIGN="TOP">See discussion above. Created with <b>cl:make-synonym-stream</b>.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>input-terminal-stream</code></td>
    <td WIDTH="64%" VALIGN="TOP" ROWSPAN="6">
    <p id="41">All six classes implement streams intended
    to support connection to sockets and input-output 
    devices that connect to a
    "stream" of data rather than a fixed file 
    stored in a file system. A normal call
    to <b>open</b> without the <code>:class</code> 
    argument extension always creates a file
    stream. The initial value of 
    <code>*terminal-io*</code> at startup is a 
    <code>bidirectional-terminal-stream</code>
    stream. One essential difference between these 
    two groups is evident for the bidirectional
    versions. The input and output sides of a bidirectional 
    file stream access the same data
    storage (e.g. on a disk) and so need to cooperate closely 
    about buffering when input and
    output operations are interleaved. They also share a single 
    file-position pointer. The
    input and output sides of a socket stream are completely 
    separate channels, and socket
    streams don't support file position at all.</p>
    <p id="42">These classes all require an <code>:fn-in</code>
    and/or <code>:fn-out</code> initialization argument 
    which should be a small integer that
    is a Unix file descriptor. (On Windows there is an 
    internal hidden translation between the
    small integers and actual Windows "handles".) 
    An error will be signaled if the
    required initializer is omitted. The input and output 
    file descriptor of a bidirectional
    stream may be and typically are the same.</p></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>output-terminal-stream</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>bidirectional-terminal-stream</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>input-binary-socket-stream</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>output-binary-socket-stream</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>bidirectional-binary-socket-stream</code></td>
  </tr>
</table>

<hr><hr><h2 id="43"><a name="gs-char-input-1">4.0 Generic functions for character input</a></h2>

<p id="44">
A character input stream class can be defined by including
<code>fundamental-character-input-stream</code> and defining methods
for the generic functions below. The builtin instantiable classes in
Allegro CL already have appropriate methods, of course. 
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="95%">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Generic function</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Notes</b></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-read-char.htm"><b>stream-read-char</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">This reads one character from 
    <em>stream</em>. </td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-unread-char.htm"><b>stream-unread-char</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream character</i></td>
    <td WIDTH="33%" VALIGN="TOP">Undoes the last call to 
    <a href="operators/excl/stream-read-char.htm"><b>stream-read-char</b></a>, as 
    in <strong>unread-char</strong>.
    Returns <code>nil</code>. </td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-read-char-no-hang.htm"><b>stream-read-char-no-hang</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">This is used to implement 
    <strong>read-char-no-hang</strong>.
    It returns either a character, or <code>nil</code> 
    if no input is currently available, or <code>:eof</code>
    if end-of-file is reached.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-peek-char.htm"><b>stream-peek-char</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Used to implement 
    <strong>peek-char</strong>; this
    corresponds to the case where the <em>peek-type</em> 
    argument is <code>nil</code>. It
    returns either a character or <code>:eof</code>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-listen.htm"><b>stream-listen</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Used by <strong>listen</strong>. 
    Returns true or false as
    there is or is not a character available to be read.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-read-line.htm"><b>stream-read-line</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Used by <strong>read-line</strong>. 
    A string is returned as
    the first value. The second value is true if the string 
    was terminated by end-of-file
    instead of the end of a line.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-clear-input.htm"><b>stream-clear-input</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Implements <strong>clear-input</strong> 
    for stream, returning
    <code>nil</code>.</td>
  </tr>
</table>

<hr><hr><h2 id="45"><a name="gs-char-output-1">5.0 Generic functions for character output</a></h2>

<p id="46">
A character output stream can be created by defining a class that
includes <a href="classes/excl/fundamental-character-output-stream.htm"><code>fundamental-character-output-stream</code></a> and defining
methods for the generic functions below. 
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="95%">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Generic function</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Notes</b></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-write-char.htm"><b>stream-write-char</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream character</i></td>
    <td WIDTH="33%" VALIGN="TOP">Writes <em>character</em> to 
    <em>stream</em> and returns <em>character</em>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-line-column.htm"><b>stream-line-column</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream </i></td>
    <td WIDTH="33%" VALIGN="TOP">This function returns the column 
    number where the next
    character will be written, or <code>nil</code>
    if that is not meaningful for <em>stream</em>.
    The first column on a line is numbered 0.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-start-line-p.htm"><b>stream-start-line-p</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">This is a predicate which 
    returns <code>t</code> if stream is
    positioned at the beginning of a line, else 
    returns <code>nil</code>. It is permissible to
    always return <code>nil</code>. This is called by 
    <a href="operators/excl/stream-fresh-line.htm"><b>stream-fresh-line</b></a>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-write-string.htm"><b>stream-write-string</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream string </i>&optional<i> 
    start end</i></td>
    <td WIDTH="33%" VALIGN="TOP">Implements <strong>write-string</strong>. 
    It writes string to
    stream, optionally delimited by <em>start</em> and 
    <em>end</em>, which default to 0 and <code>nil</code>.
    The <em>string</em> argument is returned.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-terpri.htm"><b>stream-terpri</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Writes an end of line, as for 
    <strong>terpri</strong>.
    Returns <code>nil</code>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-fresh-line.htm"><b>stream-fresh-line</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Implements <strong>fresh-line</strong>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-finish-output.htm"><b>stream-finish-output</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Implements 
    <strong>finish-output</strong></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-force-output.htm"><b>stream-force-output</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Implements 
    <strong>force-output</strong>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-advance-to-column.htm"><b>stream-advance-to-column</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream column</i></td>
    <td WIDTH="33%" VALIGN="TOP">Writes enough blank space so that 
    the next character will be
    written at the specified column. Returns true if the operation 
    is successful, or <code>nil</code> if it is not 
    supported for <em>stream</em>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-clear-input.htm"><b>stream-clear-input</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Implements <strong>clear-input</strong>.</td>
  </tr>
</table>

<hr><hr><h2 id="47"><a name="gs-bin-streams-1">6.0 Generic functions for binary streams</a></h2>

<p id="48">
A binary stream class can be defined by including either or both of
<a href="classes/excl/fundamental-binary-input-stream.htm"><code>fundamental-binary-input-stream</code></a> 
and
<a href="classes/excl/fundamental-binary-output-stream.htm"><code>fundamental-binary-output-stream</code></a>, 
and methods for one or
both of the following generic functions. 
If you create a binary stream
other than by using <b>open</b> you must also include a keyword
initialization argument for <code>:element-type</code>. 
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="95%">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Generic function</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Notes</b></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-read-byte.htm"><b>stream-read-byte</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Used by read-byte; returns either 
    an integer, or the symbol
    :eof if stream is at end-of-file.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-write-byte.htm"><b>stream-write-byte</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream integer</i></td>
    <td WIDTH="33%" VALIGN="TOP">Used by write-byte; writes the 
    integer to stream and returns
    the integer as the result.</td>
  </tr>
</table>

<hr><hr><h2 id="49"><a name="gs-efficient-seq-io-1">7.0 Functions for efficient input and output of sequences</a></h2>

<p id="50">
In the public comments on the first Draft Proposed ANSI Standard
several reviewers noted that except for the <b>write-string</b>
function, the language provided no means to request efficient
input-output on large blocks of data. The ANSI standard consequently
added two new functions to the language
<a href="../ansicl/dictentr/read-seq.htm"><b>read-sequence</b></a>
and
<a href="../ansicl/dictentr/write-se.htm"><b>write-sequence</b></a>.
</p>


<p id="51">
Allegro CL also defines generic function versions of these
functions. The nongeneric versions are implemented by calling these
generic functions. Methods are defined for these functions that handle
all legal calls, but not all legal calls will have highly efficient
execution. The existing methods will handle vector sequence arguments
efficiently, and will also handle start and end arguments
efficiently. The Allegro CL implementation will also accept and
efficiently transfer data to and from higher-dimension arrays in the
usual row-major order, although this is an extension to the language
and not defined by ANSI Common Lisp.
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="95%">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Generic function</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Notes</b></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-read-sequence.htm"><b>stream-read-sequence</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream sequence 
    </i>&optional<i> start end</i></td>
    <td WIDTH="33%" VALIGN="TOP">Destructively modifies 
    <i>sequence</i>, storing in it
    elements read from <i>stream</i>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-write-sequence.htm"><b>stream-write-sequence</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream sequence </i>&optional
    <i>start end</i></td>
    <td WIDTH="33%" VALIGN="TOP">Writes elements of 
    <i>sequence</i> to <i>stream</i>.</td>
  </tr>
</table>

<p id="52">
The definition of these functions does not permit the useful ability
to operate on sequence elements different from the stream element
type. Such capability would clearly be desirable. (It would, for
example, permit floats to be transferred efficiently, and allow an
application needing to store several different successive sequences of
different types to write them to a single stream and later reread the
data.) However, the behavior of any such operation would depend on bit
representations of objects in an implementation- and machine-dependent
way, and would be incompatible with the strict definition of
<strong>read-sequence</strong> and <strong>write-sequence</strong>,
which require automatic conversion of data to the correct element type
of the stream or sequence. Any such capability would therefore need to
be implemented by a different pair of functions. 
</p>

<hr><hr><h2 id="53"><a name="gs-creating-1">8.0 Creating streams</a></h2>

<p id="54">
Streams of arbitrary class may be constructed by an explicit call to
<strong>make-instance</strong>, but the Gray proposal did not address
how to customize the stream created by <strong>open</strong>.  We
define a simple interface here. The Gray proposal also omits mention
of constructor functions such as
<strong>make-string-input-stream</strong>,
<strong>make-string-output-stream</strong>, and their associated
macros such as <strong>with-output-to-string</strong>. However, there
is nothing these various operators do that can't be performed
explicitly by user code including a call to
<strong>make-instance</strong>. Unfortunately, Allegro CL's current
<code>string-gray-stream</code> subclasses do not (reliably) support
specialization or even independent instantiation by
<strong>make-instance</strong>. This is a bug in that some required
initialization is performed by the
<strong>make-string-...-stream</strong> function.  
</p>

<p id="55">
The <a href="../ansicl/dictentr/open.htm"><b>open</b></a> function has been
extended to take a <em>class</em> keyword argument. open passes this
argument to <strong>make-instance</strong> when it creates the stream,
and as with <strong>make-instance</strong>, the argument may be a
stream class object or a symbol naming such a class. If the
<em>class</em> argument is not supplied or is <code>nil</code>, <strong>open</strong> selects one of the
following built-in classes according to the <em>direction</em> and
<em>element-type</em> arguments:
</p>

<pre id="56">
excl::character-input-file-stream
excl::character-output-file-stream
excl::character-bidirectional-file-stream
excl::binary-input-file-stream
excl::binary-output-file-stream
excl::binary-bidirectional-file-stream
</pre>

<p id="57">
These classes all contain <code>excl::file-gray-stream</code>
and are variously mixed with
</p>

<pre id="58">
fundamental-character-input-stream
fundamental-character-output-stream
fundamental-binary-input-stream
fundamental-binary-output-stream
</pre>

<p id="59">
Although the <code>excl::file-gray-stream</code> subclasses
returned by <strong>open</strong> are all instantiable, at present
they require hidden initialization (for element-type upgrading, buffer
allocation, etc.) and therefore they should only be created using
<strong>open</strong>. It is fine to further specialize them, but you
are required to create instances of your specializations of these
stream classes using the <em>class</em> keyword argument to
<strong>open</strong> rather than by calling
<strong>make-instance</strong> yourself.
</p>
<p id="60">
On Unix platforms, <strong>open</strong> will select a terminal-stream
subclass rather than a <code>excl::file-gray-stream</code>
subclass if it detects the argument file is a character special device
or a named pipe.  See <a href="socket.htm">socket.htm</a> for more
information about creating sockets in Allegro CL.
</p>


<hr><hr><h2 id="61"><a name="gs-misc-1">9.0 Miscellaneous stream functions</a></h2>

<p id="62">
The following functions are also defined (or in the case of standard
Common Lisp functions, extended). 
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="95%">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Generic function</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Notes</b></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="../ansicl/dictentr/close.htm"><b>close</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream &key abort</i></td>
    <td WIDTH="33%" VALIGN="TOP">The existing function <b>close</b> is 
    redefined to be a generic function but otherwise behaves as 
    required by standard Common Lisp.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="../ansicl/dictentr/open-str.htm"><b>open-stream-p</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">This function is made generic. 
    A default method is provided
    by class fundamental-stream which returns true if close 
    has not been called on stream.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="../ansicl/dictentr/streamp.htm"><b>streamp</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>object</i></td>
    <td WIDTH="33%" VALIGN="TOP" ROWSPAN="3">The original proposal 
    allowed but did not require
    these three existing predicates to be implemented as generic 
    functions. In Allegro CL,
    streamp is not a generic function in order not to impact 
    speed of opencoded type
    dispatching, but the other two functions are made generic. 
    Normally, the default methods
    provided by classes fundamental-input-stream and 
    fundamental-output-stream are sufficient.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="../ansicl/dictentr/input-st.htm"><b>input-stream-p</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="../ansicl/dictentr/input-st.htm"><b>output-stream-p</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="../ansicl/dictentr/stream-2.htm"><b>stream-element-type</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">This existing function is made generic, 
    but otherwise behaves
    the same. Class fundamental-character-stream provides a 
    default method which returns
    character.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-yes-or-no-p.htm"><b>stream-yes-or-no-p</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i> &optional 
    <i>format-string</i> &rest <i>args</i></td>
    <td WIDTH="33%" VALIGN="TOP" ROWSPAN="2">The generic function 
    analogue of <b>cl:yes-or-no-p</b>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-y-or-n-p.htm"><b>stream-y-or-n-p</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i> &optional 
    <i>format-string</i> &rest <i>args</i></td>
    <td WIDTH="33%" VALIGN="TOP" ROWSPAN="2">The generic function 
    analogue of <b>cl:y-or-n-p</b>.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-input-fn.htm"><b>stream-input-fn</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP" ROWSPAN="2">These accessors return 
    the input or output file
    descriptor for streams that have them, or 
    <code>nil</code>. For some streams the input and
    output file descriptors may be the same.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-output-fn.htm"><b>stream-output-fn</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
  </tr>
</table>

<p id="63">
The following function is used by the pretty printer to determine the
output width to be used while pretty printing. Actually, the pretty
printer uses the first of the following three values that return true.
</p>

<ol>
  <li id="64">the value of <a href="../ansicl/dictentr/print-ri.htm"><code>*print-right-margin*</code></a></li>
  <li id="65">the value returned by <a href="operators/excl/stream-output-width.htm"><b>stream-output-width</b></a></li>
  <li id="66">the value of <code>excl::*default-right-margin*</code>, 
    an internal variable set when
    Lisp starts up to the apparent width of 
    <code>cl:*terminal-io*</code>, if it can be
    determined, and to 72 otherwise.</li>
</ol>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="95%">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Generic function</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Notes</b></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="operators/excl/stream-output-width.htm"><b>stream-output-width</b></a></td>
    <td WIDTH="33%" VALIGN="TOP"><i>stream</i></td>
    <td WIDTH="33%" VALIGN="TOP">Returns an integer width of stream 
    or <code>nil</code>. The
    default method for this function returns 
    <code>nil</code> for all streams.</td>
  </tr>
</table>

</body><hr><p id="2"><small>Copyright (c) 1998-2017, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page was not revised from the 10.0 page.</small><br><small>Created 2017.2.15.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/gray-streams.htm">10.0 version</a></td></tr></table></html>