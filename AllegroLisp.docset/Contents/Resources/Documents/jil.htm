<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"> <title>JiL - Java in Lisp</title></head><link rel="stylesheet" href="acldoc-styles.css" type="text/css"><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.0</b><br><small><a href="introduction.htm#updates-s">Unrevised from 9.0 to 10.0.</a></small><br><a href="http://www.franz.com/support/documentation/9.0/doc/jil.htm">9.0 version</a></td></tr></table><h1 id="2">JiL - Java in Lisp</h1><p id="3">This document contains the following sections:</p><a href="#intro-1">1.0 Introduction</a><br><a href="#lexical-1">2.0 Lexical items</a><br><a href="#types-1">3.0 Types</a><br><a href="#files-1">4.0 Files</a><br><a href="#def-java-class-1">5.0 def-java-class</a><br><a href="#def-java-method-1">6.0 def-java-method</a><br><a href="#special-symbols-1">7.0 Special Symbols</a><br><a href="#special-forms-1">8.0 Special Forms</a><br><a href="#functions-1">9.0 Functions</a><br><a href="#macros-1">10.0 macros</a><br><a href="#package-1">11.0 package</a><br><a href="#import-1">12.0 import</a><br><a href="#def-java-macro-1">13.0 def-java-macro</a><br><a href="#jil-compiler-1">14.0 Using the jil compiler</a><br><a href="#ts-example-1">15.0 Test suite example</a><br><a href="#tictactoe-example-1">16.0 TicTacToe example</a><br><hr><hr><h2 id="4"><a name="intro-1">1.0 Introduction</a></h2>


<p id="5">
Java in Lisp (jil) is a language for writing programs to run on the
Java Virtual Machine (jvm). It uses a syntax familiar to Lisp
programmers. <strong>jil</strong> programs can be generated by
Lisp programs. This allows a Lisp program to migrate
functionality over to a jvm.
</p>
<h2 id="6">
Loading the jil module
</h2>
<p id="7">
When you use <strong>jil</strong>, first load the jil module into Lisp
by evaluating:
</p>
<pre id="8">
<b>(require :jil)</b>
</pre>

<hr><hr><h2 id="9"><a name="lexical-1">2.0 Lexical items</a></h2>

<p id="10">
Java is a case sensitive language and thus <strong>jil</strong> is as
well. <strong>Jil</strong> can only be loaded and run in an Allegro
Common Lisp in <strong>modern</strong> mode (also known as
<strong>:case-sensitive-lower</strong> mode). See
<a href="case.htm">case.htm</a>.
</p>

<p id="11">
All <strong>jil</strong> source is read into the package
<code>javatools.jil.source</code> (with a nickname
<code>jvs</code>). This page <em>uses</em> only one
package: the <code>common-lisp-user</code> package.
</p>

<p id="12">
When a <strong>jil</strong> program is read, the normal Lisp reader
does the work, thus everything must be valid Lisp syntax. This also
means that normal Lisp reader macros are in effect (e.g. #x3ff4
or #.(+ 234 4) will work). Also the comment characters are
semicolon and #| followed by |#.
</p>

<p id="13">
At present <strong>jil</strong> is strictly an ASCII system -- it does
not permit Unicode characters outside the 8-bit Ascii range to be
expressed.
</p>

<p id="14">
Identifiers in Java are more restricted than they are in Lisp. A Java
identifier begins with a letter and contains letters or numbers. The
underscore and dollar sign characters are considered letters. The
<strong>jil</strong> programmer would be advised to follow that
restriction on naming identifiers, although the only restriction
<strong>jil</strong> places on identifiers is that they cannot contain
a period.
</p>

<hr><hr><h2 id="15"><a name="types-1">3.0 Types</a></h2>

<p id="16">
In <strong>jil</strong> all values have a type. Types are denoted by
the following expressions (note again that symbols mentioned are in
the <strong>jvs</strong> package or inherited from the
<strong>common-lisp</strong> package).
</p>

<h3 id="17">Primitive Types</h3>

<ul>
<li id="18">
<code>byte</code>
</li>
<li id="19">
<code>char</code>
</li>
<li id="20">
<code>short</code>
</li>
<li id="21">
<code>int</code>
</li>
<li id="22">
<code>long</code>
</li>
<li id="23">
<code>float</code>
</li>
<li id="24">
<code>double</code>
</li>
<li id="25">
<code>boolean</code>
</li>
<li id="26">
<code>void</code>
</li>
</ul>

<h3 id="27">
Reference types
</h3>

<ul>
<li id="28">
<code><em>Classname</em></code>
</li>
</ul>

<h3 id="29">
Array types
</h3>

<ul>
<li id="30">
<code>(array type)</code> [same as <code>(array type *)</code>]
</li>
<li id="31">
<code>(array type *)</code>
</li>
<li id="32">
<code>(array type * ...)</code>
</li>
</ul>


<hr><hr><h2 id="33"><a name="files-1">4.0 Files</a></h2>

<p id="34">
A file containing jil code should contain zero or more <strong>import
</strong>forms, an optional <strong>package </strong>form, a
<strong>def-java-class</strong> form followed by a sequence of zero or
more <strong>def-java-method</strong> forms.
<strong>def-java-macro</strong> forms can be placed anywhere in the
file.
</p>

<p id="35">
The name of the file should be <i>foo.jil</i> where
'foo' is the name of the class defined in the file.
</p>

<hr><hr><h2 id="36"><a name="def-java-class-1">5.0 def-java-class</a></h2>

<p id="37">
In jil, as in java, everything is class-centric. You
define a class and then methods that are associated with that
class. This is also how you define interfaces, which for the
purposes of this function are so similar to classes, that we'll just
use the term class to refer to classes and interfaces.
</p>
<p id="38">
We give the general description of <b>def-java-class</b> forms and
then some specific examples. But <b>def-java-class</b> is not a
defined operator. You cannot evaluate these for at a Lisp
prompt. Instead, they should be in a file which you then compile
with <a href="operators/jil/jcomp-file.htm"><b>jcomp-file</b></a>. See the example
in <a href="#ts-example-1">Section 15.0 Test suite example</a>
and <a href="#tictactoe-example-1">Section 16.0 TicTacToe example</a> below.
</p>
<p id="39">
The symbol name <b>def-java-class</b> is also defined in
the <code>net.jlinker</code> package
described <a href="jlinker.htm">jlinker.htm</a>. That use, which does define
an operator, has no relation to the <b>jil</b> module.
</p>

<p id="40">
The form of a def-java-class is
</p>

<pre id="41">
(def-java-class class-name (superclass superinterface ...)
      flag ...
      (field-desc ...)
      [:methods (name (arg1 ..) expr) ...]
      [:classes (name (superclass ...) [flag ...] (field-desc ...)) ... ]
)
</pre>

<p id="42">
The <strong>class-name</strong> is an identifier (which is a Lisp
symbol). You can use a fully qualified name such as
<code>com.franz.jkf.myclass</code>, but you're more likely to
want to set the package to "com.franz.jkf" and just use the
class-name myclass in the <strong>def-java-class</strong> form. Every
class you define will have one superclass and zero or more
superinterfaces. If no superclass is given, then the superclass used
is <strong>java.lang.Object</strong>.
</p>

<p id="43">
<strong>flag</strong>s are used to specify attributes of the
class. Flags are also used to specify attributes of fields in a
class and attributes of methods. The table below describes
all of the flags and which flags can be used to describe classes,
fields and methods:
</p>

<table border="1" width="53%">
  <tr>
    <td width="33%"><big><big><big>Flag</big></big></big></td>
    <td width="21%"> </td>
    <td width="23%"> </td>
    <td width="29%"> </td>
  </tr>
  <tr>
    <td width="33%"><strong>:abstract</strong></td>
    <td width="21%">class</td>
    <td width="23%"> </td>
    <td width="29%">method</td>
  </tr>
  <tr>
    <td width="33%"><strong>:final</strong></td>
    <td width="21%">class</td>
    <td width="23%">field</td>
    <td width="29%">method</td>
  </tr>
  <tr>
    <td width="33%"><strong>:interface</strong></td>
    <td width="21%">class</td>
    <td width="23%"> </td>
    <td width="29%"> </td>
  </tr>
  <tr>
    <td width="33%"><strong>:native</strong></td>
    <td width="21%"> </td>
    <td width="23%"> </td>
    <td width="29%">method</td>
  </tr>
  <tr>
    <td width="33%"><strong>:private</strong></td>
    <td width="21%"> </td>
    <td width="23%">field</td>
    <td width="29%">method</td>
  </tr>
  <tr>
    <td width="33%"><strong>:protected</strong></td>
    <td width="21%"> </td>
    <td width="23%">field</td>
    <td width="29%">method</td>
  </tr>
  <tr>
    <td width="33%"><strong>:public</strong></td>
    <td width="21%">class</td>
    <td width="23%">field</td>
    <td width="29%">method</td>
  </tr>
  <tr>
    <td width="33%"><strong>:static</strong></td>
    <td width="21%">Inner class only</td>
    <td width="23%">field</td>
    <td width="29%">method</td>
  </tr>
  <tr>
    <td width="33%"><strong>:synchronized</strong></td>
    <td width="21%"> </td>
    <td width="23%"> </td>
    <td width="29%">method</td>
  </tr>
  <tr>
    <td width="33%"><strong>:transient</strong></td>
    <td width="21%"> </td>
    <td width="23%">field</td>
    <td width="29%"> </td>
  </tr>
  <tr>
    <td width="33%"><strong>:volatile</strong></td>
    <td width="21%"> </td>
    <td width="23%">field</td>
    <td width="29%"> </td>
  </tr>
</table>


<p id="44">
Following the zero or more flags is a list of field
descriptions. The format of a <strong>field-desc</strong> is a list
beginning with the field name followed optionally by a sequence of
keyword value pairs.
</p>

<pre id="45">
(field-name :type type  :initform expression :flags (flag1 ....))
</pre>

<p id="46">
The <strong>initform</strong> expression, if given, will be evaluated
inside the default constructor for this class.
</p>

<p id="47">
The table above shows the <strong>flag</strong> values valid inside
this field description.
</p>

<p id="48">
It is possible to list some of the methods of the class in the
<strong>def-java-class</strong> form by putting them after a
<strong>:methods</strong> specifier. This is normally not
done for top level classes but it is necessary to use this syntax when
defining methods for inner classes.
</p>

<p id="49">
It is possible to define inner classes by specifying class
descriptions after the <strong>:classes</strong> keyword.
</p>

<p id="50">
Here are some sample class definitions:
</p>

<pre id="51">
(def-java-class htest ()
    ; simple one slot public class
    :public 
    ((x :type int))

   )

(def-java-class zip (nil intx inty)
    ; interface with one slot (which must be static in an interface).
    ; by specifying nil for the superclass, we get 
    ; the default (java.lang.Object)
    :public :interface
    ((teeth :type int :initform 20 :flags (:static)))
    :methods
    (brush () :void)  ; normal method
    (teeth-count () :int )

   )
</pre>

<hr><hr><h2 id="52"><a name="def-java-method-1">6.0 def-java-method</a></h2>

<p id="53">
This form is used to create a method that is associated with the
class being defined in the same file.
</p>

<pre id="54">
(def-java-method method-name ((arg1 type)... (argn type)) return-type
        flag ...
        <strong>[</strong>(:throws exception-class ...)<strong>]</strong>
        expr ....
)
</pre>

<p id="55">
The set of allowable flags is given in the table above.
</p>

<p id="56">
The body of a method is a sequence of expressions.
The allowable
expressions are described below.
While java is a statement based language, <strong>jil</strong>
is, like Lisp, an expression based language.
In <strong>jil</strong> every
expression returns zero or one value.
The value of the last expression in the
body of a method is the value returned by the method.
</p>

<hr><hr><h2 id="57"><a name="special-symbols-1">7.0 Special Symbols</a></h2>


<p id="58">
A few symbols have special meaning inside a <strong>jil</strong> method.
</p>

<ul>
<li id="59">
<strong>null</strong> - This corresponds to the java 
<strong>null</strong> value which is the universal reference 
pointer that points to no object.
</li>
<li id="60">
<strong>nil</strong> - This corresponds to the java 
<strong>false</strong> value.
</li>
<li id="61">
<strong>t</strong> - This corresponds to the java 
<strong>true</strong> value.
</li>
</ul>

<hr><hr><h2 id="62"><a name="special-forms-1">8.0 Special Forms</a></h2>

<p id="63">
The special forms in Jil are:
</p>

<ul>
<li id="64">
<a href="#progn-sf-0">progn</a>
</li>
<li id="65">
<a href="#block-sf-0">block</a>
</li>
<li id="66">
<a href="#return-from-sf-0">return-from</a>
</li>
<li id="67">
<a href="#ref-sf-0">ref</a>
</li>
<li id="68">
<a href="#if-sf-0">if</a>
</li>
<li id="69">
<a href="#and-sf-0">and</a>
</li>
<li id="70">
<a href="#or-sf-0">or</a>
</li>
<li id="71">
<a href="#handler-case-sf-0">handler-case</a>
</li>
<li id="72">
<a href="#unwind-protect-sf-0">unwind-protect</a>
</li>
<li id="73">
<a href="#throw-sf-0">throw</a>
</li>
<li id="74">
<a href="#let-sf-0">let</a>
</li>
<li id="75">
<a href="#setq-sf-0">setq</a>
</li>
<li id="76">
<a href="#lt-sf-0">&lt;, &lt;=, =, &gt;=, &gt;</a>
</li>
<li id="77">
<a href="#plus-etc-sf-0">+, *, /, -</a>
</li>
<li id="78">
<a href="#ltlt-sf-0">&lt;&lt;</a>
</li>
<li id="79">
<a href="#gtgt-sf-0">&gt;&gt;</a>
</li>
<li id="80">
<a href="#gtgtgt-sf-0">&gt;&gt;&gt;</a>
</li>
<li id="81">
<a href="#logand-etc-sf-0">logand, logior, logxor</a>
</li>
<li id="82">
<a href="#instanceof-sf-0">instanceof</a>
</li>
</ul>


<h3 id="83"><a name="progn-sf-0">progn</a></h3>

<pre id="84">
(progn expr ...)
</pre>

<p id="85">
Evaluate each expression in sequence and return the value of the last one
</p>


<h3 id="86"><a name="block-sf-0">block</a></h3>

<pre id="87">
(block tagname expr ....)
</pre>

<p id="88">
Like <a href="../ansicl/dictentr/progn.htm"><b>progn</b></a> except that this
sets up a tag for use by <a href="../ansicl/dictentr/return-f.htm"><b>return-from</b></a>.
</p>

<h3 id="89"><a name="return-from-sf-0">return-from</a></h3>

<pre id="90">
(return-from name [result])
</pre>

<p id="91">
Like <a href="../ansicl/dictentr/return-f.htm"><b>return-from</b></a>, jumps out of
a <a href="#block-sf-0">block</a>
named <i>name</i>, returning <i>result</i>
if supplied or <code>nil</code>.
</p>

<h3 id="92"><a name="ref-sf-0">ref</a></h3>

<pre id="93">
(ref expr slotname1 <strong>[ </strong>... slotnameN <strong>]</strong>)

(ref classname static-slotname <strong>[ </strong>slotname1 ... slotnameN <strong>]</strong>)

(ref package1 ... packageN classname static-slotname <strong>[ </strong>slotname1 ... slotnameN <strong>] </strong>)
</pre>

<p id="94">
The <strong>ref</strong> form is used to
</p>

<ul>
<li id="95">
navigate through a sequence of objects in order to return a slot value.
</li>
<li id="96">
retrieve a <strong>static</strong> slot of a class and then navigate through that value.
</li>
<li id="97">
name a method to be called
</li>
</ul>

<p id="98">
A shorthand for this form can be used in many cases. In
<strong>jil</strong> the expression <code>foo.bar.baz</code> is
converted into <code>(ref foo bar baz)</code> by
<strong>jil</strong> compiler. This dot convention only works
when in Java you have a sequence of symbols separated by dots.
For example there is no way to use the dot convention to
write <code>(ref (myfun x) slot)</code>.
</p>


<h3 id="99"><a name="if-sf-0">if</a></h3>

<pre id="100">
(if expr true-expr <strong>[</strong> false-expr <strong>]</strong> )
</pre>

<p id="101">
This is just like the Common Lisp <a href="../ansicl/dictentr/if.htm"><b>if</b></a> special form. In
Java conditionals only test boolean values. This is not the case in
<strong>jil</strong> which is more like Lisp in this regard. In
<strong>jil</strong> the following values are considered true:
</p>

<ul>
<li id="102">
the <strong>true</strong> boolean object
</li>
<li id="103">
a non-zero number
</li>
<li id="104">
a non-<strong>null</strong> instance
</li>
<li id="105">
an array of anything
</li>
</ul>

<p id="106">
The following things are considered false:
</p>

<ul>
<li id="107">
the <strong>false</strong> boolean object
</li>
<li id="108">
a zero number
</li>
<li id="109">
the <strong>null</strong> instance
</li>
<li id="110">
a conditional expression where the predicate isn't satisfied and there
is no <strong>else</strong> clause.
</li>
</ul>


<h3 id="111"><a name="and-sf-0">and</a></h3>

<pre id="112">
(and expr ....)
</pre>

<p id="113">
This is like the Common Lisp <strong>and</strong> form except that the
result is always the boolean <strong>true</strong> or
<strong>false</strong> value. It never returns the last value of the
form.
</p>

<h3 id="114"><a name="or-sf-0">or</a></h3>


<pre id="115">
(or expr ...)
</pre>

<p id="116">
This is like the Common Lisp <strong>or</strong> form except that the
result is always the boolean <strong>true</strong> or
<strong>false</strong> value. It never returns the value of any
subexpression in the form.
</p>

<h3 id="117"><a name="handler-case-sf-0">handler-case</a></h3>

<pre id="118">
(handler-case hexpr (exception-class (var) expr ...) ...)
</pre>

<p id="119">
This is how the Java<strong> try...except</strong> is expressed in
<strong>jil</strong>. While <strong>hexpr</strong> is evaluated,
if an exception is raised that is a subclass of one of the
<strong>exception-class</strong>es given in this form, then that
exception object is bound to the <strong>var</strong> and the control
continues in the body of the exception handler.
</p>

<h3 id="120"><a name="unwind-protect-sf-0">unwind-protect</a></h3>

<pre id="121">
(unwind-protect protected-expr expr1 .... exprN)
</pre>

<p id="122">
This is how the java <strong>try...finally</strong> is expressed in
<strong>jil</strong>. While <strong>protected-expr</strong> is
evaluated a condition handler is setup so that any attempt to throw
control out of the <strong>protected-expr</strong> will result in
control going instead to <strong>expr1</strong> and the following
forms. If all the forms up to and including
<strong>exprN</strong> evaluate, then the throw that caused control to
reach <strong>expr</strong> is continued.
</p>

<h3 id="123"><a name="throw-sf-0">throw</a></h3>

<pre id="124">
(throw expr)
</pre>

<p id="125">
The expr should evaluate to an object that is a subclass of
java.lang.Exception. The program resumes execution
at the innermost handler for the exception being thrown.
</p>

<h3 id="126"><a name="let-sf-0">let</a></h3>

<pre id="127">
(let ((var <strong>[</strong> initform <strong>[</strong> type <strong>]]</strong>) ....) expr ...)
</pre>

<p id="128">
A set of local variables are bound during the evaluation of a sequence
of expressions.  If the <strong>initform</strong> is not given
then it is assumed to be 0 (zero). If the
<strong>type</strong> is not given, then it is assumed to be the type
of the <strong>initform</strong>. In this case the type of
a number is the most restrictive type that describes it.
</p>

<h3 id="129"><a name="setq-sf-0">setq</a></h3>

<pre id="130">
(setq place expr ... ...)
</pre>

<p id="131">
Like the Common Lisp <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a> this stores values
not only in local variables but in slots of objects (described by
<strong>ref </strong>expressions). The value of the
<strong>setq</strong> expression is the value of the last expression
stored.
</p>


<h3 id="132"><a name="lt-sf-0"><b>&lt;, &lt;=, =, &gt;=, &gt;</b></a></h3>

<pre id="133">
(&lt;  expr1 expr2 ...)
(&lt;= expr1 expr2 ...)
(=  expr1 expr2 ...)
(&gt;= expr1 expr2 ...)
(&gt;  expr1 expr2 ...)
</pre>

<p id="134">
These are a mixture of the Common Lisp functions by the same names and
the <strong>and</strong> special form. They compute a
relation between numbers yet short circuit evaluation as soon as they
determine that the answer is false. The return value is the boolean
value <strong>true</strong> or <strong>false</strong>.
</p>

<h3 id="135"><a name="plus-etc-sf-0"><b>+, *, /, -</b></a></h3>

<pre id="136">
(+ <strong>[ </strong>expr ... <strong>]</strong>)
(* <strong>[</strong> expr ... <strong>]</strong>)
(/ <strong>[</strong> expr ... <strong>]</strong>)
(- <strong>[</strong> expr ... <strong>]</strong>)
</pre>

<p id="137">
These take zero or more arguments and compute the appropriate function
over the argument values. The <strong>expr</strong>s are only
evaluated as needed before the function is applied to them. This
means that an arithmetic exception may be signaled before all of the
arguments have been evaluated.
</p>

<h3 id="138"><a name="ltlt-sf-0"><b>&lt;&lt;</b></a></h3>

<pre id="139">
(&lt;&lt; value shiftamount)
</pre>

<p id="140">
shift the value left by the given shift amount. The value should be a
type that can be widened to an <strong>int</strong> or a
<strong>long</strong>. The result of the shift will either be an
<strong>int</strong> or a <strong>long</strong> depending on the type
of the value. The low bits of the shiftamount are used to
determine the number of places left the value is shifted. If an
<strong>int</strong> will be shifted then the shiftamount is <b>and</b>ed
with #x1f and that value is the shift amount. If value is a
<strong>long </strong>then the shiftamount is <b>and</b>ed with
#x3f. The resulting shift amount is thus always a
non-negative number.
</p>

<h3 id="141"><a name="gtgt-sf-0"><b>&gt;&gt;</b></a></h3>

<pre id="142">
(&gt;&gt; value shiftamount)
</pre>

<p id="143">
shift the value right by the given shiftamount, copying the sign bit
into vacated bits.  This is an arithmetic shift. See the
description for &lt;&lt; to see how the shiftamount value is modified
before it is used
</p>

<h3 id="144"><a name="gtgtgt-sf-0"><b>&gt;&gt;&gt;</b></a></h3>

<pre id="145">
(&gt;&gt;&gt; value shiftamount)
</pre>

<p id="146">
shift the value right by the given shiftamount, copying zero into
vacated bits.  This is a logical shift. See the description for
&lt;&lt; to see how the shiftamount value is modified before it is
used.
</p>

<h3 id="147"><a name="logand-etc-sf-0">logand, logior, logxor</a></h3>

<pre id="148">
(logand expr ...)
(logior expr ...)
(logxor expr ...)
</pre>

<p id="149">
perform the bitwise operation on the expressions (which must be of
type <strong>int</strong> or <strong>long</strong>)
</p>

<h3 id="150"><a name="instanceof-sf-0">instanceof</a></h3>


<pre id="151">
(instanceof expr type)
</pre>

<p id="152">
returns true if the object that is the value of the
<strong>expr</strong> is an instance of the named
<strong>type</strong>. The expression
<strong>expr</strong> must return a reference to an object, not a
primitive type such as int. The <strong>type</strong> is
not quoted.
</p>
<p id="153">
Thus, <code> (instanceof x
String)</code> tests if <code>x</code> points to a
<code>String</code> object.
</p>

<hr><hr><h2 id="154"><a name="functions-1">9.0 Functions</a></h2>

<p id="155">
The functions, <a href="#not-fun-0">not</a> and <a href="#not-fun-0">new</a>.
</p>

<h3 id="156"><a name="not-fun-0">not</a></h3> and



<pre id="157">
(not expr)
</pre>

<p id="158">
Compute the boolean value that is the inverse of the given value,
where the description of what is considered true and false is
described with the <a href="#if-sf-0">if</a> special form.
</p>

<h3 id="159"><a name="new-fun-0">new</a></h3>


<pre id="160">
(new type expr ...)
</pre>

<p id="161">
Allocate a new object of the given type and call its constructor
passing the value of the <strong>expr</strong>s as arguments.
</p>

<p id="162">
The type is normally a symbol. It can also be an anonymous type
description.
</p>

<p id="163">
The form of an <strong>anonymous type description</strong> is
</p>

<pre id="164">
(:class superclass (superinterface ...) [flag ...] (field-desc
...) [:methods method-desc] [:classes class-desc])
</pre>

<p id="165">
Essentially it looks just like a <strong>def-java-class</strong> form
except that instead of naming the class you name the class and/or
interfaces that the class inherits from. If the anonymous class
is to inherit from only an interface and no class then that interface
should be put in the <strong>superclass</strong> spot, i.e. 
<code>(:class superint () .....)</code>.
</p>


<hr><hr><h2 id="166"><a name="macros-1">10.0 macros</a></h2>


<p id="167">
Users can add macros to the <strong>jil</strong> compiler with
<strong>def-java-macro</strong>. The macros <a href="#cond-mac-0">cond</a>, <a href="#ifstar-mac-0">if*</a>, and <a href="#splus-mac-0">s+</a> are
already defined:
</p>

<h3 id="168"><a name="cond-mac-0">cond</a></h3>

<pre id="169">
(cond  (pred-expr value-expr1 ... value-exprN) ... <strong>[</strong>(t value-expr1 .. value-exprN) <strong>]</strong>)
</pre>

<p id="170">
This is very close to the Common Lisp <a href="../ansicl/dictentr/cond.htm"><b>cond</b></a> form except that one type of clause is not
permitted: that is the clause where the value of the predicate is the
value returned (if it is true).
</p>

<h3 id="171"><a name="ifstar-mac-0">if*</a></h3>

<pre id="172">
(if* pred then expr1 ... exprN <strong> [ </strong>elseif pred then expr1 .... exprN <strong>]</strong> ... <strong>[ </strong>else expr1 .... exprN <strong>] </strong>)
</pre>

<p id="173">
The <a href="operators/excl/if_s.htm"><b>if*</b></a> macro from Allegro
Common Lisp. This is designed to do the work of the Common Lisp
<a href="../ansicl/dictentr/if.htm"><b>if</b></a>, <a href="../ansicl/dictentr/whenunle.htm"><b>when</b></a> and <a href="../ansicl/dictentr/whenunle.htm"><b>unless</b></a> forms and offer greater program
readability.
</p>

<h3 id="174"><a name="splus-mac-0">s+</a></h3>

<pre id="175">
(s+ expr1 expr2 ... exprN)
</pre>

<p id="176">
In Java the + operator is overloaded to do string concatenation.
We chose not to do this in JiL. Instead we offer the
<strong>s+</strong> macro that generates code just like the Java
compiler when it determines that + must do string concatenation.
Each expression can return any type of value and as long
as there is an appropriate <strong>append</strong> method in the class
<strong>java.lang.StringBuffer</strong> that accepts that type of
value.
</p>

<hr><hr><h2 id="177"><a name="package-1">11.0 package</a></h2>


<p id="178">
A <strong>jil</strong> source file can contain a package form
</p>

<pre id="179">
(package packagename)
</pre>

<p id="180">
This form should appear before the class and any methods are
defined. It specifies the package prefix for the class.
Failure to include a package form in a file sets the package prefix to
the empty string.
</p>

<hr><hr><h2 id="181"><a name="import-1">12.0 import</a></h2>


<p id="182">
The import form specifies a class or set of classes which should be
capable of being referenced without the full package qualification.
There can be zero or more import forms in a <strong>jil</strong>
source file.
</p>

<pre id="183">
(import classname)
(import packagename.*)
</pre>

<p id="184">
The first form imports just the single class, the second imports all
classes in the given package (but not subpackages of the given
package).
</p>

<p id="185">
Just as in Java, there is an implicit import done of
<code>java.lang.*</code> before a <strong>jil</strong> file is
compiled.
</p>

<hr><hr><h2 id="186"><a name="def-java-macro-1">13.0 def-java-macro</a></h2>


<p id="187">
This defines a macro for use in compiling <strong>jil</strong>
expressions only. The form is identical to Lisp's <a href="../ansicl/dictentr/defmacro.htm"><b>defmacro</b></a>:
</p>

<pre id="188">
(def-java-macro name (arg ...)  expr ...)
</pre>


<hr><hr><h2 id="189"><a name="jil-compiler-1">14.0 Using the jil compiler</a></h2>

<p id="190">
First you must install a Java Software Development Toolkit or Java
Runtime on your machine. <strong>Jil</strong> needs access to the jar
file of standard Java classfiles (which define such classes as
<strong>java.lang.Object</strong>). You tell jil where to find the
java classfiles either by giving a non-<code>nil</code>
value to <a href="variables/jil/s_jil-classpath_s.htm"><code>*jil-classpath*</code></a> or by setting the
CLASSPATH environment variable. Newer java development toolkits don't
require you to set CLASSPATH for doing Java development since they
compute the class path based on where the java component being run is
located in the filesystem. This will not work for <strong>jil</strong>
programming. You need to specify a CLASSPATH or a value for
<a href="variables/jil/s_jil-classpath_s.htm"><code>*jil-classpath*</code></a>.
</p>
<p id="191">
The <a href="variables/jil/s_jil-classpath_s.htm"><code>*jil-classpath*</code></a> variable is designed
to allow you to easily switch between different sets of java
classfiles. If you will use only one set, you should specify a value
for CLASSPATH and leave (or make) the value of <a href="variables/jil/s_jil-classpath_s.htm"><code>*jil-classpath*</code></a> &nbsp;<code>nil</code>.
</p>

<p id="192">
Next you place the files comprising the <strong>jil</strong> compiler
on your machine, and we suggest that they be in the jil subdirectory
of the main directory in which you intend to work. Start lisp
and evaluate
</p>

<pre id="193">
(require :jil)
</pre>

<p id="194">
The <strong>jil</strong> compiler will be loaded into
Lisp. Functions and variables are named by symbols in the
<code>javatools.jil</code> package.
</p>

<p id="195">
The function <a href="operators/jil/jcomp-file.htm"><b>jcomp-file</b></a> will compile a
<strong>jil</strong> sourcefile into a classfile. A source file can
contain multiple class definitions. The
<strong>def-java-method</strong>'s that follow a
<strong>def-java-class</strong> are associated with that class. The
output of <a href="operators/jil/jcomp-file.htm"><b>jcomp-file</b></a> is one or more class
files. The names of the class files are the names of the classes
defined, with the extension or type <i>.class</i>. Inner
and anonymous classes are given names generated by the
<strong>jil</strong> compiler and are written out one per file as
well.
</p>

<p id="196">
The toplevel forms permitted in a file processed by <strong>jil</strong> are: 
</p>

<ul>
<li id="197">
progn -- the arguments to the progn are treated like toplevel forms (this is mainly useful as a return from a macro)
</li>
<li id="198">
package
</li>
<li id="199">
import
</li>
<li id="200">
def-java-class
</li>
<li id="201">
def-java-method
</li>
<li id="202">
def-java-macro
</li>
<li id="203">
static -- the arguments are forms to be evaluated when the class file
is loaded in.
</li>
<li id="204">
&lt;anything that macro expands (via def-java-macro macros) to one of
the above forms&gt;
</li>
</ul>

<hr><hr><h2 id="205"><a name="ts-example-1">15.0 Test suite example</a></h2>

<p id="206">
To run the examples, you must have a Java Software Development Toolkit
or Java Runtime installed on your machine (as said in
<a href="#jil-compiler-1">Section 14.0 Using the jil compiler</a>).
</p>


<p id="207">
The <strong>jil</strong> distribution includes the
<strong>jil</strong> test harness <code>tester.jil</code> and
the the <strong>jil</strong> test suite
<code>jiltest.jil</code>. In order to compile the test suite to
a java class file start lisp and change to the directory that contains
the <code>jil</code> directory as a subdirectory and do the
following:
</p>

<pre id="208">
cl-user(1): <strong>(require :jil)</strong>
; Fast loading /usr/local/acl/code/jil.fasl
cl-user(2): <strong>(use-package :javatools.jil)</strong>
t


;; First we must compile the test harness into a class file
;; since the jiltest.jil file imports it


cl-user(3): <strong>(jcomp-file "jil/tester")</strong>

-- Constructor building
Class: &quot;tester&quot;

-- Method compilation
Class: &quot;tester&quot;
Compiling check(int long long)void
Compiling check(int int int)void
Compiling check(int float float)void
Compiling check(int double double)void
Compiling &lt;init&gt;()void
Compiling &lt;clinit&gt;()void
Class: &quot;tester&quot;
Writing file &quot;jil/tester.class&quot;
nil

;; now we compile the test suite itself


cl-user(4): <strong>(jcomp-file "jil/jiltest")</strong>

-- Constructor building
Class: &quot;mactest1&quot;
Class: &quot;mactest2&quot;
Class: &quot;superguy&quot;
Class: &quot;subguy&quot;
Class: &quot;innertestfoo&quot;
Class: &quot;innertestfoo$innera&quot;
Class: &quot;innertestfoo$innera$ultraina&quot;
Class: &quot;innertestfoo$innerb&quot;
Class: &quot;innertestfoo$barintf&quot;
Class: &quot;jiltest&quot;
Class: &quot;blartly&quot;

-- Method compilation
Class: &quot;mactest1&quot;
Compiling &lt;init&gt;()void
Class: &quot;mactest2&quot;
Compiling &lt;init&gt;()void
Class: &quot;superguy&quot;
Compiling testfcn()int
Compiling testdowncast()int
Compiling &lt;init&gt;()void
Class: &quot;subguy&quot;
Compiling testfcn()int
Compiling overloading-2()void
Compiling randomstuff()void
Compiling test_widen()superguy
Compiling &lt;init&gt;()void
Compiling &lt;clinit&gt;()void
Class: &quot;innertestfoo&quot;
Compiling &lt;init&gt;()void
Compiling test_inner()void
Compiling sum(int int)int
Compiling diff(int int)int
Compiling &lt;init&gt;(innertestfoo)void
Compiling clonetest()void
Class: &quot;innertestfoo$innera&quot;
Compiling &lt;init&gt;(innertestfoo)void
Class: &quot;innertestfoo$innera$ultraina&quot;
Compiling &lt;init&gt;(innertestfoo$innera)void
Class: &quot;innertestfoo$innerb&quot;
Compiling &lt;init&gt;(innertestfoo)void
Class: &quot;innertestfoo$barintf&quot;
Class: &quot;jiltest&quot;
Compiling simplemath()void
Compiling promotions()void
Compiling relopstarget(int int int)void
Compiling relopscc(int int int)void
Compiling relopstarget(float float float)void
Compiling relopstarget(double float double)void
Compiling andornot(int double)void
Compiling setqs()void
Compiling lets()void
Compiling doexcept()int
Compiling doexcept2()int
Compiling excepts()void
Compiling dofinally()int
Compiling arraystuff()void
Compiling methodfun(int)void
Compiling overloading()void
Compiling thetests()void
Compiling shifttests()void
Compiling logtests()void
Compiling emptytests()void
Compiling miscstuff(String)void
Compiling main((array String))void
Compiling &lt;init&gt;()void
Class: &quot;blartly&quot;
Compiling snort(int)void
Compiling &lt;init&gt;()void
Class: &quot;mactest1&quot;
Writing file &quot;jil/mactest1.class&quot;
Class: &quot;mactest2&quot;
Writing file &quot;jil/mactest2.class&quot;
Class: &quot;superguy&quot;
Writing file &quot;jil/superguy.class&quot;
Class: &quot;subguy&quot;
Writing file &quot;jil/subguy.class&quot;
Class: &quot;innertestfoo&quot;
Writing file &quot;jil/innertestfoo.class&quot;
Class: &quot;innertestfoo$innera&quot;
Writing file &quot;jil/innertestfoo$innera.class&quot;
Class: &quot;innertestfoo$innera$ultraina&quot;
Writing file &quot;jil/innertestfoo$innera$ultraina.class&quot;
Class: &quot;innertestfoo$innerb&quot;
Writing file &quot;jil/innertestfoo$innerb.class&quot;
Class: &quot;innertestfoo$barintf&quot;
Writing file &quot;jil/innertestfoo$barintf.class&quot;
Class: &quot;jiltest&quot;
Writing file &quot;jil/jiltest.class&quot;
Class: &quot;blartly&quot;
Writing file &quot;jil/blartly.class&quot;
Class: &quot;innertestfoo$1&quot;
Writing file &quot;jil/innertestfoo$1.class&quot;
nil
cl-user(5)
</pre>

<p id="209">
The result of these two calls to <a href="operators/jil/jcomp-file.htm"><b>jcomp-file</b></a> are a
number of class files, once for each class defined in the files
(including anonymous classes). To run the test suite start a
shell (or Command Prompt on Windows) and change to the jil
directory. Then run the Java vm as shown below. Each
test suite entry that works will print an Ok message. If it fails a
message stating what was expected and returned will be printed.
There should be no errors in the test suite (although errors were
reported by older and buggier Java virtual machines).
</p>

<pre id="210">
% <strong>java jiltest</strong>
Ok 1
Ok 2
Ok 3
Ok 4
Ok 5
Ok 6
Ok 7
Ok 8
Ok 9
Ok 10
Ok 11
Ok 12
Ok 100
Ok 101
Ok 102
Ok 103
Ok 104
Ok 105
Ok 106
Ok 107
Ok 108
Ok 200
Ok 201
Ok 202
Ok 203
Ok 204
Ok 205
Ok 205
Ok 206
Ok 207
Ok 208
Ok 209
Ok 210
Ok 211
Ok 212
Ok 213
Ok 214
Ok 215
Ok 216
Ok 217
Ok 218
Ok 219
Ok 220
Ok 300
Ok 301
Ok 302
Ok 303
Ok 303
Ok 304
Ok 305
Ok 306
Ok 307
Ok 308
Ok 400
Ok 401
Ok 402
Ok 403
Ok 404
Ok 405
Ok 405
Ok 406
Ok 407
Ok 408
Ok 409
Ok 410
Ok 411
Ok 412
Ok 413
Ok 414
Ok 415
Ok 416
Ok 417
Ok 418
Ok 419
Ok 420
Ok 500
Ok 501
Ok 502
Ok 503
Ok 504
Ok 505
Ok 505
Ok 506
Ok 507
Ok 508
Ok 509
Ok 510
Ok 511
Ok 512
Ok 513
Ok 514
Ok 515
Ok 516
Ok 517
Ok 518
Ok 519
Ok 520
Ok 600
Ok 601
Ok 602
Ok 602
Ok 603
Ok 604
Ok 700
Ok 701
Ok 702
Ok 703
Ok 704
Ok 705
Ok 706
Ok 707
Ok 708
Ok 709
Ok 800
Ok 801
Ok 802
Ok 803
Ok 900
Ok 901
Ok 1000
Ok 1001
Ok 1100
Ok 1101
Ok 1102
Ok 1103
Ok 1104
Ok 1105
Ok 1106
Ok 1107
Ok 1108
Ok 1109
Ok 1110
Ok 1111
Ok 1113
Ok 1114
Ok 1115
Ok 1116
Ok 1117
Ok 1118
Ok 1119
Ok 1120
Ok 1121
Ok 1122
Ok 1123
Ok 1124
Ok 1125
Ok 1126
Ok 1127
Ok 1300
Ok 1301
Ok 1302
Ok 1303
Ok 1304
Ok 1305
Ok 1306
Ok 1307
Ok 1308
Ok 1309
Ok 1200
Ok 1201
Ok 1400
Ok 1401
Ok 1500
Ok 1501
Ok 1502
Ok 1504
Ok 1505
Ok 1506
Ok 1507
Ok 1508
Ok 1509
Ok 1510
Ok 1511
Ok 1512
Ok 1513
Ok 1514
Ok 1515
Ok 1515
Ok 1516
Ok 1517
Ok 1600
Ok 1601
Ok 1602
Ok 1603
Ok 1604
Ok 1604
Ok 1605
Ok 1700
Ok 1701
Ok 1702
Ok 1703
Ok 1704
Ok 1705
Ok 1801
Ok 1802
Ok 1803
Ok 1804
Ok 1805
Ok 1806
Ok 1807
Ok 1808
Ok 1809
Ok 1810
Ok 1811
Ok 1812
Ok 1900
Ok 1901
Ok 1902
Ok 1903
Ok 1904
Ok 1905
% 
</pre>


<hr><hr><h2 id="211"><a name="tictactoe-example-1">16.0 TicTacToe example</a></h2>


<p id="212">
To run the examples, you must have a Java Software Development Toolkit
or Java Runtime installed on your machine (as said in
<a href="#jil-compiler-1">Section 14.0 Using the jil compiler</a>).
</p>
<p id="213">
This example shows how an applet is converted from Java syntax to
<strong>jil</strong> syntax. The Java source for the
applet can be found in the Java SDK if you have that installed on your
machine.
</p>

<p id="214">
The <strong>jil</strong> version of the TicTacToe program is in
<i>TicTac.jil</i>.  Assuming that the current directory
is the one that contains the <i>jil/</i> subdirectory,
you compile the applet as follows:
</p>

<pre id="215">
cl-user(1): <strong>(require :jil)</strong>
; Fast loading /usr/local/acl/code/jil.fasl
cl-user(2): <strong>(javatools.jil:jcomp-file "jil/TicTac")</strong>


-- Constructor building
Class: &quot;TicTac&quot;

-- Method compilation
Class: &quot;TicTac&quot;
Compiling isWon(int)void
Compiling bestMove(int int)int
Compiling yourMove(int)boolean
Compiling myMove()boolean
Compiling status()int
Compiling init()void
Compiling destroy()void
Compiling paint(Graphics)void
Compiling mouseReleased(MouseEvent)void
Compiling mousePressed(MouseEvent)void
Compiling mouseClicked(MouseEvent)void
Compiling mouseEntered(MouseEvent)void
Compiling mouseExited(MouseEvent)void
Compiling getAppletInfo()String
Compiling &lt;init&gt;()void
Compiling &lt;clinit&gt;()void
Class: &quot;TicTac&quot;
Writing file &quot;jil/TicTac.class&quot;
nil
cl-user(3):
</pre>


<p id="216">
To run the demo start up a web browser viewing the file
<i>TicTac.html</i> in the <strong>jil</strong>
directory. That will cause the TicTac.class file to be loaded into the
browser and started. Then start clicking on free squares to make
a move.
</p>

</body><hr><p id="2"><small>Copyright (c) 1998-2016, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page was not revised from the 9.0 page.</small><br><small>Created 2015.5.21.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.0</b><br><small><a href="introduction.htm#updates-s">Unrevised from 9.0 to 10.0.</a></small><br><a href="http://www.franz.com/support/documentation/9.0/doc/jil.htm">9.0 version</a></td></tr></table></html>