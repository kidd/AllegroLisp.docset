<html><head><meta name="viewport" content="width=device-width, initial-scale=1"> <meta http-equiv="content-type" content="text/html; charset=UTF-8"> <link rel="stylesheet" href="acldoc-styles.css" type="text/css"><title>Packages</title></head><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/packages.htm">10.0 version</a></td></tr></table><h1 id="2">Packages</h1><p id="3">This document contains the following sections:</p><a href="#packages-intro-1">1.0 Packages introduction</a><br><a href="#hier-packs-1">2.0 Hierarchical Packages</a><br>&nbsp;&nbsp;&nbsp;<a href="#hier-packs-term-2">2.1 Hierarchical Package Terminology</a><br>&nbsp;&nbsp;&nbsp;<a href="#hier-packs-dots-2">2.2 The problem with dots 1: find-package with names that begin with dots</a><br>&nbsp;&nbsp;&nbsp;<a href="#hier-packs-end-dots-2">2.3 The problem with dots 2: names and nicknames that end with dots</a><br>&nbsp;&nbsp;&nbsp;<a href="#hier-packs-creation-2">2.4 Defining hierarchical packages</a><br>&nbsp;&nbsp;&nbsp;<a href="#hier-packs-nicknames-2">2.5 Package nicknames: absolute and relative</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#flat-nicknames-3">2.5.1 Names and Nicknames created with :flat t</a><br>&nbsp;&nbsp;&nbsp;<a href="#resolving-relative-2">2.6 Resolving relative package names</a><br>&nbsp;&nbsp;&nbsp;<a href="#using-nicknames-3">2.7 Hierarchical package specified with nicknames</a><br>&nbsp;&nbsp;&nbsp;<a href="#hp-anomalies-2">2.8 Hierarchical package anomalies</a><br>&nbsp;&nbsp;&nbsp;<a href="#pack-prefixes-2">2.9 Package prefixes reserved by Allegro CL</a><br>&nbsp;&nbsp;&nbsp;<a href="#new-cl-funs-2">2.10 Functions for hierarchical packages</a><br><a href="#packages-in-acl-1">3.0 Packages in Allegro CL</a><br><a href="#notes-on-specific-packages-1">4.0 Notes on specific packages</a><br><a href="#package-nicknames-1">5.0 Package nicknames and alternate names</a><br><a href="#package-locking-1">6.0 Package locking and package definition locking</a><br>&nbsp;&nbsp;&nbsp;<a href="#package-locking-2">6.1 Package locking</a><br>&nbsp;&nbsp;&nbsp;<a href="#package-definition-locking-2">6.2 Package definition locking</a><br>&nbsp;&nbsp;&nbsp;<a href="#implementation-packages-2">6.3 Implementation packages</a><br>&nbsp;&nbsp;&nbsp;<a href="#package-locked-errors-2">6.4 Package locked errors</a><br>&nbsp;&nbsp;&nbsp;<a href="#circumventing-package-locked-errors-2">6.5 Locally circumventing package locked errors</a><br>&nbsp;&nbsp;&nbsp;<a href="#default-locked-packages-2">6.6 The packages locked by default</a><br>&nbsp;&nbsp;&nbsp;<a href="#package-locking-justification-2">6.7 Justification for package locking</a><br><hr><hr><h2 id="4"><a name="packages-intro-1">1.0 Packages introduction</a></h2>

<p id="5">Common Lisp allows the use of packages to keep different parts of
an application separate, permitting multiple use of symbol names and
independent development of different parts of a large program. As
delivered, Allegro CL comprises several packages, and users should be
aware of which packages are available, which should be used by the
user, and which should, in general, be avoided.</p>

<p id="6">
Starting in release 6.0, Allegro CL has implemented a hierarchical
package naming scheme, allowing the specification of a hierarchy of
packages, and the use of relative package specifiers, analogous to
relative pathnames. While this facility is an extension to the ANSI spec,
programs that do not use hierarchical naming are unaffected
(except for the handling of rather unusual, erroneous code). Programs
that use it, however, may have to be modified to be portable.
See <a href="#hier-packs-1">Section 2.0 Hierarchical Packages</a>.
</p>

<p id="7">Lisp permits already-defined functions to be redefined
dynamically. However, redefining system-defined functions (either from
the Common Lisp standard in the common-lisp package or from the
Allegro CL implementation, in packages such as excl, system, etc.) is
almost always a bad idea. Allegro CL implements a package-locking
system which protects symbols in reserved packages from new or changed
function definitions. See the discussions under the heading 
<a href="#package-locking-1">Section 6.0 Package locking and package definition locking</a> below.</p>



<hr><hr><h2 id="8"><a name="hier-packs-1">2.0 Hierarchical Packages</a></h2>

<p id="9">
Allegro Common Lisp supports fully hierarchical packages. Hierarchical
packages, which are part of many modern languages but not part of ANSI
Common Lisp, are a convenient way to manage namespaces because you
have freedom to choose the name of the root package and then can use
any names you like for the lower-level packages, even names used by
other modules. So you can have your own <code>:test</code> package
just like every other module.
</p>
<p id="10">
The hierarchical package implementation affects output
of <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a>
(either a direct call or an implicit call triggered by use of a
package qualifier or an argument to <a href="../ansicl/dictentr/in-packa.htm"><b>in-package</b></a> or other package-related
function). When given a name containing dots, it tries to resolve the
name in a hierarchical fashion, with respect to the current value
of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a>. This means that find-package
may have different behavior for names that contain dots depending on
the value of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a>:
</p>

<pre id="11">
cl-user(9): (defpackage :mypack)
#&lt;The mypack package&gt;
cl-user(10): (defpackage :mypack.test)
#&lt;The mypack.test package&gt;
cl-user(11): (find-package :.test)
nil
cl-user(12): (in-package :mypack)
#&lt;The mypack package&gt;
mypack(13): (find-package :.test)
#&lt;The mypack.test package&gt;
mypack(14): 
</pre>

<p id="12">
In the example, <code>(find-package :.test)</code>
returns <code>nil</code> when <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> is
the <code>:cl-user</code> package and returns
the <code>:mypack.test</code> package
when <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a>
is the <code>:mypack</code> package. Note that this is
non-standard behavior. The ANS says that <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> should return the same
value for the same argument regardless of the value
of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a>.
</p>
<p id="13">
We have implemented hierarchical packages because of the convenience
it offers. Hierarchical packages:
</p>
<ul>
<li id="14">
<b>Reduce collisions with user-defined packages</b>: it is a
well-known problem that package names used by the Lisp implementation
and those defined by users can easily conflict. The intent of
hierarchical packages is to reduce such conflicts to a minimum.
</li>
<li id="15">
<b>Improve modularity</b>: the current organization of packages in
various implementations has grown over the years and appears somewhat
random. Organizing future packages into a hierarchy will help make the
intention of the implementation more clear.
</li>
</ul>
<p id="16">
The problem with implementing full hierarchical packages in Common
Lisp is that you need a special character to indicate the hierarchy
levels (we used a period, also called a <i>dot</i>) but this character
is not special in ANSI Common Lisp. Therefore, names
like <code>foo.bar</code> and <code>.bar</code> are legal
package names in Common Lisp and have nothing to do with
hierarchy. The hierarchical structure must be superimposed on the
standard Common Lisp package structure.
</p>
<p id="17">
This issue manifests itself if you have packages with names containing
dots, particularly dots at the beginning of the name. It also
manifests itself in the treatment of nicknames. We discuss both of
these issues below.
</p>
<p id="18">
Note that we give package names as keywords (<code>:foo</code>
for the <code>foo</code> package). In modern Lisp, symbol names
are case-sensitive and the <code>:foo</code> package has name
"foo". In ANSI Lisp, symbol names are case-insensitive and
the <code>:foo</code> package has name "FOO". In the remainder
of this discussion, we will use lowercase names and the examples are
from a modern implementation (with occasional reminders of the
issue). See <a href="case.htm">case.htm</a> for a discussion of modern and
ANSI Lisps.
</p>

<hr><h2 id="19"><a name="hier-packs-term-2">2.1 Hierarchical Package Terminology</a></h2>

<p id="20">
Here is the terminology we will use when discussing hierarchical packages:
</p>

<ul>
<li id="21">
<b>Package name</b>: the name as specified to <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> or <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a>. Those operators do not
resolve realtive names -- what is specified is the name. Therefore, if
the current package is the <code>foo</code>
package, <code>(defpackage :.bar)</code> creates a package with
name ".bar" (in a modern Lisp, ".BAR" in an ANSI Lisp). It does not
create the package <code>:foo.bar</code>
and <code>(find-package :.bar)</code> returns
the <code>:.bar</code> package, not
the <code>foo.bar</code> package (assuming
the <code>foo.bar</code> package has not also been created
explicitly).
</li>
<li id="22">
<b>Absolute package</b>: a package that has no parent. It can be the
root of a package hierarchy or not associated with a hierarchy at
all. Its name typically contains no dots (but can contain dots that do
not logically resolve into hierarchies, such as ".foo" or "baz..bar").
</li>
<li id="23">
<b>Relative package</b>: a package with single dots in its name (but
not a leading dot -- <code>:.bar</code> -- or a trailing dot --
<code>:bar.</code>). For
example <code>foo.bar.baz</code>. (Multiple consecutive dots --
<code>:bar..baz</code> -- are also not allowed.) If all the
ancestor packages exist, this package will be relative to them and
using relative name will work when applicable.
</li>
<li id="24">
<b>Relative package name</b>: a name starting with one or more dots
and possible containing other singleton dots except without a trailing
dot (so <code>:..bar</code> and <code>.bar.baz</code> but
not <code>.bar..baz</code> or <code>.bar.</code>). When
trying to find the package named by a relative name, the system will
combine the relative name with the current package name as described
below. If that does not find a package, then a package with that
absolute name will be looked for.
</li>
<li id="25">
<b>Absolute or flat nickname</b>: a nickname is absolute or flat
(synonomous terms) if any of the following conditions hold:
<ol>
<li id="26">
the nickname that contains no dots. <code>(defpackage :foo.bar
(:nicknames :foobar))</code> is an example.
</li>
<li id="27">
The nickname created with the <code>:flat t</code> option
to <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a>
or <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a>. <code>(defpackage
:foo.bar (:nicknames :foo.b) (:flat t))</code> is an example.
</li>
<li id="28">
The number of dots in the nickname does not match the number of
dots in the package name. <code>(defpackage :a.b (:nicknames
:anick.bnick.cnick))</code> is an example.
</li>
<li id="29">
The nickname has a different parent than the
package. <code>(defpackage :foo.bar (:nicknames :baz.b))</code>
is an example. Note the parent package (<code>:foo</code> in
this case) need not exist when the package is created.
</li>
</ol>
<p id="30">
For <code>:flat
t</code> nicknames, they are used as specified regardless of
whether they contain dots. So <code>(defpackage :foo (:nicknames
:baz.bar) (:flat t))</code> creates a package with
name <code>:foo</code> and nickname <code>:baz.bar</code>
and (assuming no other definitions are
relevant) <code>(find-package :bar.baz)</code> will return the
:foo package while <code>(find-package :.bar)</code> will return
<code>nil</code>. Nicknames are further discussed
in <a href="#hier-packs-nicknames-2">Section 2.5 Package nicknames: absolute and relative</a> below.
</p>
</li>
<li id="31">
<b>Package parent and ancestor</b>: the general hierarchical package
name is <code>name1.name2.[...]nameN.name</code>. The parent of
that package is is <code>name1.name2.[...]nameN</code>. All
packages <code>name1</code>, <code>name1.name2</code>,
etc. through <code>name1.name2.[...]nameN</code> are ancestor
packages. So for
package <code>:foo.bar.baz</code>, <code>:foo.bar</code>
is the parent and it and <code>:foo</code> are ancestors.
</li>
<li id="32">
<b>Subpackage</b>: in a package hierarchy, assuming all relevant
packages are defined, a A is a subpackage of B is A has
name <code>[name of
B].[name]</code>. So <code>:foo.bar.baz</code>
and <code>:foo.bar</code> are both subpackages
of <code>:foo</code>.
</li>
</ul>





<hr><h2 id="33"><a name="hier-packs-dots-2">2.2 The problem with dots 1: find-package with names that begin with dots</a></h2>

<p id="34">
Hierarchical packages are defined by indicating the hierarchy with
dots (periods) in names. For package names, singleton dots can appear
separating the various package ancestors, but there cannot be a
leading dot, a trailing dot, or any multiple consecutive dots (if any
of those appear, the specified name is the absolute name of the
package which is not in a hierarchy). For relative names, there must
be at least one leading dot but can be any number, and there can be
singleton dots elsewhere, but no trailing dot.
</p>
<p id="35">
The problem is dots are not special characters and so Common Lisp
allows any number of dots in package names. However, dots do matter in
the hierarchical package implementation. As said above, hierarchical
packages affect what package is found by <code>(find-package
:&lt;name&gt;)</code> directly or implicitly with
<code>&lt;name&gt;::&lt;symbol&gt;</code> and
in <i>package</i> arguments to operators. Mixing
packages with names that beging with a dot with relative package names
can result in unexpected results because of shadowing and name
conflicts. Here is an example:
</p>

<pre id="36">
;; We define package :luser, :.zoo, and :luser.zoo.
;; Except when *package* is the :luser package,
;; (find-package :.zoo) returns the :.zoo package.
;; When *package* is the :luser package, (find-package :.zoo)
;; returns the :luser.zoo package and find-package will not
;; return the :.zoo package for any argument value.
;;
cl-user(1): (defpackage :luser)
#&lt;The luser package&gt;
cl-user(2): (defpackage :.zoo)
#&lt;The .zoo package&gt;
cl-user(3): (defpackage :luser.zoo)
#&lt;The luser.zoo package&gt;
cl-user(4): (find-package :.zoo)
#&lt;The .zoo package&gt;
cl-user(5): :pa luser
luser(6): (find-package :.zoo)
#&lt;The luser.zoo package&gt;
luser(7): (defpackage :cl-user.zoo)
#&lt;The cl-user.zoo package&gt;
luser(8): (find-package :.zoo)
#&lt;The luser.zoo package&gt;
luser(9): :pa cl-user
cl-user(10): (find-package :.zoo)
#&lt;The cl-user.zoo package&gt;
cl-user(11): (defpackage :other)
#&lt;The other package&gt;
cl-user(12): :pa other
other(13): (find-package :.zoo)
#&lt;The .zoo package&gt;
other(14):
</pre>

<p id="37">
You might think you should avoid package names beginning with a dot
entirely, but one can imagine scenarios where such names might be
useful. Suppose in your hierarchy, every package has a subpackage with
relative name <code>:.test</code>. You may wish to also create a
<code>:.test</code> package (with <code>(defpackage
:.test)</code>) so <code>(find-package :.test)</code> will
never return <code>nil</code> regardless of the value of
<a href="../ansicl/dictentr/package.htm"><code>*package*</code></a>. But
outside of that case, leading dots in package names should likely be
avoided.
</p>





<hr><h2 id="38"><a name="hier-packs-end-dots-2">2.3 The problem with dots 2: names and nicknames that end with dots</a></h2>

<p id="39">
Because a dot (period) delimits levels of the package hierarchy, a
trailing dot does not make sense in a hierarchical scheme: it should
be followed by a name lower in the hierarchy but there is no name. 
</p>
<p id="40">
Therefore, package names or nicknames ending with one or more dots are
considered flat names (not hierarchical names). 
</p>




<hr><h2 id="41"><a name="hier-packs-creation-2">2.4 Defining hierarchical packages</a></h2>

<p id="42">
A package name containing one or more single dots (but no multiple
consecutive dots, no leading dot, and no trailing dot) is potentially
a hierarchical package. So <code>(defpackage
:foo.bar.baz)</code> is potentially a hierarchical package, with
name "foo.bar.baz" and potential ancestors the <code>:foo</code>
package and the
<code>:foo.bar</code> package, if they exists. When
the <code>:foo</code> package and
the <code>:foo.bar</code> packages are defined, then the
<code>:foo.bar.baz</code> package becomes a hierarchical package
and rules for resolving relative names will apply. This rules are
described in <a href="#resolving-relative-2">Section 2.6 Resolving relative package names</a>
below.
</p>
<p id="43">
To repeat and important point: a package become hierarchical when all
its potential ancestor packages exist. The package will be immediately
hierarchical if they already exist when the package is created. It
becomes hierarchical later if the ancestor packages do not exist but
are created later.
</p>



<hr><h2 id="44"><a name="hier-packs-nicknames-2">2.5 Package nicknames: absolute and relative</a></h2>

<p id="45">
Package nicknames are specified by the <code>:nicknames</code>
option to <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a>/argument
to <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a>. The
nickname will be hierarchical if it has the same number of dots, the
same parent (everything up to the last dot), and is not specified as
flat. In that case, relative names can be used when the current
package is the parent package (or one of its ancestors).  (Nicknames
ending in a dot are an anomaly discussed
in <a href="#hp-anomalies-2">Section 2.8 Hierarchical package anomalies</a> below.)  Nicknames
without dots, with a different number of dots, or with a different
parent are absolute (or flat) nicknames and can be used to find the
package regardless of the value of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a>.
</p>
<p id="46">
Consider the following example:
</p>

<pre id="47">
cl-user(2): (defpackage :newpack)
#&lt;The newpack package&gt;
cl-user(3): (defpackage :newpack.test (:nicknames :mytest 
						   :different-parent.nopt
						   :a..lot...of...dots...newpt
                                                   :newpack.npt))
#&lt;The newpack.test package&gt;

;; The full nicknames all work, flat or relative:
cl-user(4): (find-package :mytest)
#&lt;The newpack.test package&gt;
cl-user(5): (find-package :different-parent.npt)
#&lt;The newpack.test package&gt;
cl-user(6): (find-package :a..lot...of...dots...newpt)
#&lt;The newpack.test package&gt;
cl-user(7): (find-package :newpack.npt)
#&lt;The newpack.test package&gt;
cl-user(8): (find-package :.npt)
 ;; relative name but not is right package to resolve relative name
 ;; see below when *package* is the :newpack package.
nil
cl-user(9): (in-package :newpack)
#&lt;The newpack package&gt;
  ;; The possible relative nicknames are :.nopt, :.newpt, and :.npt
  ;; from nicknames :different-parent.nopt, :a..lot...of...dots...newpt,
  ;; and :newpack.npt. But only the last works when in the :newpack
  ;; package. All the rest have something which disqualifies them.
newpack(10): (in-package :newpack)
#&lt;The newpack.test package&gt;
newpack(11): (find-package :.nopt)
  ;; :different-parent.nopt has the right number of dots but
  ;; a different parent.
nil
newpack(12): (find-package :.newpt)
  ;; :a..lot...of...dots...newpt has too many dots.
nil
newpack(13): (find-package :.npt)
  ;; This one is a proper relative package nickname.
#&lt;The newpack.test package&gt;
newpack(14): (find-package :.newpt)
nil
newpack(11): (find-package :newpack.npt)
 ;; relative nicknames only work as relative names. Their full
 ;; name is not a nickname.
nil
newpack(15):
</pre>



<hr><h2 id="48"><a name="flat-nicknames-3">2.5.1 Names and Nicknames created with :flat t</a></h2>

<p id="49">
If the <code>:flat</code> option to <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a>/keyword argument to
<a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a> is
specified true, the name is stored in the flat hashtable rather than as part of a hierarchy and all nicknames defined are made absolute nicknames
whether or not they contain dots (see
<a href="implementation.htm#extensions-to-clfuns-one-2">Extensions to cl:make-package, 
cl:disassemble, cl:truename, cl:probe-file, cl:open, 
cl:apropos</a> and <a href="implementation.htm#cl-defpackage-2">cl:defpackage and cl:in-package</a>, both in
<a href="implementation.htm">implementation.htm</a>, for more information on
extensions to <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> and <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a>.)
</p>
<p id="50">
The fact that the name is stored in the flat hashtable is an
implementation detail which may have no visible consequences to the
user (so <code>(defpackage :foo)</code> and <code>(defpackage
:foo.bar (:flat t))</code> ctreates
packages <code>:foo</code> and <code>:foo.bar</code>, and
even though <code>:foo.bar</code> is
flat, <code>(find-package :.bar)</code>
when <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a>
is the
<code>:foo</code> package returns
the <code>:foo.bar</code> package). The consequences to
nicknames is, howver, significant, as we discuss next.
</p>
<p id="51">
In this example, we specify nicknames containing dots but also specify
<code>:flat t</code>. As a result, all the nicknames are
absolute nicknames and none work as relative nicknames.
</p>

<pre id="52">
cl-user(53): (defpackage :pack1)
#&lt;The pack1 package&gt;
cl-user(54): (defpackage :pack1.flatpack (:nicknames :.fpk :a..lot.of..dots
						     :.pack1.gp :flatpk)
			 (:flat t))
#&lt;The pack1.flatpack package&gt;
cl-user(55): (find-package :.fpk)  ;; absolute nickname, not relative
#&lt;The pack1.flatpack package&gt;
cl-user(56): (find-package :a..lot.of..dots) ;; absolute here too
#&lt;The pack1.flatpack package&gt;
cl-user(57): (find-package :flatpk) ;; this one is always absolute
#&lt;The pack1.flatpack package&gt;
cl-user(58): (in-package :pack1)
#&lt;The pack1 package&gt;
pack1(59): (find-package :.gp) ;; Without :flat t, this would work
                               ;; as a relative nickname
nil
pack1(60): (find-package :.fpk)  ;; this is an absolute nickname and
                                 ;; so works (it just looks like a relative
                                 ;; nickname)
#&lt;The pack1.flatpack package&gt;
pack1(61): (find-package :a..lot.of..dots) ;; absolute nickname
#&lt;The pack1.flatpack package&gt;
pack1(62): 
</pre>





<hr><h2 id="53"><a name="resolving-relative-2">2.7 Resolving relative package names</a></h2>

<p id="54">
When <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> is
passed an actual package name or an absolute nickname, the associated
package is returned (except perhaps when the name looks like a
relative name,
see <a href="#hp-anomalies-2">Section 2.8 Hierarchical package anomalies</a>). When it is passed
a relative name, it tries to resolve that name with respect to the
current package (the value of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> and returns the package
found, if any. <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> tries to resolve relative
names with <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> before it looks for an
absolute name that resembles the relative name but it will find the
absolute name if there is no relative name resolution.
</p>
<p id="55">
A <b>relative package name</b> is a name that starts with any number
of dots (but at least one) and may contain additional single dots, but
does not end with a dot and contains no additional multiple
consecutive dots. So
<code>:.foo</code>, <code>:...foo</code>, 
<code>:.foo.bar</code>, and <code>:..foo.bar.baz</code>
are all relative names but <code>:[any character beside a
dot][pehaps more characters]</code>, <code>:p.foo</code>,
<code>:..foo..bar</code>, and <code>:.foo.</code> are not.
</p>
<p id="56">
When there are multiple dots at the beginning, they are treated
analogously with initial dots in pathnames, with a single dot meaning
the current package, two dots meaning the parent of the current
package, and more than two meaning ancestors of the current package
further back. <code>(find-package :.)</code> always returns the
current package. <code>(find-package :..)</code> returns the
parent of the current package, if there is one (and signals an error
if there is not).
</p>
<p id="57">
Here are multiple examples of resolving relative pathnames. Note that
resolving relative package names is done by explicit calls
to <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> and
also by implicit calls, such as finding the package indicated by a
package qualifier to a symbol or finding the package in a call
to <a href="../ansicl/dictentr/in-packa.htm"><b>in-package</b></a>.
</p>

<p id="58">
In these examples, we assum that packages
named <code>mypack</code>,
<code>mypack.foo</code>, <code>mypack.foo.bar</code>,
<code>mypack.foo.baz</code>, <code>mypack.bar</code>,
<code>mypack.bar.baz</code>, <code>foo</code>, and
<code>foo.bar</code>, have all been created:
</p>

<table border="2" cellpadding="3" cellspacing="1" width="95%">
  <tr>
    <th width="24%" align="left">relative name</th>
    <th width="36%" align="left">current package</th>
    <th width="116%" align="left">absolute name of referenced package</th>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>foo</code></td>
    <td width="36%"><i>any</i></td>
    <td width="116%"><code>foo</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>foo.bar</code></td>
    <td width="36%"><i>any</i></td>
    <td width="116%"><code>foo.bar</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>.foo</code></td>
    <td width="36%"><code>mypack</code></td>
    <td width="116%"><code>mypack.foo</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>.foo.bar</code></td>
    <td width="36%"><code>mypack</code></td>
    <td width="116%"><code>mypack.foo.bar</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>..foo</code></td>
    <td width="36%"><code>mypack.bar</code></td>
    <td width="116%"><code>mypack.foo</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>..foo.baz</code></td>
    <td width="36%"><code>mypack.bar</code></td>
    <td width="116%"><code>mypack.foo.baz</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>...foo</code></td>
    <td width="36%"><code>mypack.bar.baz</code></td>
    <td width="116%"><code>mypack.foo</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>.</code></td>
    <td width="36%"><code>mypack.bar.baz</code></td>
    <td width="116%"><code>mypack.bar.baz</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>..</code></td>
    <td width="36%"><code>mypack.bar.baz</code></td>
    <td width="116%"><code>mypack.bar</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>...</code></td>
    <td width="36%"><code>mypack.bar.baz</code></td>
    <td width="116%"><code>mypack</code></td>
  </tr>
</table>

<hr><h2 id="59"><a name="using-nicknames-3">2.7 Hierarchical package specified with nicknames</a></h2>

<p id="60">
Because Allegro CL implements true hierarchical packages, relative
nicknames can be used in place of relative names at any level, and
absolute nicknames can also be used, as the following example shows:
</p>

<pre id="61">
cl-user(78): (defpackage :zpack (:nicknames :zpa))
#&lt;The zpack package&gt;
cl-user(79): (defpackage :zpack.foo (:nicknames :.zfo :zop))
#&lt;The zpack.foo package&gt;
cl-user(80): (defpackage :zpack.foo.bar)
#&lt;The zpack.foo.bar package&gt;
cl-user(81): (find-package :zpa.foo)
#&lt;The zpack.foo package&gt;
cl-user(82): (find-package :zpa.zfo)
#&lt;The zpack.foo package&gt;
cl-user(83): (find-package :zpack.zop.bar) ;; zop is an absolute nickname
nil
cl-user(84): (find-package :zop.bar) ;; so this works
#&lt;The zpack.foo.bar package&gt;
cl-user(85): (in-package :zpack)
#&lt;The zpack package&gt;
zpa(86): (find-package :.zop) ;; again, an absolute nickname
nil
zpa(87): (find-package :.zfo)
#&lt;The zpack.foo package&gt;
zpa(90): (in-package :zpack.foo.bar)
#&lt;The zpack.foo.bar package&gt;
zpack.foo.bar(91): (find-package :.)
#&lt;The zpack.foo.bar package&gt;
zpack.foo.bar(92): (find-package :..)
#&lt;The zpack.foo package&gt;
zpack.foo.bar(93): (find-package :...)
#&lt;The zpack package&gt;
zpack.foo.bar(94): (find-package :...foo)
#&lt;The zpack.foo package&gt;
zpack.foo.bar(95): 
</pre>







<hr><h2 id="62"><a name="hp-anomalies-2">2.8 Hierarchical package anomalies</a></h2>

<p id="63">
Because implementing hierarchical packages makes dots into special
characters, you may see behavior which is unexpected or (at first)
unintuitive (and also not what standard Common Lisp would do). This
has been true since partial hierarchical packages were first
introduced and remains true now that fully hierarchical packages have
been implemented.
</p>
<ul>
<li id="64">
An abolute package name starting with a dot or dots will not be found by
<a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> when
taken as a relative name, it does resolve. We gave this example above:
<pre id="65">
;; We define package :luser, :.zoo, and :luser.zoo.
;; Except when *package* is the :luser package,
;; (find-package :.zoo) returns the :.zoo package.
;; When *package* is the :luser package, (find-package :.zoo)
;; returns the :luser.zoo package and find-package will not
;; return the :.zoo package for any argument value.
;;
cl-user(1): (defpackage :luser)
#&lt;The luser package&gt;
cl-user(2): (defpackage :.zoo)
#&lt;The .zoo package&gt;
cl-user(3): (defpackage :luser.zoo)
#&lt;The luser.zoo package&gt;
cl-user(4): (find-package :.zoo)
#&lt;The .zoo package&gt;
cl-user(5): :pa luser
luser(6): (find-package :.zoo)
#&lt;The luser.zoo package&gt;
luser(7): (defpackage :cl-user.zoo)
#&lt;The cl-user.zoo package&gt;
luser(8): (find-package :.zoo)
#&lt;The luser.zoo package&gt;
luser(9): :pa cl-user
cl-user(10): (find-package :.zoo)
#&lt;The cl-user.zoo package&gt;
cl-user(11): (defpackage :other)
#&lt;The other package&gt;
cl-user(12): :pa other
other(13): (find-package :.zoo)
#&lt;The .zoo package&gt;
other(14):
</pre>
</li>
<li id="66">
Specifying a nickname ending in a dot can cause problems. Unless you
specify <code>:flat t</code> in the <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> or <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a> form (see
<a href="implementation.htm#extensions-to-clfuns-one-2">Extensions to cl:make-package, 
cl:disassemble, cl:truename, cl:probe-file, cl:open, 
cl:apropos</a> and <a href="implementation.htm#cl-defpackage-2">cl:defpackage and cl:in-package</a>, both in
<a href="implementation.htm">implementation.htm</a>, for more information on
extensions to <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> and <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a>), specifying a nickname
ending in a dot (like <code>(:nicknames :foo.bar.baz.)</code>)
will follow the relative nickname rule of ignoring everything up to
the last dot, and so the nickname will be "." which in any case names
the current package. In some cases, you may get an error.
</li>
<li id="67">
<b>find-package will signal an error if a relative package name has
too many leading dots</b>. <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> normally does not signal
an error so long as its argument can be coerced to a string. It just
returns <code>nil</code> if the string obtained from its
argument does not name a package. However, if passed a name beginning
with more than one dots, it tries to find the parent of the current
package, and (if necessary) the parent of that package, and so on
until all dots are resolved. If at any point there is no parent, then
an error is signaled. So:

<pre id="68">
zpack.foo.bar(106): *package*
#&lt;The zpack.foo.bar package&gt;
zpack.foo.bar(107): (find-package :.)
#&lt;The zpack.foo.bar package&gt;
zpack.foo.bar(108): (find-package :..)
#&lt;The zpack.foo package&gt;
zpack.foo.bar(109): (find-package :...)
#&lt;The zpack package&gt;
zpack.foo.bar(110): (find-package :....)
Error: The parent of package #&lt;The zpack package&gt; does not exist.
</pre>
</li>
</ul>
<p id="69">
<b>BETA NOTE</b>: The correct behavior for these cases is still under
review. Behavior may change in the final release.
</p>


<hr><h2 id="70"><a name="pack-prefixes-2">2.9 Package prefixes reserved by Allegro CL</a></h2>

<p id="71">
Allegro CL typically puts newly created
packages under the following top-level names:
</p>

<ul>
  <li id="72"><em>net</em> -- network related modules <ul>
      <li id="73"><em>uri</em> -- URI/URL/URN parser 
      (see <a href="uri.htm">uri.htm</a>)</li>
      <li id="74"><em>aserve</em> -- web server (see
      <a href="aserve/aserve.html">aserve/aserve.html</a>)</li>
      <li id="75"><em>rpc</em> -- Lisp-to-Lisp remote procedure call
      (see <a href="rpc.htm">rpc.htm</a>)</li>
    </ul>
  </li>
  <li id="76"><em>xml</em> -- used for generated namespaces</li>
  <li id="77"><em>javatools</em>
    <ul>
    <li id="78"><em>jlinker</em> -- Java interface components
    (see <a href="jlinker.htm">jlinker.htm</a>)</li>
    <li id="79"><em>jil</em> -- Java-in-Lisp bytecode compiler
    (see <a href="jil.htm">jil.htm</a>)</li>
    </ul>
  </li>
  <li id="80"><em>cg</em> -- common graphics</li>
  <li id="81"><em>ide</em> -- cg-based graphical development environment</li>
  <li id="82"><em>corba</em></li>
  <li id="83"><em>ffi</em> -- foreign function related modules</li>
  <li id="84"><em>util</em> -- utility modules</li>
</ul>

<p id="85">
The use of these top-level names as packages in applications might run
into problems with Allegro CL. Note that all current
package names (such as <em>excl</em>, <em>system</em> etc.) will also
be used.
</p>



<hr><h2 id="86"><a name="new-cl-funs-2">2.10 Functions for hierarchical packages</a></h2>

<p id="87">
To facilitate using hierarchical packages, there are the 
functions <a href="operators/excl/package-parent.htm"><b>package-parent</b></a> and <a href="operators/excl/package-children.htm"><b>package-children</b></a>. 
</p>









<hr><hr><h2 id="88"><a name="packages-in-acl-1">3.0 Packages in Allegro CL</a></h2>

<p id="89">
In addition to the hierarchical packages named in
<a href="#pack-prefixes-2">Section 2.9 Package prefixes reserved by Allegro CL</a>, the following packages
used by Allegro CL are of direct importance to the user. Note that all
nicknames are not listed in every case. Use <a href="../ansicl/dictentr/package4.htm"><b>package-nicknames</b></a> applied to a package to see
the complete list. The first nickname listed in each case is the
principal nickname.
</p>

<p id="90">Some of these packages may not exist in a standard Allegro CL image
until a <em>fasl</em> file containing the functionality associated
with the package is loaded. In many cases, the loading is automatic
when the package is referenced. Thus</p>

<pre id="91">
(find-package :flavors)
</pre>

<p id="92">causes <em>flavors.fasl</em> to be loaded from the bundle. The
cltl-1 module is not atoloaded.</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="95%">
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p id="93" ALIGN="CENTER">Name</p></td>
    <td WIDTH="8%" VALIGN="TOP"><p id="94" ALIGN="CENTER">Some nicknames</p></td>
    <td WIDTH="39%" VALIGN="TOP"><p id="95" ALIGN="CENTER">Brief Description</p></td>
    <td WIDTH="11%" VALIGN="TOP"><p id="96" ALIGN="CENTER">Locked?</p></td>
    <td WIDTH="23%" VALIGN="TOP"><p id="97" ALIGN="CENTER">Notes</p></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>acl-socket</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Socket interface functionality. See <a href="socket.htm">socket.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>aclwin</code></td>
    <td WIDTH="8%" VALIGN="TOP">aclwin302</td>
    <td WIDTH="39%" VALIGN="TOP">Functionality from Allegro CL 3.0.2 kept in 6.x for
    backward compatibility. </td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP"><p id="98">Exists in Windows and Unix. 
    In Unix, do </p> <p id="99">(require :aclwin)</p>
    <p id="100">In Unix, symbols having to do with graphics have no function 
    definition. Functionality
    that is Windows-specific generates an error when called in Unix.</p></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>clos</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">the MOP extension to CLOS (CLOS functionality is in
    common-lisp).</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>cltl1</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Some symbols removed some functionality redefined from the Common Lisp standard by X3J13.</td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Functionality named by symbols in this package is out of date
    and use should be avoided. Not autoloaded.</td>
  </tr>
  
  
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>common-graphics</code></td>
    <td WIDTH="8%" VALIGN="TOP">cg</td>
    <td WIDTH="39%" VALIGN="TOP">Common Graphics windows functionality.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Windows only. Always present in an image with the IDE.</td>
  </tr>
  
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>common-graphics-user</code></td>
    <td WIDTH="8%" VALIGN="TOP">cg-user</td>
    <td WIDTH="39%" VALIGN="TOP">User environment in the IDE</td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Windows only. Uses aclwin, excl, cg, cl, ide. Always
    present in an image with the IDE.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>common-lisp</code></td>
    <td WIDTH="8%" VALIGN="TOP">cl</td>
    <td WIDTH="39%" VALIGN="TOP">Standard CL symbols.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>common-lisp-user</code></td>
    <td WIDTH="8%" VALIGN="TOP">cl-user<br>user</td>
    <td WIDTH="39%" VALIGN="TOP">User environment.</td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Uses cl and excl. Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>compiler</code></td>
    <td WIDTH="8%" VALIGN="TOP">comp</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the compiler.
    See <a href="compiling.htm">compiling.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>cross-reference</code></td>
    <td WIDTH="8%" VALIGN="TOP">xref</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the cross
    referencer. See <a href="cross-reference.htm">cross-reference.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>dde</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with 
    the DDE interface on Windows. See <a href="dde.htm">dde.htm</a></td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>defsystem</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with defsystem. See <a href="defsystem.htm">defsystem.htm</a></td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>debugger</code></td>
    <td WIDTH="8%" VALIGN="TOP">db</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the debugger.
    See <a href="debugging.htm">debugging.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>excl</code></td>
    <td WIDTH="8%" VALIGN="TOP">excl</td>
    <td WIDTH="39%" VALIGN="TOP">General extensions to Common Lisp</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>foreign-functions</code></td>
    <td WIDTH="8%" VALIGN="TOP">ff</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the foreign
    functions facility. See <a href="foreign-functions.htm">foreign-functions.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>garbage</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Package for compiler labels and some CLOS names. </td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>ide</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Integrated Development
    Environment functionality.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Windows only. Always present in an image with the IDE.</td>
  </tr>

  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>inspect</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the inspector.
    See <a href="inspector.htm">inspector.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>keyword</code></td>
    <td WIDTH="8%" VALIGN="TOP"> </td>
    <td WIDTH="39%" VALIGN="TOP">Standard CL package.</td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>multiprocessing</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with multiprocessing.
    See <a href="multiprocessing.htm">multiprocessing.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>profiler</code></td>
    <td WIDTH="8%" VALIGN="TOP">prof</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the runtime analyzer.
    See <a href="runtime-analyzer.htm">runtime-analyzer.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>system</code></td>
    <td WIDTH="8%" VALIGN="TOP">sys, si</td>
    <td WIDTH="39%" VALIGN="TOP">System functionality and internals.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>top-level</code></td>
    <td WIDTH="8%" VALIGN="TOP">tpl</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the top level.
    See <a href="top-level.htm">top-level.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
</table>

<hr><hr><h2 id="101"><a name="notes-on-specific-packages-1">4.0 Notes on specific packages</a></h2>

<p id="102">When you start up Allegro CL on UNIX or without the Integrated
Development Environment on Windows, you are <i>in</i> the
<code>common-lisp-user</code> package. At the start, there are
no symbols in the <code>common-lisp-user</code> package, but the
<code>common-lisp</code> and <code>excl</code> packages
are used, so external symbols from those packages are available to the
<code>user</code> package. When you start the Integrated
Development Environment (Windows only) you are in the
<code>common-graphics-user</code> package.</p>

<p id="103">The <code>common-lisp</code> package contains only those symbols
specified in the ANSI CL specification. Some of the capabilities of
standard Common Lisp functions have been extended, but they can all be
used in the way specified in ANSI CL. The extensions are not portable,
of course. See <a href="implementation.htm">implementation.htm</a> for
more information on extensions to standard Common Lisp
functionality.</p>

<p id="104">With that caveat, if you use the common-lisp package only, you will
have portable code that can with greatest ease be ported to Common
Lisp systems other than Allegro CL. </p>

<p id="105">A number of symbols were removed from the Common Lisp standard by
the X3J13 committee.  We have maintained many of these symbols in the
<code>cltl1</code> package, for the purpose of providing
backward compatibility. </p>

<p id="106">The <code>excl</code> and <code>system</code> packages
contain many of the extensions in Allegro CL. Two packages in earlier
versions on UNIX (4.3.x and earlier), <code>franz</code> and
<code>stream</code>, have been merged with <code>excl</code>
starting in version 5.0.  Both <code>stream</code> and
<code>franz</code> are nicknames of
<code>excl</code>. <code>excl</code> is also the principal
nickname of the <code>excl</code> package to ensure that name is
used when <a href="variables/excl/s_print-nickname_s.htm"><code>*print-nickname*</code></a> is true.</p>

<p id="107">The <code>top-level</code> package contains symbols used by
the top level. Note that some of these symbols have the same names as
symbols in the <code>common-lisp</code> package (for example,
<a href="variables/tpl/s_print-level_s.htm"><code>*print-level*</code></a> and
<a href="variables/tpl/s_print-length_s.htm"><code>*print-length*</code></a>).
Therefore, we recommend that a package using the
<code>common-lisp</code> package not use (in the sense of <a href="../ansicl/dictentr/use-pack.htm"><b>use-package</b></a>) the
<code>top-level</code> package. </p>


<hr><hr><h2 id="108"><a name="package-nicknames-1">5.0 Package nicknames and alternate names</a></h2>

<p id="109">
Packages can have (usually shorter) nicknames, which can be used in
place of the full names. Symbols unavailable in the current package
are printed (during, e.g., tracing) with package qualifiers. 
</p>
<p id="110">
Allegro CL has permitted using the principal nickname (defined to be
first in the nickname list) instead of the actual name by setting the
value of the variable <a href="variables/excl/s_print-nickname_s.htm"><code>*print-nickname*</code></a> to true. This worked well for
most things but had severe limitations. In particular, the only way to
use the actual package name when <a href="variables/excl/s_print-nickname_s.htm"><code>*print-nickname*</code></a> was to have no nickname. But
sometimes you want nicknames and you want to use the actual name
instead of the nickname (actual names may not also be a nickname).
</p>
<p id="111">
Allegro CL now supports an <b>alternate</b> name. This must be the
package name or one of the nicknames. The laternate name is defined
when a package is created with <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> or <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a>. 
</p>
<p id="112">
When <a href="variables/excl/s_print-alternate-package-name_s.htm"><code>*print-alternate-package-name*</code></a> is true, the
alternate name will be used. If the alternate name is not specified
and <a href="variables/excl/s_print-alternate-package-name_s.htm"><code>*print-alternate-package-name*</code></a>, the principal
nickname is used (that is, the first nickname is the list returned
by <a href="../ansicl/dictentr/package4.htm"><b>package-nicknames</b></a>). If the package has
no nicknames, the <a href="../ansicl/dictentr/package5.htm"><b>package-name</b></a> is used.
</p>
<p id="113">
The alternate package name can be specified by the
new <code>:alternate-name</code> option to <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> and keyword argument to
<a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a>. See
<a href="implementation.htm#extensions-to-clfuns-one-2">Extensions to cl:make-package, 
cl:disassemble, cl:truename, cl:probe-file, cl:open, 
cl:apropos</a> and <a href="implementation.htm#cl-defpackage-2">cl:defpackage and cl:in-package</a>, both in
<a href="implementation.htm">implementation.htm</a>, for more information on
extensions to <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> and <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a>.
</p>
<p id="114">
The alternate name can be accessed by the <a href="operators/excl/package-alternate-name.htm"><b>package-alternate-name</b></a> function. If no
alternate name is specified, the altername name is the first in the
list of nicknames or the package name if there are no nicknames. The
alternate, if explicitly specified, must be either the package name or
one of the nicknames.
</p>
<p id="115">
 Allegro CL allows you to specify whether you want the alternate
package name or the package name as the qualifier. The following
variable <a href="variables/excl/s_print-alternate-package-name_s.htm"><code>*print-alternate-package-name*</code></a> controls which
is used.  Note that certain utilities (e.g. <a href="../ansicl/dictentr/aproposa.htm"><b>apropos</b></a> and the debugger) bind this variable to
true and so always use the alternate name.
</p>

<p id="116">
The principal nickname of some of the packages of interest to users
are listed next (<code>nil</code> means no defined
nicknames). The alternate name is in bold.
</p>

<div align="left">

<table BORDER="1" CELLSPACING="1" CELLPADDING="8" WIDTH="95%">
  <tr>
    <td VALIGN="TOP" COLSPAN="3"><p id="117" ALIGN="CENTER">Table 2: Package Nicknames</p></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><p id="118" ALIGN="CENTER">Package name</p></td>
    <td WIDTH="32%" VALIGN="TOP"><p id="119" ALIGN="CENTER">Principal Nickname (<code>nil</code> means none)</p></td>
    <td WIDTH="32%" VALIGN="TOP"><p id="120" ALIGN="CENTER">Other Nickname (some nicknames may not
    be listed)</p></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>common-lisp</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>cl</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"><code>lisp</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><b><code>clos</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><b><code>excl</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  
  
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>system</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>sys</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"><code>si</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>common-lisp-user</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>cl-user</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"><code>user</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>debugger</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>debug</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"><code>db</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><b><code>inspect</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>compiler</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>comp</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>flavors</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>fla</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>foreign-functions</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>ff</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>multiprocessing</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>mp</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>top-level</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>tpl</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>defsystem</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>defsys</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"><code>ds</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>cross-reference</code></td>
    <td WIDTH="32%" VALIGN="TOP"><b><code>xref</code></b></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
</table>
</div>

<p id="121">Package nicknames can be found with the Common Lisp function
<a href="../ansicl/dictentr/package4.htm"><b>package-nicknames</b></a>, which
returns a list of the nicknames of its argument, with the principal
one first.  Sometimes, you may wish to use a nickname of an Allegro CL
package as the name of your own package. (E.g. some users would like
to have their own package named <code>db</code>, perhaps for
database functionality, but <code>db</code> is a nickname of the
<code>debugger</code> package.) You can change the nicknames of
a package with <a href="../ansicl/dictentr/rename-p.htm"><b>rename-package</b></a>.
You must do it in a <a href="operators/excl/without-package-locks.htm"><b>without-package-locks</b></a> form, however, because
of package locking described just below.</p>


<hr><hr><h2 id="122"><a name="package-locking-1">6.0 Package locking and package definition locking</a></h2>

<p id="123">Packages have two kinds of locks as an extension in Allegro CL. The
package-lock protects a package from changes in its structure (its use
list, its exported symbols, etc.). The package-definition-lock
protects the symbols in the package from new or changed uses as the
name of a function, macro, structure, or type.</p>

<p id="124">Tracing and advice are not affected by either type of package locking.</p>

<hr><h2 id="125"><a name="package-locking-2">6.1 Package locking</a></h2>

<p id="126">When the function <a href="operators/excl/package-lock.htm"><b>package-lock</b></a> returns true when applied to a
package, we say the package is package-locked. When a package is
package-locked, the system will signal an error of type
package-locked-error when code is executed that tries to: </p>

<ul>
  <li id="127"><b>import</b> a symbol into the package (with <a href="../ansicl/dictentr/import.htm"><b>import</b></a> and <a href="../ansicl/dictentr/shadowin.htm"><b>shadowing-import</b></a>)</li>
  <li id="128"><b>export</b> a symbol from the package (with <a href="../ansicl/dictentr/export.htm"><b>export</b></a>).</li>
  <li id="129"><b>unexport</b> a symbol (with <a href="../ansicl/dictentr/unexport.htm"><b>unexport</b></a>)</li>
  <li id="130"><b>change the name</b> of the package (with <a href="../ansicl/dictentr/rename-p.htm"><b>rename-package</b></a>).</li>
  <li id="131"><b>change the packages used</b> by the package (with <a href="../ansicl/dictentr/use-pack.htm"><b>use-package</b></a> and <a href="../ansicl/dictentr/unuse-pa.htm"><b>unuse-package</b></a>).</li>
  <li id="132"><b>unintern</b> a symbol in the package (with <a href="../ansicl/dictentr/unintern.htm"><b>unintern</b></a>)</li>
  <li id="133"><b>shadow</b> a symbol (with <a href="../ansicl/dictentr/shadow.htm"><b>shadow</b></a> or <a href="../ansicl/dictentr/shadowin.htm"><b>shadowing-import</b></a>).</li>
</ul>

<p id="134">The list is exhaustive. Note that intern and delete-package cannot
signal a package-locked-error. The function <a href="operators/excl/package-lock.htm"><b>package-lock</b></a> applied to a package object (but
not a symbol or string naming a package) returns true if the package
is locked and returns <code>nil</code> if it is not
locked. Setf can be used with <a href="operators/excl/package-lock.htm"><b>package-lock</b></a> to lock or unlock a package.</p>



<hr><h2 id="135"><a name="package-definition-locking-2">6.2 Package definition locking</a></h2>

<p id="136">A package is package-definition-locked if the function <a href="operators/excl/package-definition-lock.htm"><b>package-definition-lock</b></a> (whose
argument must be a package object, not a package name) returns true
when applied to the package. When a package is
package-definition-locked, the system will signal an error when code
is executed that attempts any of the following actions on a symbol
homed in the package: </p>

<ul>
  <li id="137">defining it as a function (e.g. with <a href="../ansicl/dictentr/defun.htm"><b>defun</b></a> or <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a> of <a href="../ansicl/dictentr/fdefinit.htm"><b>fdefinition</b></a>)</li>
  <li id="138">defining it as a macro (e.g. with <a href="../ansicl/dictentr/defmacro.htm"><b>defmacro</b></a>)</li>
  <li id="139">defining it as a type specifier (with <a href="../ansicl/dictentr/defstruc.htm"><b>defstruct</b></a>, <a href="../ansicl/dictentr/defclass.htm"><b>defclass</b></a>,
    <a href="../ansicl/dictentr/deftype.htm"><b>deftype</b></a>)</li>
  <li id="140">defining it as a structure (with <a href="../ansicl/dictentr/defstruc.htm"><b>defstruct</b></a>)</li>
  <li id="141">defining it as a symbol macro</li>
  <li id="142">defining it as a compiler macro</li>
  <li id="143">if the symbol is <a href="../ansicl/dictentr/fboundp.htm"><b>fboundp</b></a>, lexically binding it with <a href="../ansicl/dictentr/fletlabe.htm"><b>flet</b></a>,
    <a href="../ansicl/dictentr/fletlabe.htm"><b>labels</b></a>, or <a href="../ansicl/dictentr/fletlabe.htm"><b>macrolet</b></a></li>
</ul>

<p id="144">Function names that are lists are also protected if the important
symbol (usually the cadr, e.g. <i>border</i> in <code>(setf
border)</code>) in the list is in the definition-locked package. We
repeat here the definition of <a href="operators/excl/package-definition-lock.htm"><b>package-definition-lock</b></a> because it describes
how the lock can be circumvented.</p>

<blockquote>
  <blockquote>
    <p id="145"><strong>package-definition-lock</strong> </p>
    <p id="146">Arguments: <em>package</em></p>
    <p id="147">Returns <code>t</code> or <code>nil</code> as package is or is not
    definition-locked. <em>package</em> must be a package object (it cannot be a symbol or a
    string). <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a> may be used with this function to definition-lock or unlock
    a package.</p>
    <p id="148">Even if a package is package-definition-locked, no error will be signaled when</p>
    <blockquote>
      <ol>
        <li id="149">the value of <a href="variables/excl/s_enable-package-locked-errors_s.htm"><code>*enable-package-locked-errors*</code></a>
          is <code>nil</code>;</li>
        <li id="150">the violation is dynamically inside the body of a call to the macro <a href="operators/excl/without-package-locks.htm"><b>without-package-locks</b></a>; </li>
        <li id="151">the list returned by
          applying <strong>package-implementation-packages</strong> to
          the value of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> contains the home package of
          the symbol being operated on. Implementation packages are
          defined just below. Note that unless you have specified a
          list of implementation packages for a package that does not
          include the package itself (which would be unusual), no
          error will be signaled when <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> is the home package of the
          symbol being operated on. Also, no error is signaled
          if the value of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> is the home package
          of the symbol being operated on regardless of the contents
          of <strong>package-implementation-packages</strong>.
  </li>
      </ol>
    </blockquote>
    <p id="152">If a violation is encountered while compiling a file, a warning is signaled rather than
    an error. If the resulting <em>fasl</em> file is loaded, an error will then be signaled.</p>
  </blockquote>
</blockquote>



<hr><h2 id="153"><a name="implementation-packages-2">6.3 Implementation packages</a></h2>

<p id="154">
Allegro CL allows a package to have a list of associated packages
(called <em>implementation packages</em>). No warning or error will be
signaled for a definition or redefinition in one package when the
value of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> is an
implementation package of that package. Both <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> and <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a> have been extended to accept an
<i>implementation-packages</i> keyword
argument and the setfable function <a href="operators/excl/package-implementation-packages.htm"><b>package-implementation-packages</b></a> accesses that
list of packages.</p>

<p id="155">
The value of the <i>implementation-packages</i> argument
to <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a> should be a
list of strings naming packages. The <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> form should contain a subform which
is a list whose first element is
<code>:implementation-packages</code> and whose remaining
elements are strings naming the desired packages (as shown in the
example below). When unspecified, the list of implementation packages
defaults to a list containing the string naming the package being
defined. The <i>implementation-packages</i> argument is
not standard Common Lisp. You may wish to conditionalize it in
portable code, as shown next.
</p>

<pre id="156">
(defpackage :mypack 
    #+allegro (:implementation-packages "MYPACK"
                                        "MYPACK-2")
                ; other options as desired
   )
</pre>

<p id="157">
The <code>:implementation-packages</code> option will only be
read by Allegro CL. Note that since we specified a value, we had to
include "MYPACK" as well as "MYPACK-2" in order to
allow symbols whose home package is <code>mypack</code> to be
redefined without warning or error while the value of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> is the
<code>mypack</code> package.
</p>

<p id="158">
Note that implementation packages protects against warnings and
errors for package definition locks only. Package locks (the
distinction is described above) are not affected.
</p>

<p id="159">
Here is an example. Suppose we define two packages: foo and
bar. "BAR" is on the
<code>:implementation-packages</code> list for
<strong>foo</strong>, but "FOO" is not on the
<code>:implementation-packages</code> list for
<code>bar</code>.  Both packages are definition-locked.
</p>


<pre id="160">
(defpackage :foo (:implementation-packages "FOO" "BAR"))
(defpackage :bar)
(setf (package-definition-lock (find-package :foo)) t)
(setf (package-definition-lock (find-package :bar)) t)
</pre>

<p id="161">
Consider the following two files. The first starts with
<code>(in-package :bar)</code> and defines a function on
<b>foo::mysym</b>. The second starts with
<code>(in-package :foo)</code> and defines a function on
<b>bar::my-other-sym</b>. Compiling or
loading the first file signals no warning or error, since the bar
package is an implementation package for the foo package. The second
signals a warning on compilation and an error on loading because the
<code>foo</code> package is not an implementation package for the
<code>bar</code> package.
</p>


<pre id="162">
;; File # 1
;; Compiling or loading this file will not signal a warning 
;; (for compilation)

;; or an error (for loading) even if the FOO package is 
;; definition locked,
;; because the BAR package is an implementation package of 
;; the FOO package.
(in-package :bar)
(defun foo::mysym (a b ) (+ a b))

;; File # 2
;; Compiling or loading this file will signal a warning 
;; (for compilation)
;; or an error (for loading) if the BAR package is definition 
;; locked, because
;; the FOO package is not an implementation package 
;; of the BAR package.
(in-package :foo)
(defun bar::my-other-sym (c) (sqrt c))
</pre>



<hr><h2 id="163"><a name="package-locked-errors-2">6.4 Package locked errors</a></h2>

<p id="164">
The following script shows what happens when you try to perform a
protected action on a package-locked package. Here we try to export
the symbol <code>excl::*debug-enclose-printer-errors*</code>
from the <code>excl</code> package.</p>

<pre id="165">
USER(3): (export 'excl:: *debug-enclose-printer-errors* 
                 (find-package :excl))
Error: #&lt;The EXCL package&gt; is locked against changes by EXPORT.
[condition type: PACKAGE-LOCKED-ERROR]

Restart actions (select using :continue):
0: Allow EXPORT to modify #&lt;The EXCL package&gt;.
[1c] USER(4):
</pre>

<p id="166">The next script shows what happens when you try to define a
function on a symbol in a package-definition-locked package. We try to
define a function on the symbol
<code>excl:*read-init-files*</code>. We chose this admittedly
strange example to make clear that a symbol need not already have a
function definition (the symbol in question does not) in order for an
error to be signaled.</p>

<pre id="167">
USER(18): (defun excl:*read-init-files* nil nil)
Error: Attempt to make a FUNCTION definition for the name
EXCL:*READ-INIT-FILES*. This name is in 
the EXCL package and defining it is a violation for
portable programs. The package EXCL has 
PACKAGE-LOCK-DEFINITIONS set, which causes the system 
to check for this violation.
[condition type: PACKAGE-LOCKED-ERROR]

Restart actions (select using :continue):
0: Set the FUNCTION definition of the name 
EXCL:*READ-INIT-FILES* anyway.
[1c] USER(19):
</pre>

<p id="168">In each case, the error has condition type package-locked-error and
in each case the error is continuable. By entering <i>:continue 0</i>,
the requested action (exporting the symbol or defining the function)
will take place. </p>

<p id="169">Note however that package locking is in place for a reason:
changing a system-supplied package or defining (or particularly
redefining) a function on a symbol in a system-supplied package can
cause Lisp to fail because assumptions about the package are
violated. </p>

<p id="170">Obviously there are times when changing a package or the definition
on a symbol is the right thing to do. If, for example, we instruct you
to make some change (say, export a symbol accidentally left off an
export list), we are guaranteeing that doing so will not have adverse
consequences.</p>



<hr><h2 id="171"><a name="circumventing-package-locked-errors-2">6.5 Locally circumventing package locked errors</a></h2>

<p id="172">The variable <a href="variables/excl/s_enable-package-locked-errors_s.htm"><code>*enable-package-locked-errors*</code></a> and macro
<a href="operators/excl/without-package-locks.htm"><b>without-package-locks</b></a> can be
used to prevent package-locked-errors (of either type -- ordinary
locks and definition locks) without actually unlocking a package. </p>

<p id="173">When <a href="variables/excl/s_enable-package-locked-errors_s.htm"><code>*enable-package-locked-errors*</code></a> is true,
executing code that violates package-locking or
package-definition-locking will signal errors and compiling such code
will signal warnings as described above. When it is <code>nil</code>, such code will execute without
package-locked-errors or compile-time warnings.</p>

<p id="174">The macro <a href="operators/excl/without-package-locks.htm"><b>without-package-locks</b></a>, which takes one or more
forms as its arguments, evaluates those forms with <a href="variables/excl/s_enable-package-locked-errors_s.htm"><code>*enable-package-locked-errors*</code></a>
bound to <code>nil</code>.</p>



<hr><h2 id="175"><a name="default-locked-packages-2">6.6 The packages locked by default</a></h2>

<p id="176">For symbols in the <code>common-lisp</code> package, all of
the actions prevented by package locking and package definition
locking are explicitly restricted by the ANSI specification (see
sections 11.1.2.1.2 and 11.1.2.1.2.1). The
<code>common-lisp</code> package is locked and definition locked
as are a number of Allegro CL packages, including</p>

<pre id="177">
    aclmop
    aclwin (Windows only)
    clos
    cltl1
    common-graphics (Windows only)
    common-lisp
    compiler
    cross-reference
    debugger
    defsystem
    excl
    excl.scm
    foreign-functions
    inspect
    lep
    multiprocessing
    profiler
    system
    top-level
</pre>



<hr><h2 id="178"><a name="package-locking-justification-2">6.7 Justification for package locking</a></h2>

<p id="179">For the <code>common-lisp</code> package, the restrictions of both
package-locks and package-lock-definitions locks are compliant with
the ANSI standard. Other system-provided packages in Allegro CL are
also locked, for the same reasons that the
<code>common-lisp</code> package is locked.</p>

<p id="180">Writers of application packages may want to lock their packages as
well, especially if the package may be used by other packages written
later. Package locks can detect inadvertent name collisions before
they cause program failures. The following forms will package-lock and
package-definition-lock the package <code>foo</code>. The same
forms, with <code>nil</code> instead of <code>t</code>, unlock the package.</p>

<pre id="181">
(setf (excl:package-lock (find-package :foo)) t)
(setf (excl:package-definition-lock (find-package :foo)) t)
</pre>




</body><hr><p id="2"><small>Copyright (c) 1998-2017, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br>
<small>This page was not revised from the 10.0 page.</small><br><small>Created 2017.2.15.</small><br>
</p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faq/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 10.1</b><br><small><a href="introduction.htm#updates-s">Unrevised from 10.0 to 10.1.</a></small><br><a href="http://www.franz.com/support/documentation/10.0/doc/packages.htm">10.0 version</a></td></tr></table></html>